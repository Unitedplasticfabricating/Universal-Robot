<URProgram name="Cover Corner" installation="default" installationRelativePath="default" directory="/programs" createdIn="5.14.5" lastSavedIn="5.21.3" robotSerialNumber="20246801938" createdInPolyscopeProgramVersion="2" lastSavedInPolycopeProgramVersion="2" crcValue="924418886">
  <kinematics status="LINEARIZED" validChecksum="true">
    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
  </kinematics>
  <children>
    <InitVariablesNode>
      <variables>
        <variable name="free_dr_already">
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </variable>
        <variable name="freedrive_m_var">
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </variable>
      </variables>
    </InitVariablesNode>
    <SpecialSequence type="BeforeStart">
      <children>
        <Folder name="Safe Home Folder" keepHidden="false">
          <children>
            <Comment comment="if robot is not at home, send it back to home safely"/>
            <Comment comment="make sure the tcp is welder"/>
            <Set type="NoAction">
              <tcp referencedName="pretend_welder"/>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="sp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_tcp_pose"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" referencedName="Joint_0_name"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../Assignment/variable"/>
                </Waypoint>
                <Comment comment="if first move is to a variable, skip automove"/>
              </children>
            </Move>
            <Comment comment="turn off welder"/>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR0"/>
                <data key="Command" value="[252,82,48]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Set type="DigitalOutput">
              <pin referencedName="digital_out[0]"/>
              <digitalValue>0</digitalValue>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="jp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_joint_positions"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="s"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="["/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
                <ExpressionChar character="&gt;"/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="0"/>
              </expression>
              <children>
                <Comment comment="if x &gt; 600 then above then home"/>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../Move/feature"/>
                  <children>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_47" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.266942326222555, -1.1744836431792756, 1.6532800833331507, 1.0039457517811279, -0.0024531523333948257, -1.5362089315997522"/>
                          <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                            <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                            <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                            <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                            <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="Waypoint_76" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
                <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
              </children>
            </If>
            <If type="Else" checkContinuously="false">
              <expression/>
              <children>
                <Popup type="Message" haltProgram="false" message="retreating to home" inputType="Text"/>
                <Comment comment="for rules 2-8, finish with oldhome then above then home"/>
                <If type="If" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="5"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if oldhome, test teach, then go straight to oldhome"/>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="5"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="4"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="7"/>
                  </expression>
                  <children>
                    <Comment comment="if left side weld approach, left weld approach in reverse"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <Waypoint type="Fixed" name="Waypoint_50" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.021522347127095998, -1.2794721287539979, 2.4323821703540247, 5.090870934515753, -2.2996109167682093, 1.533644199371338"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_51" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.1454814116107386, -1.5427037247321387, 2.8454700152026575, 4.979047852545538, -4.902958456669943, 1.5718834400177002"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_52" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.2978580633746546, -1.3217003357461472, 2.2583277861224573, 3.7025129038044433, -2.952825371419088, 0.9627944231033325"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_53" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.7676661650287073, -1.8206430874266566, 2.312763277684347, 1.0122546392628173, -1.0765226523028772, -0.8102834860431116"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                  </expression>
                  <children>
                    <Comment comment="if right side around, move back then wapoint 24 then oldhome"/>
                    <If type="If" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="s"/>
                        <ExpressionChar character="p"/>
                        <ExpressionChar character="["/>
                        <ExpressionChar character="0"/>
                        <ExpressionChar character="]"/>
                        <ExpressionChar character="&lt;"/>
                        <ExpressionChar character="-"/>
                        <ExpressionChar character="1"/>
                        <ExpressionChar character="."/>
                        <ExpressionChar character="0"/>
                      </expression>
                      <children>
                        <Assignment valueSource="Expression">
                          <variable name="xback" prefersPersistentValue="false" favourite="false">
                            <initializeExpression/>
                          </variable>
                          <expression>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="-"/>
                            <ExpressionChar character="1"/>
                            <ExpressionChar character="."/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="1"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="2"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="3"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="4"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="5"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character="]"/>
                          </expression>
                        </Assignment>
                        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                          <feature class="GeomFeatureReference" reference="../../../../../../../../Move/feature"/>
                          <children>
                            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                              <motionParameters/>
                              <variable reference="../../../../Assignment/variable"/>
                            </Waypoint>
                          </children>
                        </Move>
                      </children>
                    </If>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <Waypoint type="Fixed" name="Waypoint_54" kinematicsFlags="-1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.9617512861834925, -1.2994225782207032, 2.207935158406393, 0.745708628291748, 1.5955500602722168, 1.41863214969635"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if left side second half, then left weld ending sequence"/>
                    <If type="If" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="j"/>
                        <ExpressionChar character="p"/>
                        <ExpressionChar character="["/>
                        <ExpressionChar character="5"/>
                        <ExpressionChar character="]"/>
                        <ExpressionChar character="&lt;"/>
                        <ExpressionChar character="0"/>
                        <ExpressionChar character="."/>
                        <ExpressionChar character="3"/>
                        <ExpressionChar character="5"/>
                      </expression>
                      <children>
                        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                          <feature class="GeomFeatureReference" reference="../../../../../../../../Move/feature"/>
                          <children>
                            <Waypoint type="Fixed" name="Waypoint_65" kinematicsFlags="1">
                              <motionParameters/>
                              <position>
                                <JointAngles angles="0.11527767777442932, -1.206728772526123, 2.660132948552267, 3.2525827127644042, -4.69939905801882, -0.18521625200380498"/>
                                <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                                <Kinematics status="LINEARIZED" validChecksum="true">
                                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                                </Kinematics>
                              </position>
                              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                            </Waypoint>
                          </children>
                        </Move>
                      </children>
                    </If>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_61" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.6650493780719202, -0.3235338491252442, 1.7927187124835413, 3.2544242578693847, -4.704199973736898, 1.262176513671875"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_62" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.03908092180360967, -0.2939794820598145, 1.7487567106830042, 3.2439190584370117, -4.706024233494894, -0.9516757170306605"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_63" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.5884297529803675, -1.2237849694541474, 2.732112232838766, 3.207263632411621, -4.698813978825704, 0.5185537934303284"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_64" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="0.11528298258781433, -1.206734911804535, 2.660121027623312, 3.252600832576416, -4.6993935743915, -0.18521625200380498"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment comment="above is testing, below is real"/>
                        <Waypoint type="Fixed" name="Waypoint_55" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.89636737505068, -1.198587493305542, 2.6061368624316614, 3.3119169908710937, -4.700617257748739, 0.826545238494873"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_60" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-1.0328291098224085, -0.2980014842799683, 2.121174160634176, 2.9023844438740234, -4.711147491131918, 1.783251166343689"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Waypoint type="Fixed" name="Waypoint_59" kinematicsFlags="1">
                          <motionParameters nextMotionTime="2.0"/>
                          <position>
                            <JointAngles angles="-1.1454528013812464, -1.5427289356342335, 2.8454795519458216, 4.979044186859884, -4.902960960065023, 1.5718833208084106"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_71" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.3941848913775843, -1.6550847492613734, 2.7336130777942103, 4.156678839320801, -3.798194471989767, 1.7310842275619507"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_58" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.651280705128805, -1.7712346516051234, 2.617981735860006, 3.3066598612019042, -2.656208101903097, 0.8563313484191895"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_56" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.0344861189471644, -1.9012485943236292, 2.469647232686178, 2.2012061315723876, -1.1677187124835413, -0.5094392935382288"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_57" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.920837704335348, -1.9932075939574183, 2.3856611887561243, 0.6815890508839111, -0.5688460508929651, -1.1506975332843226"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="9"/>
                  </expression>
                  <children>
                    <Comment comment="bottom homing"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_66" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.3470967451678675, -0.032737569218017626, 1.3673046270953577, -2.895853658715719, 1.5969500541687012, 1.9293429851531982"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment/>
                        <If type="If" checkContinuously="false">
                          <expression>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character="&lt;"/>
                            <ExpressionChar character="-"/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character="."/>
                            <ExpressionChar character="9"/>
                            <ExpressionChar character="5"/>
                          </expression>
                          <children>
                            <Assignment valueSource="Expression">
                              <variable reference="../../../../../../../../If[3]/children/If/children/Assignment/variable"/>
                              <expression>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="-"/>
                                <ExpressionChar character="0"/>
                                <ExpressionChar character="."/>
                                <ExpressionChar character="9"/>
                                <ExpressionChar character="5"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="1"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="2"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="3"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="4"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="5"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character="]"/>
                              </expression>
                            </Assignment>
                            <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                              <feature class="GeomFeatureReference" reference="../../../../../../../../../../Move/feature"/>
                              <children>
                                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                                  <motionParameters/>
                                  <variable reference="../../../../../../../../../../If[3]/children/If/children/Assignment/variable"/>
                                </Waypoint>
                              </children>
                            </Move>
                          </children>
                        </If>
                        <Waypoint type="Fixed" name="Waypoint_67" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.410516087208883, -0.9778240484050293, 2.47756010690798, -1.72361483196401, -0.3956816832171839, 1.808600902557373"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if left side homing, special unspin"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_68" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="0.03963470458984375, -0.7528810066035767, 1.6842077414142054, -0.7365346711925049, -3.6980724970446985, 1.6390107870101929"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment/>
                        <Waypoint type="Fixed" name="Waypoint_69" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.22154647508730108, -1.118469015961029, 2.7561236063586634, -1.5568565337783475, -3.851987902318136, 1.559481143951416"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_70" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.1281922499286097, -1.0678585332683106, 2.4290812651263636, -2.7994214497008265, -1.6034835020648401, 1.7401196956634521"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="("/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionToken token=" or "/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character=")"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="5"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="5"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="2"/>
                  </expression>
                  <children>
                    <Comment comment="go straight to home"/>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="1"/>
                  </expression>
                  <children>
                    <Comment comment="if none of the other options, then error continuously"/>
                    <Loop type="While" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="2"/>
                        <ExpressionChar character="&gt;"/>
                        <ExpressionChar character="1"/>
                      </expression>
                      <children>
                        <Popup type="Message" haltProgram="false" message="Unknown Position. Find Calvin for Assistance" inputType="Text"/>
                      </children>
                    </Loop>
                  </children>
                </If>
                <Comment comment="insert logic for how to get back to oldhome"/>
                <Comment comment="finish with oldhome then above then home"/>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="Waypoint_49" kinematicsFlags="3">
                      <motionParameters jointSpeed="1.0471975511965976" jointAcceleration="1.3962634015954636" cartesianSpeed="0.25" cartesianAcceleration="1.2"/>
                      <position>
                        <JointAngles angles="-3.4579480330096644, -2.0568953953185023, 2.3266006151782435, -0.2270372670939942, -0.1993797461139124, -0.10534602800478154"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_48" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.266932551060812, -1.1745034915259858, 1.653294865285055, 1.0039614874073486, -0.002454582844869435, -1.5362089315997522"/>
                          <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                            <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                            <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                            <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                            <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="Waypoint_75" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
                <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
              </children>
            </If>
            <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
              <dataModel>
                <data key="type" value="addMotor"/>
                <data key="numberAdded" value="0"/>
                <data key="speed_in_mm_per_min" value="600"/>
                <data key="acceleration_in_mm_per_s2" value="50.0"/>
                <data key="teachColor" value="BLUE"/>
                <data key="combo1" value="MachineMotion1"/>
                <data key="combo2" value="(1) Custom Actuator"/>
                <data key="combo3" value="Home"/>
                <data key="combo6" value="In series"/>
                <data key="message" value="Homing"/>
                <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
                <data key="comboAddress" value="Address 1"/>
                <data key="comboActuator" value="Valve 1"/>
              </dataModel>
            </Contributed>
          </children>
        </Folder>
      </children>
    </SpecialSequence>
    <MainProgram runOnlyOnce="true" InitVariablesNode="true">
      <children>
        <Comment comment="start of main program"/>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Script type="File">
          <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# based on a Corner Homing 45 Cover pattern of touchpoints
# this uses those touchpoints to create a representation of the corner in 3d robot space. 
def analyze_touchpoints_only_cover(p11, p12, p21, p3):
    zcoord=p3[2]
    
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x

    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]

    # equate the second line in 2d space
    # ml2 = opposite reciprocal of ml1 (because they are perpendicular) (assume perpendicular to make calculation of weldpath much easier)
    ml2 = -1 / ml1

    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x

    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1

    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]

    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect

    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p1x - xintersect
    l2delyfull = l2p1y - yintersect

    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag

    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. this line is from pointintersect and along each edge of the corner
    heading1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    heading3 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (heading1 + heading3)/2

    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

def get_corner_homing_45_pathpoints_cover(point0):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
    
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.04 # first distance from init point
    d2 = 0.15 # second distance from init point
    d4 = 0.06 # top distance from init point - larger to avoid large chamfers
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
    
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
    
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
    #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
    
    # approach point for top
    ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner. 
    
    # top point
    ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
    is_robot_at_reachable_spot(point0, ret)
    return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i &lt; structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
  
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

def main_calculate_step_right(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
    return struct2
end

def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
    return struct2
end

# analyze_touchpoints_only()
# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
#   FIND HEADINGS
#for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
# so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box. 
# we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
def step_right_demo(struct1):
    pointintersect = struct1[0]
    x = pointintersect[0]
    y = pointintersect[1]
    z = pointintersect[2]
    heading1 = struct1[1]
    heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
    heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
    # heading1 == heading1adj2. ok 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
    popup(point_demo)
    movej(point_demo, a=1.4, v=0.1)
    popup(point_demo)
    ret = struct(point_demo = point_demo)
    return ret
end

# for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld. 
def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on left side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1 
    # only use the right side taps for circle move related things
    heading3basedh1 = heading1 - pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
    # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
    heading1descr = heading1 - pi
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l1delxunit * rod
    p4y = y + l1delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l1delxunit * wd2
    p5y = y + l1delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on right side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1 
    # only use the left side taps for circle move related things
    heading1basedh3 = heading3 + pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l2delxunit * rod
    p4y = y + l2delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l2delxunit * wd2
    p5y = y + l2delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
# returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
def calc_rod_midpoint_90deg(rod):
    # the factor is (1- 1/sqrt(2))
    factor = 0.292893
    ret = rod * factor
    return ret
end

# this is the main entry point for calculations, for Cover Corner.
# it takes in the 4 touchpoints, analyzes the shape of the box. 
# returns the pathpoints
# specifically for Around and Down then Straight (AtS)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_cover(p11, p12, p21, p3, leftwallthick, rightwallthick, leftchoice):
    struct1 = analyze_touchpoints_only_cover(p11, p12, p21, p3)
    if leftchoice:
        struct2 = calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick)
    else:
        struct2 = calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick)
    end
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
end

def calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 4 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end
    
    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1
    p1x = x + l1delxunit * wd1
    p1y = y + l1delyunit * wd1
    point1 = p[p1x, p1y, z, rx, ry, rz]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l1delxunit * rod
    p2y = y + l1delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    wtod = 0.015 # weldturnoffdistance # meters from pointtopvcham # 10 mm (1.0 seconds)
    p2ax = x + l1delxunit * wtod
    p2ay = y + l1delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]
    
    # calculate the rxryrz for facing the down the left side of the box
    # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading3 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l2delxunit * pushtipforward2
    p201by = p201y + l2delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a)
    return struct2
end

def calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 4 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end

    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]

    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # next, calculate point1
    p1x = x + l2delxunit * wd1
    p1y = y + l2delyunit * wd1
    point1 = p[p1x, p1y, z, rx, ry, rz]

    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l2delxunit * rod
    p2y = y + l2delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    wtod = 0.015 # weldturnoffdistance # meters from pointtopvcham # 10 mm (1.0 seconds)
    p2ax = x + l2delxunit * wtod
    p2ay = y + l2delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]

    # calculate the rxryrz for facing the down the right side of the box
    # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]

    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit

    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]

    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward

    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l1delxunit * pushtipforward2
    p201by = p201y + l1delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]

    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]

    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a)
    return struct2
end
</cachedContents>
          <file>/programs/analyze_touchpoints.script</file>
        </Script>
        <SuppressedNode>
          <suppressedNode class="Script" type="Line">
            <expression>
              <ExpressionChar character="w"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="l"/>
              <ExpressionChar character="d"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="d"/>
              <ExpressionChar character="y"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Operator" message="Select Yes for a Left side weld, or select No for a Right Side weld." valueType="Boolean">
          <variable name="leftchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <Assignment valueSource="Operator" message="Is the capping wall 3/4 inch?" valueType="Boolean">
          <variable name="floorchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="f"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="e"/>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="floorthick" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="8"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="7"/>
                <ExpressionChar character="5"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <Assignment valueSource="Operator" message="Is the other wall 3/4 inch?" valueType="Boolean">
          <variable name="sidewallchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionVariable>
              <ProgramVariable reference="../../../../Assignment[3]/variable"/>
            </ExpressionVariable>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="sidewall" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="8"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If[3]/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="7"/>
                <ExpressionChar character="5"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_46" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-3.266944233571188, -1.1744955343059083, 1.6532734076129358, 1.003952904338501, -0.002457443867818654, -1.5361955801593226"/>
                <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="NoAction">
          <tcp referencedName="pretend_w_top"/>
        </Set>
        <Script type="Line">
          <expression>
            <ExpressionChar character="T"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="T"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="P"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../Set[2]/tcp"/>
        </Set>
        <Script type="Line">
          <expression>
            <ExpressionChar character="k"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character=" "/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="I"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="T"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="1"/>
          </expression>
        </Script>
        <Script type="Line">
          <expression>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="H"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="path1" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="a"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="l"/>
              <ExpressionChar character="y"/>
              <ExpressionChar character="z"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="c"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="i"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="("/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="CallSubProgram"/>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_19" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.7325146834002894, -1.1100619596293946, 2.5569477717029017, 0.15985266744580073, 1.4753735065460205, 3.3034157752990723"/>
                  <TCPOffset pose="0.00855, -0.27152, 0.102, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="l"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="≟"/>
            <ExpressionToken token=" True "/>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="pathturn" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="("/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="s"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="w"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Script type="Line">
              <expression>
                <ExpressionChar character="e"/>
                <ExpressionChar character="x"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
            <Script type="Line">
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If[5]/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="("/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="s"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="w"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Script type="Line">
              <expression>
                <ExpressionChar character="e"/>
                <ExpressionChar character="x"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
            <Script type="Line">
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="g"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </If>
      </children>
    </MainProgram>
    <SubProgram name="align_for_cover_left" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_for_cover_left.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Folder" name="dummypoints" keepHidden="false">
            <children>
              <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                <feature class="GeomFeatureReference" reference="../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                <children>
                  <Comment comment="startpoint: oldhome"/>
                  <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.4611328426873, -2.0623207793499674, 2.329160332900075, -0.21924456446498652, -0.2009788370788126, -0.11039879152515653"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy left start"/>
                  <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="4">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.0538056879199513, -2.6742425054854273, -0.6374733179630976, -2.978794509912973, 0.8911860770965965, 0.004599663033619118"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="approach point near shoulder"/>
                  <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="4">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-2.977835455580779, -1.8478377370769383, -2.007182568140033, -2.434874955750219, 0.9678560292809983, 0.0036113126149359687"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                </children>
              </Move>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Folder name="actualprogram" keepHidden="false">
          <children>
            <Folder name="liftcolumnup" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable name="liftcolumnz" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="c"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="z"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                  </expression>
                </Assignment>
                <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
                  <dataModel>
                    <data key="type" value="addMotor"/>
                    <data key="numberAdded" value="0"/>
                    <data key="acceleration_in_mm_per_s2" value="50.0"/>
                    <data key="ActuatorPos" value="liftcolumnz"/>
                    <data key="speed_in_mm_per_min" value="3000.0"/>
                    <data key="teachColor" value="BLUE"/>
                    <data key="combo1" value="MachineMotion1"/>
                    <data key="combo2" value="(1) Custom Actuator"/>
                    <data key="combo3" value="Move to Position"/>
                    <data key="combo6" value="In series"/>
                    <data key="message" value="Move to Position"/>
                    <data key="description" value="Moves the actuator to a specified position from the home location."/>
                    <data key="comboAddress" value="Address 1"/>
                    <data key="comboActuator" value="Valve 1"/>
                  </dataModel>
                </Contributed>
              </children>
            </Folder>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_21" kinematicsFlags="4">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-2.918409517091006, -1.130700698023488, -2.096373719624969, -2.2849817795239993, 0.8961046798977055, 0.10799070352990178"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
                <Waypoint type="Fixed" name="Waypoint_22" kinematicsFlags="-1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-2.977835455580779, -1.8478377370769383, -2.007182568140033, -2.434874955750219, 0.9678560292809983, 0.0036113126149359687"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Folder>
      </children>
    </SubProgram>
    <SubProgram name="align_for_cover_right" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_for_cover_right.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Folder" name="dummypoints" keepHidden="false">
            <children>
              <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                <feature class="GeomFeatureReference" reference="../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                <children>
                  <Comment comment="startpoint: oldhome"/>
                  <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.4611328426873, -2.0623207793499674, 2.329160332900075, -0.21924456446498652, -0.2009788370788126, -0.11039879152515653"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy start right"/>
                  <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.29049961919197287, -1.1819831404078718, 1.334465833195068, -0.17409121259363225, 2.0099089258476623, -0.009438179428446603"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy start right 2"/>
                  <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.1104716957103129, -0.980541586809573, 1.0560350620627785, -0.09941936143260843, 2.18984876960206, -0.014276884747548735"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="approach point close to shoulder"/>
                  <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.9252587377076562, -1.9106813901052684, 2.580357834681599, -0.6901398423967073, 1.3752736098591445, 0.0039154434748498446"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                </children>
              </Move>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Folder name="actualprogram" keepHidden="false">
          <children>
            <Folder name="liftcolumnup" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../../../SubProgram/children/Folder/children/Folder/children/Assignment/variable"/>
                  <expression>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="c"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="z"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                  </expression>
                </Assignment>
                <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
                  <dataModel>
                    <data key="type" value="addMotor"/>
                    <data key="numberAdded" value="0"/>
                    <data key="acceleration_in_mm_per_s2" value="50.0"/>
                    <data key="ActuatorPos" value="liftcolumnz"/>
                    <data key="speed_in_mm_per_min" value="3000.0"/>
                    <data key="teachColor" value="BLUE"/>
                    <data key="combo1" value="MachineMotion1"/>
                    <data key="combo2" value="(1) Custom Actuator"/>
                    <data key="combo3" value="Move to Position"/>
                    <data key="combo6" value="In series"/>
                    <data key="message" value="Move to Position"/>
                    <data key="description" value="Moves the actuator to a specified position from the home location."/>
                    <data key="comboAddress" value="Address 1"/>
                    <data key="comboActuator" value="Valve 1"/>
                  </dataModel>
                </Contributed>
              </children>
            </Folder>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-3.4611328426873005, -2.0623207793499674, 2.329160332900076, -0.21924456446498652, -0.2009788370788117, -0.11039879152515564"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
                <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="3">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.9252587377076562, -1.9106813901052684, 2.580357834681599, -0.6901398423967073, 1.3752736098591445, 0.0039154434748498446"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Folder>
      </children>
    </SubProgram>
    <SubProgram name="move_path_cover_left3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/move_path_cover_left3.urp</programFile>
      <children>
        <Comment/>
        <Script type="Line">
          <expression>
            <ExpressionChar character="a"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp referencedName="backofhole"/>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable name="p1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p5" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pa1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p4a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p2a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pa1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="p1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>8.0</waitTime>
        </Wait>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../../../SpecialSequence/children/Folder/children/Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[8]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="dummyvar" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionToken token=" True "/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed[2]/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="p2" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveP" speed="5.0E-4" acceleration="0.01" blendRadius="0.001" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <CircleMove OrientationMode="FIXED">
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable name="p3" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable name="p4" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
              </children>
            </CircleMove>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>4.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.012" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="p5" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../../../SpecialSequence/children/Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable name="pret1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="1"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="2"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="pret2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="-"/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_1" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../Assignment[3]/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="6"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_4" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_5" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable name="p201" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p202" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201b" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="8"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201c" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_preheat" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_pre_ret" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_pre_ret2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../SuppressedNode[2]/suppressedNode/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="retreat of p5"/>
            <Waypoint type="Fixed" name="Waypoint_6" kinematicsFlags="4">
              <motionParameters/>
              <position>
                <JointAngles angles="-2.503819662579805, -2.1076337372495892, -2.275962047042132, -1.9004743836489615, 1.3994194205792434, 1.571324733063948"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="dummypoint" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.41165382066835754, -0.7046496433070812, 1.0278294722186718, -0.30475409448659985, -1.3570078055011177, -0.01810008684267217"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="dummyret4p202" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.29118168425203006, -0.6923505048639953, 0.9660675043035383, -0.25348952983543693, -1.110187083325532, -0.02315869782612623"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="requires a shoulder flip. safe waypoints for that:"/>
            <Waypoint type="Fixed" name="Waypoint_9" kinematicsFlags="4">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.9737304628485504, -1.344748989694347, -2.2088795437767974, -1.7501578224355292, 0.9718193787935403, 1.511259645642839"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_15" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.2853152196519062, -1.6491975265833752, 1.5282079038237402, -0.6595344440871038, -1.457284994100636, -0.0759705702208393"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="approach of p201"/>
            <Waypoint type="Fixed" name="Waypoint_16" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret3" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[11]/variable"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[13]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>6.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[14]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[15]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <Move motionType="MoveL" speed="0.012" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="p202" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder[2]/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret4" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_17" kinematicsFlags="-1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
          <dataModel>
            <data key="type" value="addMotor"/>
            <data key="numberAdded" value="0"/>
            <data key="speed_in_mm_per_min" value="600"/>
            <data key="acceleration_in_mm_per_s2" value="50.0"/>
            <data key="teachColor" value="BLUE"/>
            <data key="combo1" value="MachineMotion1"/>
            <data key="combo2" value="(1) Custom Actuator"/>
            <data key="combo3" value="Home"/>
            <data key="combo6" value="In series"/>
            <data key="message" value="Homing"/>
            <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
            <data key="comboAddress" value="Address 1"/>
            <data key="comboActuator" value="Valve 1"/>
          </dataModel>
        </Contributed>
      </children>
    </SubProgram>
    <SubProgram name="move_path_cover_right3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/move_path_cover_right3.urp</programFile>
      <children>
        <Comment/>
        <Script type="Line">
          <expression>
            <ExpressionChar character="a"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../../../SubProgram[3]/children/Set/tcp"/>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[3]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[4]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[5]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[6]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[7]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[8]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[2]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>8.0</waitTime>
        </Wait>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[8]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[4]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveP" speed="5.0E-4" acceleration="0.01" blendRadius="0.001" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <CircleMove OrientationMode="FIXED">
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable reference="../../../../../../../../SubProgram[3]/children/Move[5]/children/CircleMove/children/Waypoint/variable"/>
                </Waypoint>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable reference="../../../../../../../../SubProgram[3]/children/Move[5]/children/CircleMove/children/Waypoint[2]/variable"/>
                </Waypoint>
              </children>
            </CircleMove>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>4.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[7]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[9]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[10]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="1"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="2"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[2]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="-"/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[3]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[4]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/Assignment[3]/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="6"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[6]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[7]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[11]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[12]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[13]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[14]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="8"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[15]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[16]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[17]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[8]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[9]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[10]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[8]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/SuppressedNode[2]/suppressedNode/variable"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="retreat of p5"/>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="4">
                <motionParameters/>
                <position>
                  <JointAngles angles="-2.503819662579805, -2.1076337372495892, -2.275962047042132, -1.9004743836489615, 1.3994194205792434, 1.571324733063948"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="dummypoint" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.41165382066835754, -0.7046496433070812, 1.0278294722186718, -0.30475409448659985, -1.3570078055011177, -0.01810008684267217"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="dummyret4p202" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.29118168425203006, -0.6923505048639953, 0.9660675043035383, -0.25348952983543693, -1.110187083325532, -0.02315869782612623"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="requires a shoulder flip. safe waypoints for that:"/>
              <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="4">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.9737304628485504, -1.344748989694347, -2.2088795437767974, -1.7501578224355292, 0.9718193787935403, 1.511259645642839"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.2853152196519062, -1.6491975265833752, 1.5282079038237402, -0.6595344440871038, -1.457284994100636, -0.0759705702208393"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="approach of p201"/>
              <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[13]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[13]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>6.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[14]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[15]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../Folder/children/Contributed[2]/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <Move motionType="MoveL" speed="0.012" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[16]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed[2]/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[17]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_20" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.1084698903771084, -1.6120482505177893, 2.1904850640545614, -0.5440229802855612, -0.5713420496459127, -0.0431436282365123"/>
                <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
          <dataModel>
            <data key="type" value="addMotor"/>
            <data key="numberAdded" value="0"/>
            <data key="speed_in_mm_per_min" value="600"/>
            <data key="acceleration_in_mm_per_s2" value="50.0"/>
            <data key="teachColor" value="BLUE"/>
            <data key="combo1" value="MachineMotion1"/>
            <data key="combo2" value="(1) Custom Actuator"/>
            <data key="combo3" value="Home"/>
            <data key="combo6" value="In series"/>
            <data key="message" value="Homing"/>
            <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
            <data key="comboAddress" value="Address 1"/>
            <data key="comboActuator" value="Valve 1"/>
          </dataModel>
        </Contributed>
      </children>
    </SubProgram>
    <SubProgram name="Test_Teach_Position_Cover" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/Test Teach Position Cover.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-2.527531687413351, -2.1028810940184535, 2.591139856969015, -2.0582763157286585, -1.5713656584369105, 2.1834325790405273"/>
                  <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Comment comment="move welder up out of holder"/>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="false" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <tcp referencedName="TCP_1_plate"/>
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_40" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-3.4579489866839808, -2.0569035015501917, 2.3265796343432825, -0.22706706941638188, -0.1993501822101038, -0.10534793535341436"/>
                <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
            <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.0516188780414026, -1.010990933781006, 2.1562450567828577, -1.143702046280243, -1.0526168982135218, -0.0017235914813440445"/>
                <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="freedrive_m_var" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../Assignment/variable"/>
          <expression>
            <ExpressionToken token=" True "/>
          </expression>
        </Assignment>
        <Popup type="Message" haltProgram="false" message="Move the TCP to the corner of the tank, then click &apos;Continue&apos;" inputType="Text"/>
        <Assignment valueSource="Expression">
          <variable name="tcp_pose" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../Assignment/variable"/>
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </Assignment>
        <Wait type="Sleep">
          <waitTime>0.25</waitTime>
        </Wait>
        <Script type="Line">
          <expression>
            <ExpressionChar character="s"/>
            <ExpressionChar character="y"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_left" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_left.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable name="cp" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="aligned_y_pose" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="6"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="extrude_knife3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/extrude_knife3.urp</programFile>
      <children>
        <Folder name="pre program stuff" keepHidden="false">
          <children>
            <Set type="NoAction">
              <tcp reference="../../../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="ek_sp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_tcp_pose"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Move motionType="MoveL" speed="0.005" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../Assignment/variable"/>
                </Waypoint>
              </children>
            </Move>
            <SuppressedNode>
              <suppressedNode class="Script" type="File">
                <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  joints_1 = get_inverse_kin(pose, orig_joints)
  #iterate through the 6 joints
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - orig_joints[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  return allGood
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end
</cachedContents>
                <file>/programs/analyze_touchpoints.script</file>
              </suppressedNode>
            </SuppressedNode>
          </children>
        </Folder>
        <Comment comment="list possible points"/>
        <Folder name="robot 1 moves" keepHidden="false">
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="1"/>
                <ExpressionChar character="≟"/>
                <ExpressionChar character="2"/>
              </expression>
              <children>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="r1_ek_oldhome" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_extrude" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_front" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_middle" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_middle2" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_bottom" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_end" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
              </children>
            </If>
          </children>
        </Folder>
        <Folder name="robot 2 moves" keepHidden="false">
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="1"/>
                <ExpressionChar character="≟"/>
                <ExpressionChar character="2"/>
              </expression>
              <children>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="r2_ek_oldhome" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.461132842686933, -2.062320779349874, 2.32916033290004, -0.21924456446492258, -0.20097883707844666, -0.11039879152527199"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.190347370661634, -1.4265640510241013, 2.191586797737077, -0.7413809357659105, -0.33101111967973296, -0.09495351526939722"/>
                          <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                            <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                            <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                            <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                            <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="r2_ek_extrude" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.199475796455825, -1.4862854517875999, 2.263543898005424, -0.6928175084157413, -0.09183293866530295, -0.15653548683830643"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_front" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2029012478485694, -1.4943971905029905, 2.3176866046272355, -0.727203417516419, -0.10461513056100813, -0.1013922369747533"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_middle" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2036200175167613, -1.5006788185274456, 2.326226188945654, -0.730095076239345, -0.10533288811000929, -0.10075548926859312"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_bottom" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.204010221105431, -1.5099366263094405, 2.3272215014458872, -0.722096275899732, -0.10572512264357048, -0.10049057923478166"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_end" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.205098875769389, -1.5204959829395506, 2.3387656715508855, -0.724001524008818, -0.10681294496314919, -0.09956563917089412"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
              </children>
            </If>
          </children>
        </Folder>
        <Comment comment="detemine correct points for which robot"/>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="r"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="≟"/>
            <ExpressionChar character="1"/>
          </expression>
          <children>
            <Folder name="robot1 positions" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable name="ek_oldhome" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="h"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_extrude" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="x"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_front" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_middle" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_middle2" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_bottom" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="b"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_end" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="q"/>
                  </expression>
                </Assignment>
              </children>
            </Folder>
          </children>
        </If>
        <If type="ElseIf" checkContinuously="false">
          <expression>
            <ExpressionChar character="r"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="≟"/>
            <ExpressionChar character="2"/>
          </expression>
          <children>
            <Folder name="robot1 positions" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="h"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[2]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="x"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[3]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[4]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[5]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[6]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="b"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[7]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="q"/>
                  </expression>
                </Assignment>
              </children>
            </Folder>
          </children>
        </If>
        <Comment comment="start of program"/>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_oldhome" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment/variable"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
          </children>
        </Move>
        <Comment comment="move above bucket"/>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_extrude" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Comment comment="extrude out a foot"/>
        <SuppressedNode>
          <suppressedNode class="Script" type="Line">
            <expression>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="x"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="i"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>1</digitalValue>
        </Set>
        <Wait type="Sleep">
          <waitTime>24.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment comment="slice"/>
        <Move motionType="MoveL" speed="0.03" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_front" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_middle" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_middle2" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_bottom" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_end" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[3]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[4]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[5]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[6]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_oldhome" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment/variable"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_forward" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_forward.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="6"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[6]/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_up" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_up.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[6]/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="Corner_Homing_45_Cover" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/Corner Homing 45 Cover.urp</programFile>
      <children>
        <Comment comment="Use this program when tool is already positioned close to corner at 45deg"/>
        <Comment comment="tool flange will seek all 3 sides. will save those 5 locs in p__"/>
        <Set type="NoAction">
          <tcp reference="../../../../MainProgram/children/Set[2]/tcp"/>
        </Set>
        <Comment comment="dummy move below for debug"/>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="demo_point0" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6836307684527796, -1.0886919063380738, 1.8533313910113733, -1.1951357883265992, 0.36088186502456665, 0.17399978637695312"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.1356399695025843, -0.8834679287723084, 2.671961847935812, -1.629258771935934, 0.611339807510376, 1.4263536930084229"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6423338095294397, -0.9283088010600586, 2.3237603346454065, -1.2926811438849946, 1.1005513668060303, 1.510843276977539"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Assignment valueSource="Expression">
          <variable name="tp" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Script type="File">
          <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# based on a Corner Homing 45 Cover pattern of touchpoints
# this uses those touchpoints to create a representation of the corner in 3d robot space. 
def analyze_touchpoints_only_cover(p11, p12, p21, p3):
    zcoord=p3[2]
    
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x

    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]

    # equate the second line in 2d space
    # ml2 = opposite reciprocal of ml1 (because they are perpendicular) (assume perpendicular to make calculation of weldpath much easier)
    ml2 = -1 / ml1

    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x

    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1

    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]

    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect

    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p1x - xintersect
    l2delyfull = l2p1y - yintersect

    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag

    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. this line is from pointintersect and along each edge of the corner
    heading1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    heading3 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (heading1 + heading3)/2

    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

def get_corner_homing_45_pathpoints_cover(point0):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
    
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.04 # first distance from init point
    d2 = 0.15 # second distance from init point
    d4 = 0.06 # top distance from init point - larger to avoid large chamfers
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
    
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
    
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
    #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
    
    # approach point for top
    ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner. 
    
    # top point
    ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
    is_robot_at_reachable_spot(point0, ret)
    return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i &lt; structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
  
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

def main_calculate_step_right(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
    return struct2
end

def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
    return struct2
end

# analyze_touchpoints_only()
# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
#   FIND HEADINGS
#for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
# so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box. 
# we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
def step_right_demo(struct1):
    pointintersect = struct1[0]
    x = pointintersect[0]
    y = pointintersect[1]
    z = pointintersect[2]
    heading1 = struct1[1]
    heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
    heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
    # heading1 == heading1adj2. ok 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
    popup(point_demo)
    movej(point_demo, a=1.4, v=0.1)
    popup(point_demo)
    ret = struct(point_demo = point_demo)
    return ret
end

# for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld. 
def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on left side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1 
    # only use the right side taps for circle move related things
    heading3basedh1 = heading1 - pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
    # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
    heading1descr = heading1 - pi
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l1delxunit * rod
    p4y = y + l1delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l1delxunit * wd2
    p5y = y + l1delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on right side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1 
    # only use the left side taps for circle move related things
    heading1basedh3 = heading3 + pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l2delxunit * rod
    p4y = y + l2delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l2delxunit * wd2
    p5y = y + l2delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
# returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
def calc_rod_midpoint_90deg(rod):
    # the factor is (1- 1/sqrt(2))
    factor = 0.292893
    ret = rod * factor
    return ret
end

# this is the main entry point for calculations, for Cover Corner.
# it takes in the 4 touchpoints, analyzes the shape of the box. 
# returns the pathpoints
# specifically for Around and Down then Straight (AtS)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_cover(p11, p12, p21, p3, leftwallthick, rightwallthick, leftchoice):
    struct1 = analyze_touchpoints_only_cover(p11, p12, p21, p3)
    if leftchoice:
        struct2 = calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick)
    else:
        struct2 = calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick)
    end
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
end

def calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 4 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end
    
    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1
    p1x = x + l1delxunit * wd1
    p1y = y + l1delyunit * wd1
    point1 = p[p1x, p1y, z, rx, ry, rz]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l1delxunit * rod
    p2y = y + l1delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    wtod = 0.015 # weldturnoffdistance # meters from pointtopvcham # 10 mm (1.0 seconds)
    p2ax = x + l1delxunit * wtod
    p2ay = y + l1delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]
    
    # calculate the rxryrz for facing the down the left side of the box
    # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading3 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l2delxunit * pushtipforward2
    p201by = p201y + l2delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a)
    return struct2
end

def calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 4 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end

    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]

    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # next, calculate point1
    p1x = x + l2delxunit * wd1
    p1y = y + l2delyunit * wd1
    point1 = p[p1x, p1y, z, rx, ry, rz]

    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l2delxunit * rod
    p2y = y + l2delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    wtod = 0.015 # weldturnoffdistance # meters from pointtopvcham # 10 mm (1.0 seconds)
    p2ax = x + l1delxunit * wtod
    p2ay = y + l1delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]

    # calculate the rxryrz for facing the down the right side of the box
    # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]

    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit

    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]

    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward

    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l1delxunit * pushtipforward2
    p201by = p201y + l1delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]

    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]

    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a)
    return struct2
end
</cachedContents>
          <file>/programs/analyze_touchpoints.script</file>
        </Script>
        <Assignment valueSource="Expression">
          <variable name="path_pre" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="g"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph5" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph6" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph7" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="ph2up" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="ph4up" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[3]/variable"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_18" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.4527270065814086, -1.5335080666897793, 2.331465577553839, -0.7978622473340167, -0.6551352271038269, -4.318663923239541E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[4]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="p11" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[4]/variable"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_18" kinematicsFlags="-1">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.4527270065814086, -1.5335080666897793, 2.331465577553839, -0.7978622473340167, -0.6551352271038269, -4.318663923239541E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[5]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p13" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionToken token="get_actual_tcp_pose"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../SuppressedNode[4]/suppressedNode/variable"/>
              </Waypoint>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[5]/variable"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <gui.program.direction.MoveDirectionNode>
                <expression class="ExpressionBranch">
                  <ExpressionChar character="["/>
                  <ExpressionChar character="-"/>
                  <ExpressionChar character="1"/>
                  <ExpressionChar character=","/>
                  <ExpressionChar character="-"/>
                  <ExpressionChar character="1"/>
                  <ExpressionChar character="."/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character=","/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character="."/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character="]"/>
                </expression>
                <children>
                  <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
                </children>
              </gui.program.direction.MoveDirectionNode>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable name="p12" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[5]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[3]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.9805802500330287, -1.776402843114571, 2.5402932176735167, -0.7636784153299869, 0.7364093853225739, -4.7636853491450637E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.026244747181998207, -1.640187288787068, 2.4226740052170705, -0.6078304005137403, 2.4762680113591635, 0.13253734890858748"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702387017062684, 2.492185179387228, -1.7834822140135707, -0.33723670641054326, 1.8489984273910522"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.1354392210589808, -1.0039964479259034, 2.441021744404928, -2.875528474847311, -1.6043828169452112, 1.7329596281051636"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <SuppressedNode>
                <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_5" kinematicsFlags="1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.26738197008241826, -1.11244489372287, 2.793460194264547, -1.547202582736947, -4.00090462366213, 1.5620925426483154"/>
                    <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                      <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                      <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                      <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                      <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </suppressedNode>
              </SuppressedNode>
              <Waypoint type="Fixed" name="Waypoint_10" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.556256119404928, -1.0744255942157288, 2.9114087263690394, -1.7763501606383265, -4.185837809239523, 1.5288889408111572"/>
                  <TCPOffset pose="-0.0011568140153006695, -0.095603710023444, 0.2575950646467742, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[6]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="p21" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[6]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="demo" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.009823083093752238, -1.0619960093747771, 1.6464553941979907, -0.40598839384763163, 2.538895015150203, 0.12566061136358356"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_8" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.01715496240946024, -1.494545279446406, 2.2672250278044364, -0.5958806326806094, 2.5316554411695993, 0.12363151404680206"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Fixed" name="Waypoint_10" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.02556298299657378, -1.7236099938373233, 2.481788294620727, -0.5833114718704184, 2.5232984892167174, 0.12127481998396572"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_11" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.056348542397287815, -1.755951936284177, 2.687083281983292, -1.2239132866197675, 1.4020418579316969, 1.382286188783346"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_12" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.07847491298553244, -1.1667344858175497, 2.6853522647108843, -3.0537863367367724, -1.5263486092027065, 4.7222922273042975"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_7" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.05711347261537725, -1.0985367459109803, 2.4025002161609095, -2.8401085338988246, -1.5255449453936976, 4.743709564208984"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[8]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[9]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode selectedDirection="ZMinus">
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[3]/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[9]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[8]/variable"/>
            </Waypoint>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_13" kinematicsFlags="-1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.07847491298553244, -1.1667344858175497, 2.6853522647108843, -3.0537863367367724, -1.5263486092027065, 4.7222922273042975"/>
                    <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[9]/variable"/>
              </Waypoint>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[8]/variable"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_14" kinematicsFlags="-1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702451390079041, 2.492171827946798, -3.0669099293150843, 1.575993537902832, 2.355180025100708"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="-1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702387017062684, 2.492185179387228, -1.7834822140135707, -0.33723670641054326, 1.8489984273910522"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_41" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.4579578081714075, -2.0569120846190394, 2.3265841642962855, -0.22706885755572515, -0.1993349234210413, -0.10534984270204717"/>
                  <TCPOffset pose="0.0, -0.004, 0.284, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Comment comment="above waypoint is home"/>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
      </children>
    </SubProgram>
    <Thread name="Thread_1" runOnlyOnce="true">
      <children>
        <Loop type="While" checkContinuously="false">
          <expression>
            <ExpressionToken token=" True "/>
          </expression>
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionVariable>
                  <ProgramVariable reference="../../../../../../../../SubProgram[5]/children/Assignment/variable"/>
                </ExpressionVariable>
                <ExpressionChar character="≟"/>
                <ExpressionToken token=" True "/>
              </expression>
              <children>
                <Script type="Line">
                  <expression>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="v"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="("/>
                    <ExpressionChar character=")"/>
                  </expression>
                </Script>
                <Assignment valueSource="Expression">
                  <variable name="free_dr_already" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionToken token=" True "/>
                  </expression>
                </Assignment>
              </children>
            </If>
            <If type="Else" checkContinuously="false">
              <expression/>
              <children>
                <If type="If" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="a"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="a"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="y"/>
                  </expression>
                  <children>
                    <Script type="Line">
                      <expression>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="n"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="_"/>
                        <ExpressionChar character="f"/>
                        <ExpressionChar character="r"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="r"/>
                        <ExpressionChar character="i"/>
                        <ExpressionChar character="v"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="_"/>
                        <ExpressionChar character="m"/>
                        <ExpressionChar character="o"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="("/>
                        <ExpressionChar character=")"/>
                      </expression>
                    </Script>
                  </children>
                </If>
              </children>
            </If>
            <Script type="Line">
              <expression>
                <ExpressionChar character="s"/>
                <ExpressionChar character="y"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </Loop>
      </children>
    </Thread>
    <SuppressedNode>
      <suppressedNode class="Thread" name="Thread_2" runOnlyOnce="false">
        <children>
          <Loop type="While" checkContinuously="false">
            <expression>
              <ExpressionToken token=" True "/>
            </expression>
            <children>
              <If type="If" checkContinuously="false">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="h"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="a"/>
                  <ExpressionChar character="d"/>
                  <ExpressionChar character="2"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="g"/>
                  <ExpressionChar character="g"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="≟"/>
                  <ExpressionToken token=" True "/>
                </expression>
                <children>
                  <Comment comment="do the dot extrude"/>
                  <Wait type="Sleep">
                    <waitTime>5.0</waitTime>
                  </Wait>
                  <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
                    <dataModel>
                      <data key="byte_array" value="true"/>
                      <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                      <data key="Command" value="[252,82,49]"/>
                      <data key="QUERY" value="false"/>
                      <data key="OUTPUT_ENTRY" value="Static"/>
                      <Variable key="OUTPUT_VARIABLE">
                        <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                          <initializeExpression/>
                        </variable>
                      </Variable>
                    </dataModel>
                  </Contributed>
                  <Wait type="Sleep">
                    <waitTime>2.0</waitTime>
                  </Wait>
                  <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
                    <dataModel>
                      <data key="QUERY" value="false"/>
                      <data key="NODE_TITLE" value="Serial Bridge uR0"/>
                      <data key="Command" value="[252,82,48]"/>
                      <data key="byte_array" value="true"/>
                      <data key="OUTPUT_ENTRY" value="Static"/>
                      <Variable key="OUTPUT_VARIABLE">
                        <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                          <initializeExpression/>
                        </variable>
                      </Variable>
                    </dataModel>
                  </Contributed>
                  <Assignment valueSource="Expression">
                    <variable name="thread2trigger" prefersPersistentValue="false" favourite="false">
                      <initializeExpression/>
                    </variable>
                    <expression>
                      <ExpressionToken token=" False "/>
                    </expression>
                  </Assignment>
                </children>
              </If>
              <Script type="Line">
                <expression>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="y"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="c"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </Script>
            </children>
          </Loop>
        </children>
      </suppressedNode>
    </SuppressedNode>
  </children>
</URProgram>