<URProgram name="Cover Corner" installation="default" installationRelativePath="../default" directory="/programs/UPF" createdIn="5.14.5" lastSavedIn="5.21.3" robotSerialNumber="20246801938" createdInPolyscopeProgramVersion="2" lastSavedInPolycopeProgramVersion="2" crcValue="924418886">
  <kinematics status="LINEARIZED" validChecksum="true">
    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
  </kinematics>
  <children>
    <InitVariablesNode>
      <variables>
        <variable name="free_dr_already">
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </variable>
        <variable name="freedrive_m_var">
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </variable>
      </variables>
    </InitVariablesNode>
    <SpecialSequence type="BeforeStart">
      <children>
        <Folder name="Safe Home Folder" keepHidden="false">
          <children>
            <Comment comment="if robot is not at home, send it back to home safely"/>
            <Comment comment="make sure the tcp is welder"/>
            <Set type="NoAction">
              <tcp referencedName="pretend_welder"/>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="sp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_tcp_pose"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" referencedName="Joint_0_name"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../Assignment/variable"/>
                </Waypoint>
                <Comment comment="if first move is to a variable, skip automove"/>
              </children>
            </Move>
            <Comment comment="turn off welder"/>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR0"/>
                <data key="Command" value="[252,82,48]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Set type="DigitalOutput">
              <pin referencedName="digital_out[0]"/>
              <digitalValue>0</digitalValue>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="jp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_joint_positions"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="s"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="["/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
                <ExpressionChar character="&gt;"/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="0"/>
              </expression>
              <children>
                <Comment comment="if x &gt; 600 then above then home"/>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../Move/feature"/>
                  <children>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_47" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.266942326222555, -1.1744836431792756, 1.6532800833331507, 1.0039457517811279, -0.0024531523333948257, -1.5362089315997522"/>
                          <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                            <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                            <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                            <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                            <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="Waypoint_76" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
                <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
              </children>
            </If>
            <If type="Else" checkContinuously="false">
              <expression/>
              <children>
                <Popup type="Message" haltProgram="false" message="retreating to home" inputType="Text"/>
                <Comment comment="for rules 2-8, finish with oldhome then above then home"/>
                <If type="If" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="5"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if oldhome, test teach, then go straight to oldhome"/>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="5"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="4"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="7"/>
                  </expression>
                  <children>
                    <Comment comment="if left side weld approach, left weld approach in reverse"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <Waypoint type="Fixed" name="Waypoint_50" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.021522347127095998, -1.2794721287539979, 2.4323821703540247, 5.090870934515753, -2.2996109167682093, 1.533644199371338"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_51" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.1454814116107386, -1.5427037247321387, 2.8454700152026575, 4.979047852545538, -4.902958456669943, 1.5718834400177002"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_52" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.2978580633746546, -1.3217003357461472, 2.2583277861224573, 3.7025129038044433, -2.952825371419088, 0.9627944231033325"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_53" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.7676661650287073, -1.8206430874266566, 2.312763277684347, 1.0122546392628173, -1.0765226523028772, -0.8102834860431116"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="4"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="7"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                  </expression>
                  <children>
                    <Comment comment="if right side around, move back then wapoint 24 then oldhome"/>
                    <If type="If" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="s"/>
                        <ExpressionChar character="p"/>
                        <ExpressionChar character="["/>
                        <ExpressionChar character="0"/>
                        <ExpressionChar character="]"/>
                        <ExpressionChar character="&lt;"/>
                        <ExpressionChar character="-"/>
                        <ExpressionChar character="1"/>
                        <ExpressionChar character="."/>
                        <ExpressionChar character="0"/>
                      </expression>
                      <children>
                        <Assignment valueSource="Expression">
                          <variable name="xback" prefersPersistentValue="false" favourite="false">
                            <initializeExpression/>
                          </variable>
                          <expression>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="-"/>
                            <ExpressionChar character="1"/>
                            <ExpressionChar character="."/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="1"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="2"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="3"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="4"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character=","/>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="5"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character="]"/>
                          </expression>
                        </Assignment>
                        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                          <feature class="GeomFeatureReference" reference="../../../../../../../../Move/feature"/>
                          <children>
                            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                              <motionParameters/>
                              <variable reference="../../../../Assignment/variable"/>
                            </Waypoint>
                          </children>
                        </Move>
                      </children>
                    </If>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <Waypoint type="Fixed" name="Waypoint_54" kinematicsFlags="-1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.9617512861834925, -1.2994225782207032, 2.207935158406393, 0.745708628291748, 1.5955500602722168, 1.41863214969635"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="6"/>
                    <ExpressionChar character="2"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="8"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if left side second half, then left weld ending sequence"/>
                    <If type="If" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="j"/>
                        <ExpressionChar character="p"/>
                        <ExpressionChar character="["/>
                        <ExpressionChar character="5"/>
                        <ExpressionChar character="]"/>
                        <ExpressionChar character="&lt;"/>
                        <ExpressionChar character="0"/>
                        <ExpressionChar character="."/>
                        <ExpressionChar character="3"/>
                        <ExpressionChar character="5"/>
                      </expression>
                      <children>
                        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                          <feature class="GeomFeatureReference" reference="../../../../../../../../Move/feature"/>
                          <children>
                            <Waypoint type="Fixed" name="Waypoint_65" kinematicsFlags="1">
                              <motionParameters/>
                              <position>
                                <JointAngles angles="0.11527767777442932, -1.206728772526123, 2.660132948552267, 3.2525827127644042, -4.69939905801882, -0.18521625200380498"/>
                                <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                                <Kinematics status="LINEARIZED" validChecksum="true">
                                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                                </Kinematics>
                              </position>
                              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                            </Waypoint>
                          </children>
                        </Move>
                      </children>
                    </If>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_61" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.6650493780719202, -0.3235338491252442, 1.7927187124835413, 3.2544242578693847, -4.704199973736898, 1.262176513671875"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_62" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.03908092180360967, -0.2939794820598145, 1.7487567106830042, 3.2439190584370117, -4.706024233494894, -0.9516757170306605"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_63" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.5884297529803675, -1.2237849694541474, 2.732112232838766, 3.207263632411621, -4.698813978825704, 0.5185537934303284"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_64" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="0.11528298258781433, -1.206734911804535, 2.660121027623312, 3.252600832576416, -4.6993935743915, -0.18521625200380498"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment comment="above is testing, below is real"/>
                        <Waypoint type="Fixed" name="Waypoint_55" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.89636737505068, -1.198587493305542, 2.6061368624316614, 3.3119169908710937, -4.700617257748739, 0.826545238494873"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_60" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-1.0328291098224085, -0.2980014842799683, 2.121174160634176, 2.9023844438740234, -4.711147491131918, 1.783251166343689"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Waypoint type="Fixed" name="Waypoint_59" kinematicsFlags="1">
                          <motionParameters nextMotionTime="2.0"/>
                          <position>
                            <JointAngles angles="-1.1454528013812464, -1.5427289356342335, 2.8454795519458216, 4.979044186859884, -4.902960960065023, 1.5718833208084106"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_71" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.3941848913775843, -1.6550847492613734, 2.7336130777942103, 4.156678839320801, -3.798194471989767, 1.7310842275619507"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_58" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.651280705128805, -1.7712346516051234, 2.617981735860006, 3.3066598612019042, -2.656208101903097, 0.8563313484191895"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_56" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.0344861189471644, -1.9012485943236292, 2.469647232686178, 2.2012061315723876, -1.1677187124835413, -0.5094392935382288"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_57" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-2.920837704335348, -1.9932075939574183, 2.3856611887561243, 0.6815890508839111, -0.5688460508929651, -1.1506975332843226"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="9"/>
                  </expression>
                  <children>
                    <Comment comment="bottom homing"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_66" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="-0.3470967451678675, -0.032737569218017626, 1.3673046270953577, -2.895853658715719, 1.5969500541687012, 1.9293429851531982"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment/>
                        <If type="If" checkContinuously="false">
                          <expression>
                            <ExpressionChar character="s"/>
                            <ExpressionChar character="p"/>
                            <ExpressionChar character="["/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character="]"/>
                            <ExpressionChar character="&lt;"/>
                            <ExpressionChar character="-"/>
                            <ExpressionChar character="0"/>
                            <ExpressionChar character="."/>
                            <ExpressionChar character="9"/>
                            <ExpressionChar character="5"/>
                          </expression>
                          <children>
                            <Assignment valueSource="Expression">
                              <variable reference="../../../../../../../../If[3]/children/If/children/Assignment/variable"/>
                              <expression>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="-"/>
                                <ExpressionChar character="0"/>
                                <ExpressionChar character="."/>
                                <ExpressionChar character="9"/>
                                <ExpressionChar character="5"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="1"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="2"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="3"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="4"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character=","/>
                                <ExpressionChar character="s"/>
                                <ExpressionChar character="p"/>
                                <ExpressionChar character="["/>
                                <ExpressionChar character="5"/>
                                <ExpressionChar character="]"/>
                                <ExpressionChar character="]"/>
                              </expression>
                            </Assignment>
                            <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                              <feature class="GeomFeatureReference" reference="../../../../../../../../../../Move/feature"/>
                              <children>
                                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                                  <motionParameters/>
                                  <variable reference="../../../../../../../../../../If[3]/children/If/children/Assignment/variable"/>
                                </Waypoint>
                              </children>
                            </Move>
                          </children>
                        </If>
                        <Waypoint type="Fixed" name="Waypoint_67" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.410516087208883, -0.9778240484050293, 2.47756010690798, -1.72361483196401, -0.3956816832171839, 1.808600902557373"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="j"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="4"/>
                  </expression>
                  <children>
                    <Comment comment="if left side homing, special unspin"/>
                    <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                      <feature class="GeomFeatureReference" reference="../../../../../../Move/feature"/>
                      <children>
                        <SuppressedNode>
                          <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_68" kinematicsFlags="1">
                            <motionParameters/>
                            <position>
                              <JointAngles angles="0.03963470458984375, -0.7528810066035767, 1.6842077414142054, -0.7365346711925049, -3.6980724970446985, 1.6390107870101929"/>
                              <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                              <Kinematics status="LINEARIZED" validChecksum="true">
                                <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                                <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                                <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                                <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                                <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                              </Kinematics>
                            </position>
                            <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                          </suppressedNode>
                        </SuppressedNode>
                        <Comment/>
                        <Waypoint type="Fixed" name="Waypoint_69" kinematicsFlags="1">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-0.22154647508730108, -1.118469015961029, 2.7561236063586634, -1.5568565337783475, -3.851987902318136, 1.559481143951416"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                        <Waypoint type="Fixed" name="Waypoint_70" kinematicsFlags="3">
                          <motionParameters/>
                          <position>
                            <JointAngles angles="-1.1281922499286097, -1.0678585332683106, 2.4290812651263636, -2.7994214497008265, -1.6034835020648401, 1.7401196956634521"/>
                            <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                            <Kinematics status="LINEARIZED" validChecksum="true">
                              <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                              <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                              <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                              <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                              <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                            </Kinematics>
                          </position>
                          <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                        </Waypoint>
                      </children>
                    </Move>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="("/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="3"/>
                    <ExpressionToken token=" or "/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="4"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="3"/>
                    <ExpressionChar character=")"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="-"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="5"/>
                    <ExpressionChar character="]"/>
                    <ExpressionToken token=" and "/>
                    <ExpressionChar character="s"/>
                    <ExpressionChar character="p"/>
                    <ExpressionChar character="["/>
                    <ExpressionChar character="5"/>
                    <ExpressionChar character="]"/>
                    <ExpressionChar character="&lt;"/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="."/>
                    <ExpressionChar character="0"/>
                    <ExpressionChar character="2"/>
                  </expression>
                  <children>
                    <Comment comment="go straight to home"/>
                  </children>
                </If>
                <If type="ElseIf" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="&gt;"/>
                    <ExpressionChar character="1"/>
                  </expression>
                  <children>
                    <Comment comment="if none of the other options, then error continuously"/>
                    <Loop type="While" checkContinuously="false">
                      <expression>
                        <ExpressionChar character="2"/>
                        <ExpressionChar character="&gt;"/>
                        <ExpressionChar character="1"/>
                      </expression>
                      <children>
                        <Popup type="Message" haltProgram="false" message="Unknown Position. Find Calvin for Assistance" inputType="Text"/>
                      </children>
                    </Loop>
                  </children>
                </If>
                <Comment comment="insert logic for how to get back to oldhome"/>
                <Comment comment="finish with oldhome then above then home"/>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="Waypoint_49" kinematicsFlags="3">
                      <motionParameters jointSpeed="1.0471975511965976" jointAcceleration="1.3962634015954636" cartesianSpeed="0.25" cartesianAcceleration="1.2"/>
                      <position>
                        <JointAngles angles="-3.4579480330096644, -2.0568953953185023, 2.3266006151782435, -0.2270372670939942, -0.1993797461139124, -0.10534602800478154"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_48" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.266932551060812, -1.1745034915259858, 1.653294865285055, 1.0039614874073486, -0.002454582844869435, -1.5362089315997522"/>
                          <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                            <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                            <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                            <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                            <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="Waypoint_75" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
                <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
              </children>
            </If>
            <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
              <dataModel>
                <data key="type" value="addMotor"/>
                <data key="numberAdded" value="0"/>
                <data key="speed_in_mm_per_min" value="600"/>
                <data key="acceleration_in_mm_per_s2" value="50.0"/>
                <data key="teachColor" value="BLUE"/>
                <data key="combo1" value="MachineMotion1"/>
                <data key="combo2" value="(1) Custom Actuator"/>
                <data key="combo3" value="Home"/>
                <data key="combo6" value="In series"/>
                <data key="message" value="Homing"/>
                <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
                <data key="comboAddress" value="Address 1"/>
                <data key="comboActuator" value="Valve 1"/>
              </dataModel>
            </Contributed>
          </children>
        </Folder>
      </children>
    </SpecialSequence>
    <MainProgram runOnlyOnce="true" InitVariablesNode="true">
      <children>
        <Comment comment="start of main program"/>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Script type="File">
          <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# based on a Corner Homing 45 Cover pattern of touchpoints
# this uses those touchpoints to create a representation of the corner in 3d robot space. 
def analyze_touchpoints_only_cover(p11, p12, p21, p3):
    zcoord=p3[2]
    
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x

    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]

    # equate the second line in 2d space
    # ml2 = opposite reciprocal of ml1 (because they are perpendicular) (assume perpendicular to make calculation of weldpath much easier)
    ml2 = -1 / ml1

    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x

    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1

    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]

    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect

    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p1x - xintersect
    l2delyfull = l2p1y - yintersect

    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag

    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. this line is from pointintersect and along each edge of the corner
    heading1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    heading3 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (heading1 + heading3)/2

    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

def get_corner_homing_45_pathpoints_cover(point0):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
    
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.04 # first distance from init point
    d2 = 0.15 # second distance from init point
    d4 = 0.06 # top distance from init point - larger to avoid large chamfers
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
    
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
    
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
    #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
    
    # approach point for top
    ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner. 
    
    # top point
    ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
    is_robot_at_reachable_spot(point0, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_cover(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points (the rxryrz are given in pretend_welder_top coordinates. they match pure rotations of 90 degrees)
    ph1 = p[lpx + d0, lpy, lpz - d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz - d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d2, lpy, lpz + d0, 2.221, -2.221, 0] # left top approach
    ph4 = p[rpx - d2, rpy, rpz + d0, 2.221, -2.221, 0] # right top approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_floor(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points
    ph1 = p[lpx + d0, lpy, lpz + d2, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz + d2, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d1, lpy, lpz - d0, 0, 0, 0] # left bottom approach
    ph4 = p[rpx - d1, rpy, rpz - d0, 0, 0, 0] # right bottom approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i &lt; structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
  
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

# this function takes in a struct of only points. it checks those points for validity. 
# if one of them is not valid, it throws a popup loop
def check_validity_only(struct2):
    validity = check_structofpoints_validity(struct2)
    if not validity:
    # bad
    popuptext = &quot;Not all weldpoints are valid. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Position Error&quot;,blocking=True)
    end
    end
end

def main_calculate_step(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top, leftseam, leftobstacle):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    if leftseam:
        if leftobstacle:
            struct2 = calculate_LtUA_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
            heading1deg = struct1[1] * 180/pi
            if heading1deg &lt; 210:
                popup(&quot;Robot is not aligned 45 degree angle from corner. Wrist pinch may bonk, Align robot 45 degrees from corner and try again. &quot;, title=&quot;Alignment Error&quot;,blocking=True)
            end
        else:
            struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
        end
    else:
        if leftobstacle:
            # error: this geometry is impossible for the robot to weld
            popup(&quot;Cannot weld a right seam, left obstacle step corner with robot. please weld by hand. &quot;, title=&quot;Geometry Error&quot;,blocking=True)
        else:
            struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
        end
    end
    validity = check_validity_only(struct2)
    return struct2
end

def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
    validity = check_validity_only(struct2)
    return struct2
end

# analyze_touchpoints_only()
# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
#   FIND HEADINGS
#for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
# so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box. 
# we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
def step_right_demo(struct1):
    pointintersect = struct1[0]
    x = pointintersect[0]
    y = pointintersect[1]
    z = pointintersect[2]
    heading1 = struct1[1]
    heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
    heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
    # heading1 == heading1adj2. ok 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
    popup(point_demo)
    movej(point_demo, a=1.4, v=0.1)
    popup(point_demo)
    ret = struct(point_demo = point_demo)
    return ret
end

# for a left seam step corner, calculate the toolpath points for a L (under) then Up and Around weld. for left obstacle step. 
def calculate_LtUA_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = tcp_pose_top[2] - pointintersect[2] # the z distance from the corner to the top of the weld
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    # get rxryrz for facing along towards the intersection. heading1 +90 deg - 90 deg
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    # get rxryrz for facing along the second edge pointed toward the left. heading 3 + 90 - 90
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # now calculate the points of the Up Around
    # don&apos;t use heading3 at all. 
    #point201 is at the chamfer intersection
    p201x = xbottom
    p201y = ybottom
    p201z = z
    
    # rxryrz is the same 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, p201z, rx, ry, rz]
    
    # find side point (point on the side. where point 203 would be if roundoverdistance was 0)
    sidex = pointintersect[0] + l2delxunit * rightwallthickmm
    sidey = pointintersect[1] + l2delyunit * rightwallthickmm
    sidez = z
    
    # p202
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p202x = sidex + rod * l1delxunit
    p202y = sidey + rod * l1delyunit
    p202z = sidez
    point202 = p[p202x, p202y, p202z, rx, ry, rz]
    
    # p204 end of circle move
    p204x = sidex
    p204y = sidey
    p204z = sidez + rod
    
    # calculate rxryrz
    # first rotation: 90 degrees about x axis. positive direction. preheat is now facing up, and gun tip is pointed towards y- direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 90 * pi / 180)
    # second rotation: rotate about z until you are facing into the front face. but only use heading 1
    # heading 1 is about 225 degrees. i need to go about 225 degrees. starting from y- instead of x+ cancels out the extra 90 degrees needed to go into face1 instead of parallel to face1
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point204 = p[p204x, p204y, p204z, rx, ry, rz]
    
    #p205 (end of straight after cirlce move, before listleans
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point205 = p[p204x, p204y, sidez + sld, rx, ry, rz]
    
    #p206 (top of weld)
    p206x = sidex + wd3 * listleans[0]
    p206y = sidey + wd3 * listleans[1]
    p206z = sidez + wd3
    point206 = p[p206x, p206y, p206z, rx, ry, rz]
    
    # p203 (middle of turn)
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p203z = sidez + delta
    p203x = sidex + delta * l1delxunit
    p203y = sidey + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 45 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point203 = p[p203x, p203y, p203z, rx, ry, rz]
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point201=point201, point202=point202, point203=point203, point204=point204, point205=point205, point206=point206)
    return struct2
end

# for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld. 
def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on left side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1 
    # only use the right side taps for circle move related things
    heading3basedh1 = heading1 - pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
    # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
    heading1descr = heading1 - pi
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l1delxunit * rod
    p4y = y + l1delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l1delxunit * wd2
    p5y = y + l1delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on right side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1 
    # only use the left side taps for circle move related things
    heading1basedh3 = heading3 + pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l2delxunit * rod
    p4y = y + l2delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l2delxunit * wd2
    p5y = y + l2delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
# returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
def calc_rod_midpoint_90deg(rod):
    # the factor is (1- 1/sqrt(2))
    factor = 0.292893
    ret = rod * factor
    return ret
end

# this is the main entry point for calculations, for Cover Corner.
# it takes in the 4 touchpoints, analyzes the shape of the box. 
# returns the pathpoints
# specifically for Around and Down then Straight (AtS)
# specifically for left-sided boxes (vertical weld on left side of edge)
# leftchoice is a boolean and deepcovercham is a boolean but leftwallthick, rightwallthick are decimals in inches. 
def main_calculate_cover(p11, p12, p21, p3, leftwallthick, rightwallthick, leftchoice, deepcovercham):
    struct1 = analyze_touchpoints_only_cover(p11, p12, p21, p3)
    if leftchoice:
        struct2 = calculate_LtAD_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham)
    else:
        struct2 = calculate_LtAD_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham)
    end
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
end

def calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end
    
    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 (start point on top of cover welding towards corner)
    p1x = x + l1delxunit * wd1 + deepchambumpmm * l2delxunit
    p1y = y + l1delyunit * wd1 + deepchambumpmm * l2delyunit
    point1 = p[p1x, p1y, z, rx, ry, rz]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l1delxunit * rod
    p2y = y + l1delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2. 
    if deepcovercham:
        speed = 6 # mm/s
        wtod = shutofftime * speed / 1000 #weldturnoffdistance
    else:
        speed = 10 # mm/s
        wtod = shutofftime * speed / 1000
    end
    p2ax = x + l1delxunit * wtod
    p2ay = y + l1delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]
    
    # calculate the rxryrz for facing the down the left side of the box
    # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx3 = rxryrz[0]
    ry3 = rxryrz[1]
    rz3 = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    #todo: calculate trail out points
    botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = x
    p101y = y
    p101z = z - wd2 + dist
    point101 = p[p101x, p101y, p101z, rx, ry, rz]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = x + l1delxunit * tiltraise * -1
    p102y = y + l1delyunit * tiltraise * -1
    p102z = z - wd2 + dist
    
    # calculate rxryrz
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point102 = p[p102x, p102y, p102z, rx, ry, rz]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * (leftwallthickmm + deepchambumpmm) + l2delxunit * pushtipforward 
    p201y = y + l1delyunit * (leftwallthickmm + deepchambumpmm) + l2delyunit * pushtipforward
    
    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading3 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l2delxunit * pushtipforward2
    p201by = p201y + l2delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
    return struct2
end

def calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end

    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]

    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # next, calculate point1 (start point on top of cover welding towards corner)
    p1x = x + l2delxunit * wd1 + deepchambumpmm * l1delxunit
    p1y = y + l2delyunit * wd1 + deepchambumpmm * l1delyunit
    point1 = p[p1x, p1y, z, rx, ry, rz]

    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l2delxunit * rod
    p2y = y + l2delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2. 
    if deepcovercham:
        speed = 6 # mm/s
        wtod = shutofftime * speed / 1000 #weldturnoffdistance
    else:
        speed = 10 # mm/s
        wtod = shutofftime * speed / 1000
    end
    p2ax = x + l2delxunit * wtod
    p2ay = y + l2delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]

    # calculate the rxryrz for facing the down the right side of the box
    # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]

    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit

    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx3 = rxryrz[0]
    ry3 = rxryrz[1]
    rz3 = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]

    #todo: calculate trail out point
    botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = x
    p101y = y
    p101z = z - wd2 + dist
    point101 = p[p101x, p101y, p101z, rx, ry, rz]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = x + l2delxunit * tiltraise * -1
    p102y = y + l2delyunit * tiltraise * -1
    p102z = z - wd2 + dist
    
    # calculate rxryrz
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point102 = p[p102x, p102y, p102z, rx, ry, rz]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * (rightwallthickmm + deepchambumpmm) + l1delxunit * pushtipforward
    p201y = y + l2delyunit * (rightwallthickmm + deepchambumpmm) + l1delyunit * pushtipforward

    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l1delxunit * pushtipforward2
    p201by = p201y + l1delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]

    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]

    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
    return struct2
end

def calculate_LtAD_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    x0 = pointintersect[0]
    y0 = pointintersect[1]
    z0 = pointintersect[2]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # CONST
    welddistance1 = 6 # first path first leg (left side of L)
    welddistance2 = 6 # first path second leg (Right Side of L) # inches
    welddistance3 = 3 # second path (down sidewall) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z0 = 0
    else:
        z0 = zpi
    end
    
    # first and second path
    
    # calculate rxryrz1 (facing down, preheat rightish)
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis)
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    # calculate rxryrz2 (gun facing down, preheat facing right and back)
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    # calculate point centerchamfers (where the center of the two chamfers intersect 
    pcx = x0 + (leftwallthickmm + deepchambumpmm) * l1delxunit + (rightwallthickmm + deepchambumpmm) * l2delxunit
    pcy = y0 + (leftwallthickmm + deepchambumpmm) * l1delyunit + (rightwallthickmm + deepchambumpmm) * l2delyunit
    pcz = z0
    
    # calculate point1 (start of weld)
    p1x = pcx + l2delxunit * wd1
    p1y = pcy + l2delyunit * wd1
    p1z = pcz
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # calculate point2 (end of segment 1)
    p2x = pcx
    p2y = pcy
    p2z = pcz
    point2 = p[p2x, p2y, p2z, rx1, ry1, rz1]
    
    # calculate point3 (point at end of turn)
    slide = 0.01 # slide distance : the distance the tip slides forward as it turns
    p3x = pcx + slide * l1delxunit
    p3y = pcy + slide * l1delyunit
    p3z = pcz
    point3 = p[p3x, p3y, p3z, rx2, ry2, rz2]
    
    # calculate point4 (end of segment 2)
    p4x = pcx + wd2 * l1delxunit
    p4y = pcy + wd2 * l1delyunit
    p4z = pcz
    point4 = p[p4x, p4y, p4z, rx2, ry2, rz2]
    
    # third path
    
    # calculate rxryrz3 (gun pointing down, preheat pointing toward corner. for left seam, pointing left)
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    # calculate rxryrz4 (gun at 45 around corner)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    # calculate rxryrz5 (gun straight into left seam side chamfer, preheat down)
    # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz5 = convert_matrix_to_axang(m3)
    rx5 = rxryrz5[0]
    ry5 = rxryrz5[1]
    rz5 = rxryrz5[2]
    
    # calculate pointtopcham (the point at the top of the endwall chamfer) ( WHERE POINT3 WOULD BE IF RADIUS WAS 0)
    ptcx = x0 + rightwallthickmm * l2delxunit
    ptcy = y0 + rightwallthickmm * l2delyunit
    ptcz = z0
    
    # calculate point201 (weld start)
    # if deepchamfer, just ignore that. because if its deep chamfer then it filled more as well. so the hot extrudant should be to the same spot (same distance from the pointtopcham) whether it&apos;s big weld or small weld 
    adjust = 0.0 # if you want to move the start point further away from corner (positive, mm) or closer to corner
    p201x = x0 + rightwallthickmm * l2delxunit + leftwallthickmm * l1delxunit + adjust * l1delxunit
    p201y = y0 + rightwallthickmm * l2delyunit + leftwallthickmm * l1delyunit + adjust * l1delyunit
    p201z = z0
    point201 = p[p201x, p201y, p201z, rx3, ry3, rz3]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # calculate point202 (start of roundover)
    p202x = ptcx + rod * l1delxunit
    p202y = ptcy + rod * l1delyunit
    p202z = z0
    point202 = p[p202x, p202y, p202z, rx3, ry3, rz3]
    
    # calculate point203 (middle of roundover)
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p203z = ptcz - delta
    p203x = ptcx + delta * l1delxunit
    p203y = ptcy + delta * l1delyunit
    point203 = p[p203x, p203y, p203z, rx4, ry4, rz4]
    
    # calculate point204 (end of roundover)
    point204 = p[ptcx, ptcy, ptcz - rod, rx5, ry5, rz5]
    
    # calculate trail out points (tilt back and ride)
    botvcham = wd3 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # point101 will still use backofhole, but points 102 and 103 will use normal weld tip tcp
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = ptcx
    p101y = ptcy
    p101z = ptcz - wd3 + dist
    point101 = p[p101x, p101y, p101z, rx5, ry5, rz5]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = ptcx + l1delxunit * tiltraise * -1
    p102y = ptcy + l1delyunit * tiltraise * -1
    p102z = ptcz - wd3 + dist
    
    # calculate rxryrz
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point102 = p[p102x, p102y, p102z, rx, ry, rz]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, ptcz - wd3 + dist, rx, ry, rz]
    
    # return
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point201=point201, point202=point202, point203=point203, point204=point204, point101=point101, point102=point102, point103=point103)
    return struct2
    
    
end

def calculate_LtAD_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    x0 = pointintersect[0]
    y0 = pointintersect[1]
    z0 = pointintersect[2]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # CONST
    welddistance1 = 6 # first path first leg (left side of L)
    welddistance2 = 6 # first path second leg (Right Side of L) # inches
    welddistance3 = 3 # second path (down sidewall) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z0 = 0
    else:
        z0 = zpi
    end
    
    # first and second path
    
    # calculate rxryrz1 (facing down, preheat rightish)
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis)
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    # calculate rxryrz2 (gun facing down, preheat facing right and back)
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    # calculate point centerchamfers (where the center of the two chamfers intersect 
    pcx = x0 + (leftwallthickmm + deepchambumpmm) * l1delxunit + (rightwallthickmm + deepchambumpmm) * l2delxunit
    pcy = y0 + (leftwallthickmm + deepchambumpmm) * l1delyunit + (rightwallthickmm + deepchambumpmm) * l2delyunit
    pcz = z0
    
    # calculate point1 (start of weld)
    p1x = pcx + l2delxunit * wd1
    p1y = pcy + l2delyunit * wd1
    p1z = pcz
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # calculate point2 (end of segment 1)
    p2x = pcx
    p2y = pcy
    p2z = pcz
    point2 = p[p2x, p2y, p2z, rx1, ry1, rz1]
    
    # calculate point3 (point at end of turn)
    slide = 0.01 # slide distance : the distance the tip slides forward as it turns
    p3x = pcx + slide * l1delxunit
    p3y = pcy + slide * l1delyunit
    p3z = pcz
    point3 = p[p3x, p3y, p3z, rx2, ry2, rz2]
    
    # calculate point4 (end of segment 2)
    p4x = pcx + wd2 * l1delxunit
    p4y = pcy + wd2 * l1delyunit
    p4z = pcz
    point4 = p[p4x, p4y, p4z, rx2, ry2, rz2]
    
    # third path
    
    # calculate rxryrz3 (gun pointing down, preheat pointing toward corner. for right seam, pointing right)
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    # calculate rxryrz4 (gun at 45 around corner)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    # calculate rxryrz5 (gun straight into right seam side chamfer, preheat down)
    # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz5 = convert_matrix_to_axang(m3)
    rx5 = rxryrz5[0]
    ry5 = rxryrz5[1]
    rz5 = rxryrz5[2]
    
    # calculate rxryrz6 (gun straight into right seam side chamfer, preheat down, 10 degrees tiltback)
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz6 = convert_matrix_to_axang(m3)
    rx6 = rxryrz6[0]
    ry6 = rxryrz6[1]
    rz6 = rxryrz6[2]
    
    # calculate pointtopcham (the point at the top of the endwall chamfer) ( WHERE POINT3 WOULD BE IF RADIUS WAS 0)
    ptcx = x0 + leftwallthickmm * l1delxunit
    ptcy = y0 + leftwallthickmm * l1delyunit
    ptcz = z0
    
    # calculate point201 (weld start)
    # if deepchamfer, just ignore that. because if its deep chamfer then it filled more as well. so the hot extrudant should be to the same spot (same distance from the pointtopcham) whether it&apos;s big weld or small weld 
    adjust = 0.0 # if you want to move the start point further away from corner (positive, mm) or closer to corner
    p201x = x0 + rightwallthickmm * l2delxunit + leftwallthickmm * l1delxunit + adjust * l2delxunit
    p201y = y0 + rightwallthickmm * l2delyunit + leftwallthickmm * l1delyunit + adjust * l2delyunit
    p201z = z0
    point201 = p[p201x, p201y, p201z, rx3, ry3, rz3]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # calculate point202 (start of roundover)
    p202x = ptcx + rod * l2delxunit
    p202y = ptcy + rod * l2delyunit
    p202z = z0
    point202 = p[p202x, p202y, p202z, rx3, ry3, rz3]
    
    # calculate point203 (middle of roundover)
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p203z = ptcz - delta
    p203x = ptcx + delta * l2delxunit
    p203y = ptcy + delta * l2delyunit
    point203 = p[p203x, p203y, p203z, rx4, ry4, rz4]
    
    # calculate point204 (end of roundover)
    point204 = p[ptcx, ptcy, ptcz - rod, rx5, ry5, rz5]
    
    # calculate trail out points (tilt back and ride)
    botvcham = wd3 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # point101 will still use backofhole, but points 102 and 103 will use normal weld tip tcp
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = ptcx
    p101y = ptcy
    p101z = ptcz - wd3 + dist
    point101 = p[p101x, p101y, p101z, rx5, ry5, rz5]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = ptcx + l2delxunit * tiltraise * -1
    p102y = ptcy + l2delyunit * tiltraise * -1
    p102z = ptcz - wd3 + dist
    point102 = p[p102x, p102y, p102z, rx6, ry6, rz6]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, ptcz - wd3 + dist, rx6, ry6, rz6]
    
    # return
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point201=point201, point202=point202, point203=point203, point204=point204, point101=point101, point102=point102, point103=point103)
    return struct2
    
end
    

def main_calculate_cover_straight(p11, p12, p21, p22, sidewallthick, leftpoint, rightpoint, deepcovercham):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_cover(struct1, sidewallthick, leftpoint, rightpoint, deepcovercham)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# calculates the line of intersection of the sidewall plane (assumed vertical) and the cover plane (assumed perpendicular to sidewall plane)
# returns a struct containing point0 (point on the intersection line, same y as leftpoint) and 3 components of the unit vector left to right and 2 components of the other direction in 2d
def analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint):
    # calculate slope of sidewall in x-y plane
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
    
    # calculate the cover plane
    # if two planes are perpendicular, then their normal vectors must be perpendicular. 
    # the first planes normal vector is n1, which is taken from the equation of the plane ax + by + cz = d -&gt; &lt;a, b, c&gt;
    # the second plane&apos;s normal vector is perpendicular to all vectors contained in the plane
    # p21 to p22 is a vector v contained within plane 2. 
    # n2 is normal to both n1 AND v. to achieve a vector that is normal to both, take the cross product
    
    # plane 1 (y = mx + b) -&gt; (b = -mx +1y +0z)
    n1 = [-1 * ml1, 1, 0]
    
    # v=P2P1=(x2x1,y2y1,z2z1)
    v = [p21[0]-p22[0], p21[1]-p22[1], p21[2]-p22[2]]
    
    #v n2 = cross product of n1 and v
    n2x = n1[1]*v[2] - n1[2]*v[1]
    n2y = n1[2]*v[0] - n1[0]*v[2]
    n2z = n1[0]*v[1] - n1[1]*v[0]
    n2 = [n2x, n2y, n2z]
    
    # find the d of the second plane
    # n2x * x + n2y * y + n2z * z = d0
    d = n2x * p21[0] + n2y * p21[1] + n2z * p21[2]
    
    # find the intersection line of the two planes
    # find the direction vector of that line by taking the cross product of the normal vector of those two planes
    v3x = n1[1]*n2[2] - n1[2]*n2[1]
    v3y = n1[2]*n2[0] - n1[0]*n2[2]
    v3z = n1[0]*n2[1] - n1[1]*n2[0]
    v3 = [v3x, v3y, v3z]
    
    # normalize the vector so the magnitude is 1
    magnitude2 = v3x * v3x + v3y * v3y + v3z * v3z
    magnitude = sqrt(magnitude2)
    v3xunit = v3x/magnitude
    v3yunit = v3y/magnitude
    v3zunit = v3z/magnitude
    
    # make sure it is going the right way (from left to right). make sure the v3yunit is positive
    if v3yunit &lt; 0:
        v3xunit = v3xunit * -1
        v3yunit = v3yunit * -1
        v3zunit = v3zunit * -1
    end
    
    # next we have to find a point on the line by setting one of the dimensions and solving the system of equations
    # i will pick the y value of the left teach point
    y = leftpoint[1]
    # plane 1: -ml1 * x + 1 * y + 0 * z = bl1
    # -ml1 * x = bl1 - y
    x = (bl1 - y)/ (-1 * ml1)
    # plane 2: d = n2x * x + n2y * y + n2z * z
    # (d - n2x * x - n2y * y) = n2z * z
    z = (d - n2x * x - n2y * y) / n2z
    
    # make point0 into a pose
    point0 = p[x, y, z, 0, 0, 0]
    
    # find heading of main line
    heading1 = convert_uv_to_heading(v3xunit, v3yunit)
    
    # make a unit vector perpendicular to this one in the xy plane pointing x -. will be used to move over the chamfer distance
    ml2 = -1 / ml1
    # y = ml2 * x + unknownB
    # vector = [1, ml2]
    mag2 = 1 + ml2 * ml2
    mag = sqrt(mag2)
    v4xunit = 1 / mag
    v4yunit = ml2 / mag
    # switch is to the x direction is negative
    v4xunit = -1 * v4xunit
    v4yunit = -1 * v4yunit
    
    ret = struct(point0=point0, v3xunit=v3xunit, v3yunit=v3yunit, v3zunit=v3zunit, heading1=heading1, v4xunit=v4xunit, v4yunit=v4yunit)
    return ret
end

def calculate_straight_points_cover(struct1, sidewallthick, leftpointteach, rightpointteach, deepcovercham):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    sidewallthick = sidewallthick
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = p0z
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        coverz = 0
    else:
        coverz = zpi
    end
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # calculate pointtopvcham
    chamferover = sidewallthick * 25.4 / 1000.0 + deepchambumpmm
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    x = p0x + v4xunit * chamferover
    y = p0y + v4yunit * chamferover
    z = coverz + tiltraise
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # second rotation is a 10 degree turn about the x axis (negative direction)
    m2 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 10 * pi / 180)
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = -1 * 25.4 / 1000.0 # move back 1 inch from 
    p1x = x + dist * v3xunit
    p1y = y + dist * v3yunit
    p1z = z + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x + dist * v3xunit
    p2y = y + dist * v3yunit
    p2z = z + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate rxryrz for nontilted
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    m5 = multiply_matrix(m3, m1)
    rxryrz = convert_matrix_to_axang(m5)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point3 (end of flatten)
    dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x + dist * v3xunit
    p3y = y + dist * v3yunit
    p3z = coverz + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that&apos;s what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    
    # calculate point4 (start of unflatten)
    dist = -1.5 * 25.4 / 1000.0 
    p4x = x2 + v3xunit * dist
    p4y = y2 + v3yunit * dist
    p4z = z2 + v3zunit * dist - tiltraise
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = -0.5 * 25.4 / 1000.0 
    p5x = x2 + v3xunit * dist
    p5y = y2 + v3yunit * dist
    p5z = z2 + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = 2 * 25.4 / 1000.0 
    p6x = x2 + v3xunit * dist
    p6y = y2 + v3yunit * dist
    p6z = z2 + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
    
end

def main_calculate_floor_straight(p11, p12, p21, p22, floorthick, leftpoint, rightpoint):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_floor(struct1, floorthick, leftpoint, rightpoint)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# the path for welding a floor straight weld with v chisels on both sides. 
# start at the right side and move left. 
def calculate_straight_points_floor(struct1, floorthick, leftpointteach, rightpointteach):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do not, because the floors are low)
    zpi = p0z
    floorz = zpi
    
    # calculate pointtopvcham (left point) (tilted and tiltraised)
    chamferup = floorthick * 25.4 / 1000.0
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    # on this one, move the tiltraise distance sideways (towards robot) and the chamferover distance up
    x = p0x + v4xunit * tiltraise * -1
    y = p0y + v4yunit * tiltraise * -1
    z = floorz + chamferup
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 90 degrees about y axis. positive direction. gun is now pointing in the x+ direction with preheat facing +y direction
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, 1, 90 * pi / 180) 
    # second rotation is about 180 degrees about the z axis. heading1 plus 90 degrees. gun is now pointing directly into the sidewall
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # third rotation is 10 degrees about the z axis. gun is now tilted back 10 degrees from the sidewall
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, 10 * pi / 180)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    # the non tilted angle is just m4
    rxryrz = convert_matrix_to_axang(m4)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that&apos;s what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2 (right point) (tilted and tiltraised)
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    pointtopvcham2 = p[x2, y2, z2, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = 1 * 25.4 / 1000.0 # move back 1 inch from ptvc2 (in this case back means positive)
    p1x = x2 + dist * v3xunit
    p1y = y2 + dist * v3yunit
    p1z = z2 + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = -0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x2 + dist * v3xunit
    p2y = y2 + dist * v3yunit
    p2z = z2 + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate point3 (end of flatten)
    dist = -1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x2 + dist * v3xunit + tiltraise * v4xunit
    p3y = y2 + dist * v3yunit + tiltraise * v4yunit
    p3z = z2 + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate point4 (start of unflatten)
    dist = 1.5 * 25.4 / 1000.0 
    p4x = x + v3xunit * dist + tiltraise * v4xunit
    p4y = y + v3yunit * dist + tiltraise * v4yunit
    p4z = z + v3zunit * dist
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = 0.5 * 25.4 / 1000.0 
    p5x = x + v3xunit * dist
    p5y = y + v3yunit * dist
    p5z = z + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = -2 * 25.4 / 1000.0 
    p6x = x + v3xunit * dist
    p6y = y + v3yunit * dist
    p6z = z + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
end

# this function determines the starting touchpoints for homing in on cover lt geometry
# includes two points above the cover lt, closer to the robot than the lt, facing down
def get_coverlt_homing_pathpoints(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from (in meters)
    d0 = 0.05 # how far from the cover to approach from
    d1 = 0.03 # how far the touchpints are pushed closer to the robot
    d2 = 0.00 # how far inwards the touchpoints are pushed
    
    # rxryrz
    rxryrz = [0.334, 3.124, 0]
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate the points
    ph1 = p[lpx + d1, lpy + d2, lpz + d0, rx, ry, rz] # left side approach
    ph2 = p[rpx + d1, rpy - d2, rpz + d0, rx, ry, rz] # right side approach
    
    ret = struct(ph1=ph1, ph2=ph2)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

def main_calculate_cover_lt(p11, p12, leftpoint, rightpoint):
    struct1 = analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint)
    struct2 = calculate_points_cover_lt(struct1)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

def analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint):
    # calculate the slope of the groove in xy plane
    l1p1x = leftpoint[0]
    l1p1y = leftpoint[1]
    l1p2x = rightpoint[0]
    l1p2y = rightpoint[1]
    
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
    
    # zraise (how much the z value changes from left point to right point
    zraise = p12[2] - p11[2]
    
    #get the calcpoints
    leftcalcpoint = [leftpoint[0], leftpoint[1], p11[2]]
    rightcalcpoint = [rightpoint[0], rightpoint[1], p12[2]]
    # get the vector from a to b
    vec = [rightcalcpoint[0] - leftcalcpoint[0], rightcalcpoint[1] - leftcalcpoint[1], rightcalcpoint[2] - leftcalcpoint[2]]
    # get the unit vector in 3d
    mag3d = sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])
    vec3dunit = [vec[0]/mag3d, vec[1]/mag3d, vec[2]/mag3d]
    # get the unit vector in 2d
    mag2d = sqrt(vec[0]*vec[0]+vec[1]*vec[1])
    vec2dunit = [vec[0]/mag2d, vec[1]/mag2d]
    # get the heading
    heading1 = convert_uv_to_heading(vec2dunit[0], vec2dunit[1])
    
    ret = struct(leftcalcpoint=leftcalcpoint, rightcalcpoint=rightcalcpoint, vxunit=vec3dunit[0], vyunit=vec3dunit[1], vzunit=vec3dunit[2], heading1=heading1)
    return ret
end

def calculate_points_cover_lt(struct1):
    # get the stuff from struct
    leftcalcpoint = struct1[0]
    x = leftcalcpoint[0]
    y = leftcalcpoint[1]
    z = leftcalcpoint[2]
    rightcalcpoint = struct1[1]
    x2 = rightcalcpoint[0]
    y2 = rightcalcpoint[1]
    z2 = rightcalcpoint[2]
    v3xunit = struct1[2]
    v3yunit = struct1[3]
    v3zunit = struct1[4]
    heading1 = struct1[5]
    
    # first calculate rxryrz f normal and tiltback
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # second rotation is a 10 degree turn about the x axis (negative direction)
    m2 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 10 * pi / 180)
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    
    # calculate rxryrz for nontilted
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    m5 = multiply_matrix(m3, m1)
    rxryrz = convert_matrix_to_axang(m5)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    
    # calculate points 1-3
    # calculate point1 (preheat)
    dist = -1 * 25.4 / 1000.0 # move back 1 inch from 
    p1x = x + dist * v3xunit
    p1y = y + dist * v3yunit
    p1z = z + dist * v3zunit + tiltraise
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x + dist * v3xunit
    p2y = y + dist * v3yunit
    p2z = z + dist * v3zunit + tiltraise
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate point3 (end of flatten)
    dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x + dist * v3xunit
    p3y = y + dist * v3yunit
    p3z = z + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate points 4-6
    # calculate point4 (start of unflatten)
    dist = -1.5 * 25.4 / 1000.0 
    p4x = x2 + v3xunit * dist
    p4y = y2 + v3yunit * dist
    p4z = z2 + v3zunit * dist
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = -0.5 * 25.4 / 1000.0 
    p5x = x2 + v3xunit * dist
    p5y = y2 + v3yunit * dist
    p5z = z2 + v3zunit * dist + tiltraise
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = 2 * 25.4 / 1000.0 
    p6x = x2 + v3xunit * dist
    p6y = y2 + v3yunit * dist
    p6z = z2 + v3zunit * dist + tiltraise
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    # return struct
    ret = struct(pointtopvcham=leftcalcpoint, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
end

def main_calculate_sleeve_fillet(p1, p2, p3):
    struct1 = analyze_touchpoints_only_sleeve_fillet(p1, p2, p3)
    struct2 = calculate_points_sleeve_fillet_quadonly(struct1)
    return struct2
end

# given 3 points at the intersection of the sleeve and the sidewall, this calculates and returns 3 things:
# the centerpoint of the circle on the plane, the normal vector of the plane, and the radius of the circle
# then it returns 4 more things after converting to a vertical circle/plane: heading1 (into the plane), vecn, vecr, vecu
def analyze_touchpoints_only_sleeve_fillet(p1, p2, p3):
    x1 = p1[0]
    y1 = p1[1]
    z1 = p1[2]
    x2 = p2[0]
    y2 = p2[1]
    z2 = p2[2]
    x3 = p3[0]
    y3 = p3[1]
    z3 = p3[2]
    
    # calculate plane
    # calculate ab (1-&gt;2) vector
    abvec = [x2-x1, y2-y1, z2-z1]
    # calculate ac (1-&gt;3) vector
    acvec = [x3-x1, y3-y1, z3-z1]
    #calculate the plane&apos;s normal vector = ab x ac
    
    n = crossproduct(abvec, acvec)
    mag = sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2])
    n = [n[0]/mag, n[1]/mag, n[2]/mag]
    d = n[0] * x1 + n[1] * y1 + n[2] * z1
    
    # find the circle
    # Midpoint of AB:
    mab = [(x1 + x2)/2, (y1 + y2)/2, (z1 + z2)/2]
    # midpoint of ac
    mac = [(x3 + x1)/2, (y3 + y1)/2, (z3 + z1)/2]
    # Get Normal Vectors to AB and AC in the Plane
    # nab (normal to ab) = abvec x n
    nab = crossproduct(abvec, n)
    # nac (normal to ac) = acvec x n
    nac = crossproduct(acvec, n)
    # Define Perpendicular Bisector Lines
    # Each line goes through a midpoint and extends in the direction of the na_
    # we already have the equations of those lines in point vector form with l1 = mab + s * nab, and l2 = mac + t * nac
    # define all the terms so the math is simpler when i have to do math
    mabx = mab[0]
    maby = mab[1]
    mabz = mab[2]
    nabx = nab[0]
    naby = nab[1]
    nabz = nab[2]
    macx = mac[0]
    macy = mac[1]
    macz = mac[2]
    nacx = nac[0]
    nacy = nac[1]
    nacz = nac[2]
    # find the intersection point using the y and z equations
    # maby + s * naby = macy + t * nacy
    # mabz + s * nabz = macz + t * nacz
    # first solve for s and take
    # t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    # s = (t*nacz + macz - mabz) / nabz
    s = (t*nacz + macz - mabz) / nabz
    # find the point
    # pcenter = mac + t * nac
    pcenterx = macx + t * nacx
    pcentery = macy + t * nacy
    pcenterz = macz + t * nacz
    rxryrz = [0.528, 4.631, 0.258] # demo point of the welder pointing forward into a sleeve
    pcenter = p[pcenterx, pcentery, pcenterz, rxryrz[0], rxryrz[1], rxryrz[2]]
    radius = distance_between(pcenterx, pcentery, pcenterz, x1, y1, z1)
    
    # ------ start calculation of vertical assumption -----
    # assume the plane close to vertical
    # fix it to make it actually vertical
    # calculate the unit vector of up, and the unit vector of right. 
    # calculate the heading from the +x axis to pointing straight into the wall. 
    # the unit vector of up is [0, 0, 1] (because the plane is verticalized) (for easier calculations)
    # first calculate the normal vector INTO the sidewall (make sure x is negative) and make it a unit vector
    vecn = [n[0], n[1], 0] # vector normal
    if vecn[0] &gt; 0:
        vecn = [-n[0], -n[1], 0]
    end
    mag = sqrt(vecn[0]*vecn[0]+vecn[1]*vecn[1])
    vecn = [vecn[0]/mag, vecn[1]/mag, 0]
    # next calculate the right normal vector (the vector IN the plane that goes to the right)
    vecr = [vecn[1], -1*vecn[0], 0]
    vecu = [0, 0, 1] # vector up
    heading1 = convert_uv_to_heading(vecn[0], vecn[1])
    
    
    ret = struct(pcenter=pcenter, planenormalvec=n, radius=radius, heading1=heading1, vecn=vecn, vecr=vecr, vecu=vecu)
    return ret
end

def crossproduct(vec1, vec2):
    nx = vec1[1]*vec2[2] - vec1[2]*vec2[1]
    ny = vec1[2]*vec2[0] - vec1[0]*vec2[2]
    nz = vec1[0]*vec2[1] - vec1[1]*vec2[0]
    ret = [nx, ny, nz]
    return ret
end

def calculate_points_sleeve_fillet(struct1):
    
end

# this function calculates only the four points of the quadrants, for the not real program. 
# these calculations are easier so that&apos;s why i&apos;m starting with them first. 
# this assumes a vertical plane
def calculate_points_sleeve_fillet_quadonly(struct1):
    # get the stuff from the struct
    pcenter = struct1[0]
    pcx = pcenter[0]
    pcy = pcenter[1]
    pcz = pcenter[2]
    planenormalvec = struct1[1]
    radius = struct1[2]
    heading1 = struct1[3]
    vecn = struct1[4]
    vecnx = vecn[0]
    vecny = vecn[1]
    vecr = struct1[5]
    vecrx = vecr[0]
    vecry = vecr[1]
    vecu = struct1[6]
    vecuz = vecu[2]
    
    # define cushions (the backofhole can&apos;t actually touch the intersection of pipe and wall, it travels a certain distance around it
    cushout = 0.005 # 5mm # the cushion out from the wall
    cusharound = 0.005 # 5mm # the cushion around the sleeve. 
    
    # get the top point (point1)
    # take the center point and move up the radius plus the cushions
    p1x = pcx + vecnx * -1 * cushout
    p1y = pcy + vecny * -1 * cushout
    p1z = pcz + vecuz * radius + vecuz * cusharound
    
    # find rxryrz1
    # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, -1, 135 * pi / 180)
    # second rotation is heading1  180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - 180 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # get second point (right) (point2)
    # take the center point and move right the radius plus the cushions
    p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * -1 * cushout
    p2y = pcy + vecry * radius + vecry * cusharound + vecny * -1 * cushout
    p2z = pcz
    
    # find rxryrz2
    # first rotation is 90 degrees about the x- axis
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    # second rotation is About 135 degrees about the z+ axis. This calculation is heading1  45 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
    
    # get the third point (bottom) (point3)
    p3x = pcx + vecnx * -1 * cushout
    p3y = pcy + vecny * -1 * cushout
    p3z = pcz - vecuz * radius - vecuz * cusharound
    
    # find rxryrz3
    # first rotation is 45 degrees about the y+ axis
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, 1, 45 * pi / 180)
    # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    # get the fourth point (left) (point4)
    p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * -1 * cushout
    p4y = pcy - vecry * radius - vecry * cusharound + vecny * -1 * cushout
    p4z = pcz
    
    # find rxryrz4
    # first rotation is 90 degrees about the x+ axis
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 90 * pi / 180)
    # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
    
    # return the points
    ret = struct(point1=point1, point2=point2, point3=point3, point4=point4)
    return ret
    
end
</cachedContents>
          <file>/programs/analyze_touchpoints.script</file>
        </Script>
        <SuppressedNode>
          <suppressedNode class="Script" type="Line">
            <expression>
              <ExpressionChar character="w"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="l"/>
              <ExpressionChar character="d"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="d"/>
              <ExpressionChar character="y"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Operator" message="Select Yes for a Left side weld, or select No for a Right Side weld." valueType="Boolean">
          <variable name="leftchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <Assignment valueSource="Operator" message="Is the capping wall 3/4 inch?" valueType="Boolean">
          <variable name="floorchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="f"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="e"/>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="floorthick" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="8"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="7"/>
                <ExpressionChar character="5"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <Assignment valueSource="Operator" message="Is the other wall 3/4 inch?" valueType="Boolean">
          <variable name="sidewallchoice" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionVariable>
              <ProgramVariable reference="../../../../Assignment[3]/variable"/>
            </ExpressionVariable>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="sidewall" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="6"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="8"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If[3]/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="7"/>
                <ExpressionChar character="5"/>
              </expression>
            </Assignment>
          </children>
        </If>
        <Assignment valueSource="Operator" message="Does the cover have deep chamfers? (deeper than 0.21)" valueType="Boolean">
          <variable name="deepcovercham" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_46" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-3.266944233571188, -1.1744955343059083, 1.6532734076129358, 1.003952904338501, -0.002457443867818654, -1.5361955801593226"/>
                <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="NoAction">
          <tcp referencedName="pretend_w_top"/>
        </Set>
        <Script type="Line">
          <expression>
            <ExpressionChar character="T"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="T"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="P"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../Set[2]/tcp"/>
        </Set>
        <Script type="Line">
          <expression>
            <ExpressionChar character="k"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character=" "/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="I"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="T"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="d"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="1"/>
          </expression>
        </Script>
        <Script type="Line">
          <expression>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="H"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="C"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="path1" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="a"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="l"/>
              <ExpressionChar character="y"/>
              <ExpressionChar character="z"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="c"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="i"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="("/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="2"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="CallSubProgram"/>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_19" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.7325146834002894, -1.1100619596293946, 2.5569477717029017, 0.15985266744580073, 1.4753735065460205, 3.3034157752990723"/>
                  <TCPOffset pose="0.00855, -0.27152, 0.102, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="l"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character=""/>
            <ExpressionToken token=" True "/>
          </expression>
          <children>
            <Assignment valueSource="Expression">
              <variable name="pathturn" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="("/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="s"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="w"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="m"/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Script type="Line">
              <expression>
                <ExpressionChar character="e"/>
                <ExpressionChar character="x"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
            <Script type="Line">
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Assignment valueSource="Expression">
              <variable reference="../../../../If[5]/children/Assignment/variable"/>
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="("/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="2"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="s"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="w"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="l"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="l"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="m"/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Script type="Line">
              <expression>
                <ExpressionChar character="e"/>
                <ExpressionChar character="x"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="u"/>
                <ExpressionChar character="d"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="k"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="f"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
            <Script type="Line">
              <expression>
                <ExpressionChar character="m"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="p"/>
                <ExpressionChar character="a"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="o"/>
                <ExpressionChar character="v"/>
                <ExpressionChar character="e"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="_"/>
                <ExpressionChar character="r"/>
                <ExpressionChar character="i"/>
                <ExpressionChar character="g"/>
                <ExpressionChar character="h"/>
                <ExpressionChar character="t"/>
                <ExpressionChar character="3"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </If>
      </children>
    </MainProgram>
    <SubProgram name="align_for_cover_left" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_for_cover_left.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Folder" name="dummypoints" keepHidden="false">
            <children>
              <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                <feature class="GeomFeatureReference" reference="../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                <children>
                  <Comment comment="startpoint: oldhome"/>
                  <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.4611328426873, -2.0623207793499674, 2.329160332900075, -0.21924456446498652, -0.2009788370788126, -0.11039879152515653"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy left start"/>
                  <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="4">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.0538056879199513, -2.6742425054854273, -0.6374733179630976, -2.978794509912973, 0.8911860770965965, 0.004599663033619118"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="approach point near shoulder"/>
                  <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="4">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-2.977835455580779, -1.8478377370769383, -2.007182568140033, -2.434874955750219, 0.9678560292809983, 0.0036113126149359687"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                </children>
              </Move>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Folder name="actualprogram" keepHidden="false">
          <children>
            <Folder name="liftcolumnup" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable name="liftcolumnz" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="c"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="z"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                  </expression>
                </Assignment>
                <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
                  <dataModel>
                    <data key="type" value="addMotor"/>
                    <data key="numberAdded" value="0"/>
                    <data key="acceleration_in_mm_per_s2" value="50.0"/>
                    <data key="ActuatorPos" value="liftcolumnz"/>
                    <data key="speed_in_mm_per_min" value="3000.0"/>
                    <data key="teachColor" value="BLUE"/>
                    <data key="combo1" value="MachineMotion1"/>
                    <data key="combo2" value="(1) Custom Actuator"/>
                    <data key="combo3" value="Move to Position"/>
                    <data key="combo6" value="In series"/>
                    <data key="message" value="Move to Position"/>
                    <data key="description" value="Moves the actuator to a specified position from the home location."/>
                    <data key="comboAddress" value="Address 1"/>
                    <data key="comboActuator" value="Valve 1"/>
                  </dataModel>
                </Contributed>
              </children>
            </Folder>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_21" kinematicsFlags="4">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-2.918409517091006, -1.130700698023488, -2.096373719624969, -2.2849817795239993, 0.8961046798977055, 0.10799070352990178"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
                <Waypoint type="Fixed" name="Waypoint_22" kinematicsFlags="-1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-2.977835455580779, -1.8478377370769383, -2.007182568140033, -2.434874955750219, 0.9678560292809983, 0.0036113126149359687"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Folder>
      </children>
    </SubProgram>
    <SubProgram name="align_for_cover_right" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_for_cover_right.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Folder" name="dummypoints" keepHidden="false">
            <children>
              <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                <feature class="GeomFeatureReference" reference="../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                <children>
                  <Comment comment="startpoint: oldhome"/>
                  <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-3.4611328426873, -2.0623207793499674, 2.329160332900075, -0.21924456446498652, -0.2009788370788126, -0.11039879152515653"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy start right"/>
                  <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.29049961919197287, -1.1819831404078718, 1.334465833195068, -0.17409121259363225, 2.0099089258476623, -0.009438179428446603"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="dummy start right 2"/>
                  <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.1104716957103129, -0.980541586809573, 1.0560350620627785, -0.09941936143260843, 2.18984876960206, -0.014276884747548735"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                  <Comment comment="approach point close to shoulder"/>
                  <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="1">
                    <motionParameters/>
                    <position>
                      <JointAngles angles="-0.9252587377076562, -1.9106813901052684, 2.580357834681599, -0.6901398423967073, 1.3752736098591445, 0.0039154434748498446"/>
                      <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                      <Kinematics status="LINEARIZED" validChecksum="true">
                        <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                        <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                        <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                        <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                        <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                      </Kinematics>
                    </position>
                    <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                  </Waypoint>
                </children>
              </Move>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Folder name="actualprogram" keepHidden="false">
          <children>
            <Folder name="liftcolumnup" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../../../SubProgram/children/Folder/children/Folder/children/Assignment/variable"/>
                  <expression>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="c"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="z"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                  </expression>
                </Assignment>
                <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
                  <dataModel>
                    <data key="type" value="addMotor"/>
                    <data key="numberAdded" value="0"/>
                    <data key="acceleration_in_mm_per_s2" value="50.0"/>
                    <data key="ActuatorPos" value="liftcolumnz"/>
                    <data key="speed_in_mm_per_min" value="3000.0"/>
                    <data key="teachColor" value="BLUE"/>
                    <data key="combo1" value="MachineMotion1"/>
                    <data key="combo2" value="(1) Custom Actuator"/>
                    <data key="combo3" value="Move to Position"/>
                    <data key="combo6" value="In series"/>
                    <data key="message" value="Move to Position"/>
                    <data key="description" value="Moves the actuator to a specified position from the home location."/>
                    <data key="comboAddress" value="Address 1"/>
                    <data key="comboActuator" value="Valve 1"/>
                  </dataModel>
                </Contributed>
              </children>
            </Folder>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-3.4611328426873005, -2.0623207793499674, 2.329160332900076, -0.21924456446498652, -0.2009788370788117, -0.11039879152515564"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
                <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="3">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.9252587377076562, -1.9106813901052684, 2.580357834681599, -0.6901398423967073, 1.3752736098591445, 0.0039154434748498446"/>
                    <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Folder>
      </children>
    </SubProgram>
    <SubProgram name="move_path_cover_left3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/move_path_cover_left3.urp</programFile>
      <children>
        <Comment/>
        <Script type="Line">
          <expression>
            <ExpressionChar character="a"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp referencedName="backofhole"/>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable name="p1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p5" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pa1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p4a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p2a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p101" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p102" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p103" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pa1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="p1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>8.0</waitTime>
        </Wait>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable name="p2a" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../If/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="dummyvar" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionToken token=" True "/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable name="p2" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../If[3]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <Move motionType="MoveP" speed="5.0E-4" acceleration="0.01" blendRadius="0.001" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <CircleMove OrientationMode="FIXED">
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable name="p3" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable name="p4" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
              </children>
            </CircleMove>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>4.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>1</digitalValue>
        </Set>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[9]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[10]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../../../SpecialSequence/children/Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[11]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable name="pret1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="1"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="2"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="pret2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="-"/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_1" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../Assignment[3]/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="6"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_4" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_5" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable name="p201" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p202" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201a" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201b" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="8"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="p201c" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="pret4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_preheat" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_pre_ret" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p_pre_ret2" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret1" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../SuppressedNode[2]/suppressedNode/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="retreat of p5"/>
            <Waypoint type="Fixed" name="Waypoint_6" kinematicsFlags="4">
              <motionParameters/>
              <position>
                <JointAngles angles="-2.503819662579805, -2.1076337372495892, -2.275962047042132, -1.9004743836489615, 1.3994194205792434, 1.571324733063948"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="dummypoint" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.41165382066835754, -0.7046496433070812, 1.0278294722186718, -0.30475409448659985, -1.3570078055011177, -0.01810008684267217"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="dummyret4p202" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.29118168425203006, -0.6923505048639953, 0.9660675043035383, -0.25348952983543693, -1.110187083325532, -0.02315869782612623"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="requires a shoulder flip. safe waypoints for that:"/>
            <Waypoint type="Fixed" name="Waypoint_9" kinematicsFlags="4">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.9737304628485504, -1.344748989694347, -2.2088795437767974, -1.7501578224355292, 0.9718193787935403, 1.511259645642839"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_15" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.2853152196519062, -1.6491975265833752, 1.5282079038237402, -0.6595344440871038, -1.457284994100636, -0.0759705702208393"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Comment comment="approach of p201"/>
            <Waypoint type="Fixed" name="Waypoint_16" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret3" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[14]/variable"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[16]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>6.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[17]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[18]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../Folder/children/Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../Contributed/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable name="p202" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../If[5]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable name="pret4" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_17" kinematicsFlags="-1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
          <dataModel>
            <data key="type" value="addMotor"/>
            <data key="numberAdded" value="0"/>
            <data key="speed_in_mm_per_min" value="600"/>
            <data key="acceleration_in_mm_per_s2" value="50.0"/>
            <data key="teachColor" value="BLUE"/>
            <data key="combo1" value="MachineMotion1"/>
            <data key="combo2" value="(1) Custom Actuator"/>
            <data key="combo3" value="Home"/>
            <data key="combo6" value="In series"/>
            <data key="message" value="Homing"/>
            <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
            <data key="comboAddress" value="Address 1"/>
            <data key="comboActuator" value="Valve 1"/>
          </dataModel>
        </Contributed>
      </children>
    </SubProgram>
    <SubProgram name="move_path_cover_right3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/move_path_cover_right3.urp</programFile>
      <children>
        <Comment/>
        <Script type="Line">
          <expression>
            <ExpressionChar character="a"/>
            <ExpressionChar character="l"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="f"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
        <Set type="NoAction">
          <tcp reference="../../../../SubProgram[3]/children/Set/tcp"/>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[3]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[4]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[5]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[6]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[7]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[8]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[9]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[10]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[11]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[2]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>8.0</waitTime>
        </Wait>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If[3]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If[3]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <Move motionType="MoveP" speed="5.0E-4" acceleration="0.01" blendRadius="0.001" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <CircleMove OrientationMode="FIXED">
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable reference="../../../../../../../../SubProgram[3]/children/Move[3]/children/CircleMove/children/Waypoint/variable"/>
                </Waypoint>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <variable reference="../../../../../../../../SubProgram[3]/children/Move[3]/children/CircleMove/children/Waypoint[2]/variable"/>
                </Waypoint>
              </children>
            </CircleMove>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>4.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>1</digitalValue>
        </Set>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.01" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[9]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[10]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Contributed[2]/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Move motionType="MoveL" speed="0.01" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[11]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[12]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[13]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="1"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="2"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[2]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="-"/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="5"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="0"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[3]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[4]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/Assignment[3]/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="6"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[6]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[7]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[14]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[15]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[16]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[17]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="8"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[18]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[19]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[20]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="+"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[8]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[9]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable reference="../../../../../SubProgram[3]/children/SuppressedNode[10]/suppressedNode/variable"/>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="0"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="+"/>
              <ExpressionChar character="."/>
              <ExpressionChar character="1"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="1"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="2"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="4"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character=","/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="3"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="5"/>
              <ExpressionChar character="]"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[8]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/SuppressedNode[2]/suppressedNode/variable"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="retreat of p5"/>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="4">
                <motionParameters/>
                <position>
                  <JointAngles angles="-2.503819662579805, -2.1076337372495892, -2.275962047042132, -1.9004743836489615, 1.3994194205792434, 1.571324733063948"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="dummypoint" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.41165382066835754, -0.7046496433070812, 1.0278294722186718, -0.30475409448659985, -1.3570078055011177, -0.01810008684267217"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="dummyret4p202" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.29118168425203006, -0.6923505048639953, 0.9660675043035383, -0.25348952983543693, -1.110187083325532, -0.02315869782612623"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="requires a shoulder flip. safe waypoints for that:"/>
              <Waypoint type="Fixed" name="Waypoint_3" kinematicsFlags="4">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.9737304628485504, -1.344748989694347, -2.2088795437767974, -1.7501578224355292, 0.9718193787935403, 1.511259645642839"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.2853152196519062, -1.6491975265833752, 1.5282079038237402, -0.6595344440871038, -1.457284994100636, -0.0759705702208393"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Comment comment="approach of p201"/>
              <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6506210061469844, -1.3091318937627072, 1.8409880042818898, -0.5139587177416729, -1.5958318476160747, -0.013986704947217987"/>
                  <TCPOffset pose="0.00451, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[13]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[16]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Wait type="Sleep">
          <waitTime>6.0</waitTime>
        </Wait>
        <Move motionType="MoveL" speed="0.05" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[17]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Assignment[18]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Folder name="turn ext on" keepHidden="false">
          <children>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                </Variable>
              </dataModel>
            </Contributed>
            <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
              <dataModel>
                <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                <data key="Command" value="[252,82,49]"/>
                <data key="QUERY" value="false"/>
                <data key="byte_array" value="true"/>
                <data key="OUTPUT_ENTRY" value="Static"/>
                <Variable key="OUTPUT_VARIABLE">
                  <variable reference="../../../../../../Folder/children/Contributed[2]/dataModel/Variable/variable"/>
                </Variable>
              </dataModel>
            </Contributed>
            <Wait type="Sleep">
              <waitTime>1.0</waitTime>
            </Wait>
            <SuppressedNode>
              <suppressedNode class="Script" type="Line">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="x"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="u"/>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="_"/>
                  <ExpressionChar character="o"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </suppressedNode>
            </SuppressedNode>
            <Set type="DigitalOutput">
              <pin reference="../../../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
              <digitalValue>1</digitalValue>
            </Set>
          </children>
        </Folder>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="d"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="m"/>
          </expression>
          <children>
            <Move motionType="MoveL" speed="0.006" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If[5]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <If type="Else" checkContinuously="false">
          <expression/>
          <children>
            <Move motionType="MoveL" speed="0.01" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../../../../../SubProgram[3]/children/If[5]/children/Move/children/Waypoint/variable"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </If>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable reference="../../../../Folder/children/Contributed[2]/dataModel/Variable/variable"/>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>2.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[3]/children/Move[16]/children/Waypoint/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_20" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.1084698903771084, -1.6120482505177893, 2.1904850640545614, -0.5440229802855612, -0.5713420496459127, -0.0431436282365123"/>
                <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        <Contributed strategyClass="com.ur.urcap.examples.MachineLogic_for_Universal_Robots.MachineLogic" strategyProgramNodeType="MachineLogic for Universal Robots" strategyURCapDeveloper="Vention Inc." strategyURCapName="MachineLogic for Universal Robots">
          <dataModel>
            <data key="type" value="addMotor"/>
            <data key="numberAdded" value="0"/>
            <data key="speed_in_mm_per_min" value="600"/>
            <data key="acceleration_in_mm_per_s2" value="50.0"/>
            <data key="teachColor" value="BLUE"/>
            <data key="combo1" value="MachineMotion1"/>
            <data key="combo2" value="(1) Custom Actuator"/>
            <data key="combo3" value="Home"/>
            <data key="combo6" value="In series"/>
            <data key="message" value="Homing"/>
            <data key="description" value="Moves the actuator in the negative direction until the home sensor is triggered and sets position to zero (0)."/>
            <data key="comboAddress" value="Address 1"/>
            <data key="comboActuator" value="Valve 1"/>
          </dataModel>
        </Contributed>
      </children>
    </SubProgram>
    <SubProgram name="Test_Teach_Position_Cover" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/Test Teach Position Cover.urp</programFile>
      <children>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-2.527531687413351, -2.1028810940184535, 2.591139856969015, -2.0582763157286585, -1.5713656584369105, 2.1834325790405273"/>
                  <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Comment comment="move welder up out of holder"/>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="false" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <tcp referencedName="TCP_1_plate"/>
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_40" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-3.4579489866839808, -2.0569035015501917, 2.3265796343432825, -0.22706706941638188, -0.1993501822101038, -0.10534793535341436"/>
                <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
            <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.0516188780414026, -1.010990933781006, 2.1562450567828577, -1.143702046280243, -1.0526168982135218, -0.0017235914813440445"/>
                <TCPOffset pose="0.0, 0.0, 0.019, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                  <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                  <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                  <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                  <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="freedrive_m_var" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../Assignment/variable"/>
          <expression>
            <ExpressionToken token=" True "/>
          </expression>
        </Assignment>
        <Popup type="Message" haltProgram="false" message="Move the TCP to the corner of the tank, then click &apos;Continue&apos;" inputType="Text"/>
        <Assignment valueSource="Expression">
          <variable name="tcp_pose" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../Assignment/variable"/>
          <expression>
            <ExpressionToken token=" False "/>
          </expression>
        </Assignment>
        <Wait type="Sleep">
          <waitTime>0.25</waitTime>
        </Wait>
        <Script type="Line">
          <expression>
            <ExpressionChar character="s"/>
            <ExpressionChar character="y"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Script>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_left" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_left.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable name="cp" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="aligned_y_pose" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="6"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="extrude_knife3" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/extrude_knife3.urp</programFile>
      <children>
        <Folder name="pre program stuff" keepHidden="false">
          <children>
            <Set type="NoAction">
              <tcp reference="../../../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
            </Set>
            <Assignment valueSource="Expression">
              <variable name="ek_sp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
              <expression>
                <ExpressionToken token="get_actual_tcp_pose"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Assignment>
            <Move motionType="MoveL" speed="0.005" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                  <motionParameters/>
                  <variable reference="../../../../Assignment/variable"/>
                </Waypoint>
              </children>
            </Move>
            <SuppressedNode>
              <suppressedNode class="Script" type="File">
                <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  joints_1 = get_inverse_kin(pose, orig_joints)
  #iterate through the 6 joints
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - orig_joints[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  return allGood
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end
</cachedContents>
                <file>/programs/analyze_touchpoints.script</file>
              </suppressedNode>
            </SuppressedNode>
          </children>
        </Folder>
        <Comment comment="list possible points"/>
        <Folder name="robot 1 moves" keepHidden="false">
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="1"/>
                <ExpressionChar character=""/>
                <ExpressionChar character="2"/>
              </expression>
              <children>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="r1_ek_oldhome" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_extrude" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_front" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_middle" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_middle2" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_bottom" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r1_ek_end" kinematicsFlags="-1">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702"/>
                        <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                          <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                          <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                          <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                          <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
              </children>
            </If>
          </children>
        </Folder>
        <Folder name="robot 2 moves" keepHidden="false">
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionChar character="1"/>
                <ExpressionChar character=""/>
                <ExpressionChar character="2"/>
              </expression>
              <children>
                <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
                  <feature class="GeomFeatureReference" reference="../../../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
                  <children>
                    <Waypoint type="Fixed" name="r2_ek_oldhome" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.461132842686933, -2.062320779349874, 2.32916033290004, -0.21924456446492258, -0.20097883707844666, -0.11039879152527199"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <SuppressedNode>
                      <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_1" kinematicsFlags="3">
                        <motionParameters/>
                        <position>
                          <JointAngles angles="-3.190347370661634, -1.4265640510241013, 2.191586797737077, -0.7413809357659105, -0.33101111967973296, -0.09495351526939722"/>
                          <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                          <Kinematics status="LINEARIZED" validChecksum="true">
                            <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                            <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                            <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                            <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                            <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                          </Kinematics>
                        </position>
                        <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                      </suppressedNode>
                    </SuppressedNode>
                    <Waypoint type="Fixed" name="r2_ek_extrude" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.199475796455825, -1.4862854517875999, 2.263543898005424, -0.6928175084157413, -0.09183293866530295, -0.15653548683830643"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_front" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2029012478485694, -1.4943971905029905, 2.3176866046272355, -0.727203417516419, -0.10461513056100813, -0.1013922369747533"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_middle" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.2036200175167613, -1.5006788185274456, 2.326226188945654, -0.730095076239345, -0.10533288811000929, -0.10075548926859312"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_bottom" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.204010221105431, -1.5099366263094405, 2.3272215014458872, -0.722096275899732, -0.10572512264357048, -0.10049057923478166"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                    <Waypoint type="Fixed" name="r2_ek_end" kinematicsFlags="3">
                      <motionParameters/>
                      <position>
                        <JointAngles angles="-3.205098875769389, -1.5204959829395506, 2.3387656715508855, -0.724001524008818, -0.10681294496314919, -0.09956563917089412"/>
                        <TCPOffset pose="-0.0095, -0.328, 0.10573, 1.2092, -1.2092, 1.2092"/>
                        <Kinematics status="LINEARIZED" validChecksum="true">
                          <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                          <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                          <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                          <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                          <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                        </Kinematics>
                      </position>
                      <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                    </Waypoint>
                  </children>
                </Move>
              </children>
            </If>
          </children>
        </Folder>
        <Comment comment="detemine correct points for which robot"/>
        <If type="If" checkContinuously="false">
          <expression>
            <ExpressionChar character="r"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character=""/>
            <ExpressionChar character="1"/>
          </expression>
          <children>
            <Folder name="robot1 positions" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable name="ek_oldhome" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="h"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_extrude" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="x"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_front" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_middle" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_middle2" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_bottom" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="b"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable name="ek_end" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="1"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="q"/>
                  </expression>
                </Assignment>
              </children>
            </Folder>
          </children>
        </If>
        <If type="ElseIf" checkContinuously="false">
          <expression>
            <ExpressionChar character="r"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="u"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="b"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character=""/>
            <ExpressionChar character="2"/>
          </expression>
          <children>
            <Folder name="robot1 positions" keepHidden="false">
              <children>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="h"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[2]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="x"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="u"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[3]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[4]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[5]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[6]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="b"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="t"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="p"/>
                  </expression>
                </Assignment>
                <Assignment valueSource="Expression">
                  <variable reference="../../../../../../If/children/Folder/children/Assignment[7]/variable"/>
                  <expression>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="2"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="k"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="n"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="q"/>
                  </expression>
                </Assignment>
              </children>
            </Folder>
          </children>
        </If>
        <Comment comment="start of program"/>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
        <Set type="NoAction">
          <tcp reference="../../../../SpecialSequence/children/Folder/children/Set/tcp"/>
        </Set>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_oldhome" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment/variable"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
          </children>
        </Move>
        <Comment comment="move above bucket"/>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_extrude" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Comment comment="extrude out a foot"/>
        <SuppressedNode>
          <suppressedNode class="Script" type="Line">
            <expression>
              <ExpressionChar character="t"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="x"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="u"/>
              <ExpressionChar character="s"/>
              <ExpressionChar character="i"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="o"/>
              <ExpressionChar character="n"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="NODE_TITLE" value="Serial Bridge uR1"/>
            <data key="Command" value="[252,82,49]"/>
            <data key="QUERY" value="false"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>1</digitalValue>
        </Set>
        <Wait type="Sleep">
          <waitTime>24.0</waitTime>
        </Wait>
        <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
          <dataModel>
            <data key="QUERY" value="false"/>
            <data key="NODE_TITLE" value="Serial Bridge uR0"/>
            <data key="Command" value="[252,82,48]"/>
            <data key="byte_array" value="true"/>
            <data key="OUTPUT_ENTRY" value="Static"/>
            <Variable key="OUTPUT_VARIABLE">
              <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                <initializeExpression/>
              </variable>
            </Variable>
          </dataModel>
        </Contributed>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Set type="DigitalOutput">
          <pin reference="../../../../SpecialSequence/children/Folder/children/Set[2]/pin"/>
          <digitalValue>0</digitalValue>
        </Set>
        <Comment comment="slice"/>
        <Move motionType="MoveL" speed="0.03" acceleration="0.05" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_front" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_middle" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_middle2" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_bottom" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_end" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[3]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[4]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[5]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[6]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment[7]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="r1_ek_oldhome" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569"/>
                  <TCPOffset pose="-0.00549, -0.328, 0.10639, 1.2092, -1.2092, 1.2092"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../If/children/Folder/children/Assignment/variable"/>
            </Waypoint>
            <Comment comment="above waypoint is home"/>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_forward" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_forward.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="-"/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="."/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="7"/>
            <ExpressionChar character="9"/>
            <ExpressionChar character="6"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[6]/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="align_tcp_up" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/align_tcp_up.urp</programFile>
      <children>
        <Comment comment="this program aligns the tcp parallel to the y direction"/>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[6]/children/Assignment[2]/variable"/>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character=","/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../../../SubProgram[6]/children/Assignment[2]/variable"/>
            </Waypoint>
          </children>
        </Move>
      </children>
    </SubProgram>
    <SubProgram name="Corner_Homing_45_Cover" keepHidden="false" keepSynchronizedWithDisk="false">
      <programFile>/programs/Corner Homing 45 Cover.urp</programFile>
      <children>
        <Comment comment="Use this program when tool is already positioned close to corner at 45deg"/>
        <Comment comment="tool flange will seek all 3 sides. will save those 5 locs in p__"/>
        <Set type="NoAction">
          <tcp reference="../../../../MainProgram/children/Set[2]/tcp"/>
        </Set>
        <Comment comment="dummy move below for debug"/>
        <SuppressedNode>
          <suppressedNode class="SafeHome" positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="demo_point0" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6836307684527796, -1.0886919063380738, 1.8533313910113733, -1.1951357883265992, 0.36088186502456665, 0.17399978637695312"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_1" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.1356399695025843, -0.8834679287723084, 2.671961847935812, -1.629258771935934, 0.611339807510376, 1.4263536930084229"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_2" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.6423338095294397, -0.9283088010600586, 2.3237603346454065, -1.2926811438849946, 1.1005513668060303, 1.510843276977539"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Wait type="Sleep">
          <waitTime>1.0</waitTime>
        </Wait>
        <Assignment valueSource="Expression">
          <variable name="tp" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Script type="File">
          <cachedContents># this file creates the function for analyzing touchpoints
# define pi
pi = 3.1415926535
# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# based on a Corner Homing 45 Cover pattern of touchpoints
# this uses those touchpoints to create a representation of the corner in 3d robot space. 
def analyze_touchpoints_only_cover(p11, p12, p21, p3):
    zcoord=p3[2]
    
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x

    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]

    # equate the second line in 2d space
    # ml2 = opposite reciprocal of ml1 (because they are perpendicular) (assume perpendicular to make calculation of weldpath much easier)
    ml2 = -1 / ml1

    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x

    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1

    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]

    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect

    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p1x - xintersect
    l2delyfull = l2p1y - yintersect

    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag

    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. this line is from pointintersect and along each edge of the corner
    heading1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    heading3 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (heading1 + heading3)/2

    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# given 3 points, this finds the plane and its equation
# rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
def findplane(p11, p12, p13):
    # extract coordinates
    x1 = p11[0]
    y1 = p11[1]
    z1 = p11[2]
    x2 = p12[0]
    y2 = p12[1]
    z2 = p12[2]
    x3 = p13[0]
    y3 = p13[1]
    z3 = p13[2]
    # create vectors from the points
    v1x = x2-x1
    v1y = y2-y1
    v1z = z2-z1
    v2x = x3-x1
    v2y = y3-y1
    v2z = z3-z1
    #calculate the normal vector using the cross product
    nx = v1y*v2z - v1z*v2y # i component
    ny = v1z*v2x - v1x*v2z # j component
    nz = v1x*v2y - v1y*v2x # k component
    # calculate d in the plane equation
    d = -1 * (nx*x1 + ny*y1 + nz*z1)
    ret = [nx, ny, nz, d]
    return ret
end

# given a heading, (ccw from +x axis), find the mx+b slope
# fails if exactly vertical
def get_slope_from_heading(heading):
    return tan(heading)
end



# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# this function converts a unit vector to its heading angle ccw from x+ axis
# takes uvx and uvy
# returns heading in radians
def convert_uv_to_heading(uvx, uvy):
  baseang = atan(uvy/uvx)
  if uvx &lt; 0:
    ang = baseang + pi
  elif uvy &lt; 0:
    ang = baseang + pi * 2
  else:
    ang = baseang
  end
  return ang
end

# this function finds the equation of a line, perpendicular to a given line, and going through a given point
# takes 3 arguments: m (the original line&apos;s slope), x (point&apos;s x coord), y (point&apos;s y coord). the b of the original line is not needed
# returns a list of [m,b] (the slope and intercept of the new line)
def find_perpendicular_line(origm, x, y):
  m = (1/origm) * -1
  b = y - m*x
  ret = [m, b]
  return ret
end

# this function finds the intersection point between two lines in the xy plane
# takes 4 arguments: m1, b1, m2, b2
# returns a list of [x,y] (the point of intersection)
def find_intersection(m1, b1, m2, b2):
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  x = (b2-b1) / (m1-m2)
  y = m1 * x + b1
  ret = [x, y]
  return ret
end

# this function finds the distance between 2 points in 3d space
# it takes 6 arguments: x1, y1, z1, x2, y2, z2
# it returns a distance
def distance_between(x1, y1, z1, x2, y2, z2):
  distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
  dist = sqrt(distsquared)
  return dist
end

# this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
# it returns a point as a list of coordinates
def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
  xf = xi + uvx * delta
  yf = yi + uvy * delta
  zf = zi + uvz * delta
  ret = [xf, yf, zf]
  return ret
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the bottom side of the gun facing up. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang(heading):
 axisxraw = -1 * sin(heading)
 axisyraw = cos(heading) + 1
 axiszraw = sin(heading)

 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)

 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude

 angle = acos( (cos(heading) - 1) / 2 )

 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatup(heading):
 axisxraw = -sin(heading) + 1
 axisyraw = cos(heading)
 axiszraw = cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_preheatdown(heading):
 axisxraw = -sin(heading) - 1
 axisyraw = cos(heading)
 axiszraw = -cos(heading)
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (sin(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
# this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box. 
# the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
def convert_heading_to_axang_ccw(heading):
 axisxraw = -sin(heading) 
 axisyraw = cos(heading) - 1
 axiszraw = -sin(heading) 
 
 magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
 
 axisxunit = axisxraw / magnitude
 axisyunit = axisyraw / magnitude
 axiszunit = axiszraw / magnitude
 
 angle = acos( (-cos(heading) - 1) / 2 )
 
 rxout = axisxunit * angle
 ryout = axisyunit * angle
 rzout = axiszunit * angle
 
 return [rxout, ryout, rzout]
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.03 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] &gt; p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

def get_corner_homing_45_pathpoints_cover(point0):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
    
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.04 # first distance from init point
    d2 = 0.15 # second distance from init point
    d4 = 0.06 # top distance from init point - larger to avoid large chamfers
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
    
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
    
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
    #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
    
    # approach point for top
    ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner. 
    
    # top point
    ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
    is_robot_at_reachable_spot(point0, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_cover(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points (the rxryrz are given in pretend_welder_top coordinates. they match pure rotations of 90 degrees)
    ph1 = p[lpx + d0, lpy, lpz - d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz - d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d2, lpy, lpz + d0, 2.221, -2.221, 0] # left top approach
    ph4 = p[rpx - d2, rpy, rpz + d0, 2.221, -2.221, 0] # right top approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_floor(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points
    ph1 = p[lpx + d0, lpy, lpz + d2, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz + d2, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d1, lpy, lpz - d0, 0, 0, 0] # left bottom approach
    ph4 = p[rpx - d1, rpy, rpz - d0, 0, 0, 0] # right bottom approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z &lt; -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight &lt; 1.04775 - 0.400:
    # bad
    popuptext = &quot;Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = &quot;&quot;
    listnames = [&quot;ph1&quot;, &quot;ph2&quot;, &quot;ph3&quot;, &quot;ph4&quot;, &quot;ph5&quot;, &quot;ph6&quot;, &quot;ph7&quot;, &quot;ph2up&quot;, &quot;ph4up&quot;]
    i = 0
    structlength = 9
    while i &lt; structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
end

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are valid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i &lt; structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X &gt; -1300)
  # if y &lt; 0, then x &lt; -1300. if y &lt; 480, then y &gt; (1300+x)*8. if y &gt; 480, then y &gt; (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] &lt; 0:
    if pointintersect[0] &gt; -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] &lt; 0.480:
    if pointintersect[1] &lt; (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] &lt; (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees &lt; 201 or heading1degrees &gt; 231 :
    # then out of range
    popuptext = &quot;Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=&quot; + str_cat(&quot;&quot;,heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset &gt; 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset &lt; 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x &gt; a*y+b
    if pointintersect[0] &gt; a * pointintersect[1] + b:
      # bad
      popuptext = &quot;Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. &quot; 
      # infinite loop
      while 1==1:
        popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
      end
    end
  else:
    # headingoffset &gt; 5 degrees
    if pointintersect[1] &lt; 0:
      if pointintersect[0] &gt; -1150.0 / 1000.0:
        #bad
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    else:
      # if x &gt; .7736 y - 1101.9 then bad
      if pointintersect[0] &gt; 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = &quot;Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. &quot; 
        # infinite loop
        while 1==1:
          popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = &quot;&quot;
  listnames = [&quot;point1&quot;, &quot;point2&quot;, &quot;point4&quot;, &quot;point5&quot;, &quot;point_1&quot;, &quot;point_2&quot;, &quot;point_3&quot;, &quot;point_4&quot;, &quot;point_5&quot;]
  while i &lt; structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      allvalid = False
      listproblems = listproblems + listnames[i]
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = &quot;Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. &quot; + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i &lt; structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2&apos;s points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = &quot;Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Robot Positioning Warning&quot;,blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i &lt; structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr &gt; degreesmax or joint_curr &lt; degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference &gt; maxdifference or difference * -1 &gt; maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
  
end

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;r&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;1&quot;])
  # if resp &lt;&gt; &quot;uR1&quot;
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal([&quot;u&quot;, &quot;R&quot;, &quot;0&quot;])
    resp3 = send_serial_signal([&quot;u&quot;, &quot;H&quot;, &quot;0&quot;])
    popuptext = &quot;Error code encountered while trying to start extrusion. Find Calvin. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Extrusion Error Code&quot;,blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command(&quot;/dev/ttyUSB0&quot;,1200, 8, &quot;None&quot;, &quot;One&quot;, &quot;None&quot;, 1000, &quot;None&quot;, &quot;None&quot;, listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == &quot;A&quot;:
    return 65
  elif letter == &quot;H&quot;:
    return 72
  elif letter == &quot;R&quot;:
    return 82
  elif letter == &quot;M&quot;:
    return 77
  elif letter == &quot;E&quot;:
    return 69
  elif letter == &quot;a&quot;:
    return 97
  elif letter == &quot;b&quot;:
    return 98
  elif letter == &quot;h&quot;:
    return 104
  elif letter == &quot;r&quot;:
    return 114
  elif letter == &quot;s&quot;:
    return 115
  elif letter == &quot;m&quot;:
    return 109
  elif letter == &quot;0&quot;:
    return 48
  elif letter == &quot;1&quot;:
    return 49
  elif letter == &quot;2&quot;:
    return 50
  elif letter == &quot;3&quot;:
    return 51
  elif letter == &quot;4&quot;:
    return 52
  elif letter == &quot;5&quot;:
    return 53
  elif letter == &quot;6&quot;:
    return 54
  elif letter == &quot;7&quot;:
    return 55
  elif letter == &quot;8&quot;:
    return 56
  elif letter == &quot;9&quot;:
    return 57
  elif letter == &quot;?&quot;:
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # send the signal
  resp1 = send_serial_signal([&quot;u&quot;, &quot;s&quot;, &quot;?&quot;])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = &quot;Welder is not ready for extrusion. Follow the instructions to start heating welder. &quot;
    while 1==1:
      popup(popuptext, title=&quot;Welder Not Ready&quot;,blocking=True)
    end
  end
  
end

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 &quot;MachineLogic Get Position&quot;
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
    temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
    while(temp_estop_var_vention==&quot;estop/status true&quot;):
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        sendStringWithTimeout(&quot;estop/systemreset/request&quot;,&quot;Ack estop/systemreset/request;&quot;,&quot;MachineMotion1&quot;)
      end
      socket_send_string(&quot;estop/status;&quot;, &quot;MachineMotion1&quot;)
      temp_estop_var_vention = socket_read_string(&quot;MachineMotion1&quot;,timeout=15)
      if temp_estop_var_vention==&quot;estop/status true&quot;:
        popup(&quot;MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.&quot;,blocking=True)
      end
    end
  else:
    popup(&quot;resource is being used already: MachineMotion1&quot;)
    halt
  end
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end

def get_lift_column_height_condensed():
  socket_send_string(&quot;GET im_get_controller_pos_axis_1;&quot;, &quot;MachineMotion1&quot;)
  temp_drive = socket_read_ascii_float(1, &quot;MachineMotion1&quot;,timeout=15)
  ret = temp_drive[1]
  return ret
end

# this function takes two rotation matrices, and multiplies them together, returning one matrix. 
# all matrices are in the form of a list.
# all matrix values have constant values (no variables)
def multiply_matrix(matrix1, matrix2):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    b11 = matrix2[0]
    b12 = matrix2[1]
    b13 = matrix2[2]
    b21 = matrix2[3]
    b22 = matrix2[4]
    b23 = matrix2[5]
    b31 = matrix2[6]
    b32 = matrix2[7]
    b33 = matrix2[8]
    #calculate c values
    c11 = a11*b11 + a12*b21 + a13*b31
    c12 = a11*b12 + a12*b22 + a13*b32
    c13 = a11*b13 + a12*b23 + a13*b33
    c21 = a21*b11 + a22*b21 + a23*b31
    c22 = a21*b12 + a22*b22 + a23*b32
    c23 = a21*b13 + a22*b23 + a23*b33
    c31 = a31*b11 + a32*b21 + a33*b31
    c32 = a31*b12 + a32*b22 + a33*b32
    c33 = a31*b13 + a32*b23 + a33*b33
    # return resulting matrix
    ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
    return ret
end

# this function converts a matrix to axis angle representations
# this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
# returns a list of [rx,ry,rz]
def convert_matrix_to_axang(matrix1):
    # retrieve values
    a11 = matrix1[0]
    a12 = matrix1[1]
    a13 = matrix1[2]
    a21 = matrix1[3]
    a22 = matrix1[4]
    a23 = matrix1[5]
    a31 = matrix1[6]
    a32 = matrix1[7]
    a33 = matrix1[8]
    
    # First Half: find the angle    
    # find the trace
    # using the formula: trace = a11 + a22 + a33
    trace = a11 + a22 + a33
    # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
    angle = acos((trace - 1.0)/2.0)
    
    # Second Half: calculate the rotation axis
    axisxraw = a32 - a23
    axisyraw = a13 - a31
    axiszraw = a21 - a12
    # normalize axis
    magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
    axisxunit = axisxraw / magnitude
    axisyunit = axisyraw / magnitude
    axiszunit = axiszraw / magnitude
    
    # combine axis and angle into rxryrz representation
    rxout = axisxunit * angle
    ryout = axisyunit * angle
    rzout = axiszunit * angle
    return [rxout, ryout, rzout]
end

# this function takes a rotation and calculates the corresponding rotation matrix
# input is (axis, direction, angle in radians)
# example is (&quot;x&quot;, 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
# returns a matrix (a list of 9 values)
def get_rotation_matrix_from_description(axis, direction, angle):
    # get the angle
    a = angle * direction
    # get the axis
    if axis == &quot;x&quot; or axis == &quot;X&quot;:
        matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
        return matrix
    end
    if axis == &quot;y&quot; or axis == &quot;Y&quot;:
        matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
        return matrix
    end
    if axis == &quot;z&quot; or axis == &quot;Z&quot;:
        matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
        return matrix
    end
    # bad
    popuptext = &quot;Error in get_rotation_matrix_from_description. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Code Error&quot;,blocking=True)
    end
end

# this function takes in a struct of only points. it checks those points for validity. 
# if one of them is not valid, it throws a popup loop
def check_validity_only(struct2):
    validity = check_structofpoints_validity(struct2)
    if not validity:
    # bad
    popuptext = &quot;Not all weldpoints are valid. &quot;
    # infinite loop
    while 1==1:
      popup(popuptext, title=&quot;Position Error&quot;,blocking=True)
    end
    end
end

def main_calculate_step(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top, leftseam, leftobstacle):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    if leftseam:
        if leftobstacle:
            struct2 = calculate_LtUA_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
            heading1deg = struct1[1] * 180/pi
            if heading1deg &lt; 210:
                popup(&quot;Robot is not aligned 45 degree angle from corner. Wrist pinch may bonk, Align robot 45 degrees from corner and try again. &quot;, title=&quot;Alignment Error&quot;,blocking=True)
            end
        else:
            struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
        end
    else:
        if leftobstacle:
            # error: this geometry is impossible for the robot to weld
            popup(&quot;Cannot weld a right seam, left obstacle step corner with robot. please weld by hand. &quot;, title=&quot;Geometry Error&quot;,blocking=True)
        else:
            struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
        end
    end
    validity = check_validity_only(struct2)
    return struct2
end

def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
    validity = check_validity_only(struct2)
    return struct2
end

# analyze_touchpoints_only()
# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
#   FIND HEADINGS
#for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
# so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box. 
# we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
def step_right_demo(struct1):
    pointintersect = struct1[0]
    x = pointintersect[0]
    y = pointintersect[1]
    z = pointintersect[2]
    heading1 = struct1[1]
    heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
    heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
    # heading1 == heading1adj2. ok 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
    popup(point_demo)
    movej(point_demo, a=1.4, v=0.1)
    popup(point_demo)
    ret = struct(point_demo = point_demo)
    return ret
end

# for a left seam step corner, calculate the toolpath points for a L (under) then Up and Around weld. for left obstacle step. 
def calculate_LtUA_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = tcp_pose_top[2] - pointintersect[2] # the z distance from the corner to the top of the weld
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    # get rxryrz for facing along towards the intersection. heading1 +90 deg - 90 deg
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    # get rxryrz for facing along the second edge pointed toward the left. heading 3 + 90 - 90
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # now calculate the points of the Up Around
    # don&apos;t use heading3 at all. 
    #point201 is at the chamfer intersection
    p201x = xbottom
    p201y = ybottom
    p201z = z
    
    # rxryrz is the same 
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, p201z, rx, ry, rz]
    
    # find side point (point on the side. where point 203 would be if roundoverdistance was 0)
    sidex = pointintersect[0] + l2delxunit * rightwallthickmm
    sidey = pointintersect[1] + l2delyunit * rightwallthickmm
    sidez = z
    
    # p202
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p202x = sidex + rod * l1delxunit
    p202y = sidey + rod * l1delyunit
    p202z = sidez
    point202 = p[p202x, p202y, p202z, rx, ry, rz]
    
    # p204 end of circle move
    p204x = sidex
    p204y = sidey
    p204z = sidez + rod
    
    # calculate rxryrz
    # first rotation: 90 degrees about x axis. positive direction. preheat is now facing up, and gun tip is pointed towards y- direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 90 * pi / 180)
    # second rotation: rotate about z until you are facing into the front face. but only use heading 1
    # heading 1 is about 225 degrees. i need to go about 225 degrees. starting from y- instead of x+ cancels out the extra 90 degrees needed to go into face1 instead of parallel to face1
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point204 = p[p204x, p204y, p204z, rx, ry, rz]
    
    #p205 (end of straight after cirlce move, before listleans
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point205 = p[p204x, p204y, sidez + sld, rx, ry, rz]
    
    #p206 (top of weld)
    p206x = sidex + wd3 * listleans[0]
    p206y = sidey + wd3 * listleans[1]
    p206z = sidez + wd3
    point206 = p[p206x, p206y, p206z, rx, ry, rz]
    
    # p203 (middle of turn)
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p203z = sidez + delta
    p203x = sidex + delta * l1delxunit
    p203y = sidey + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 45 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point203 = p[p203x, p203y, p203z, rx, ry, rz]
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point201=point201, point202=point202, point203=point203, point204=point204, point205=point205, point206=point206)
    return struct2
end

# for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld. 
def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on left side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1 
    # only use the right side taps for circle move related things
    heading3basedh1 = heading1 - pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
    # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
    heading1descr = heading1 - pi
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l1delxunit * rod
    p4y = y + l1delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l1delxunit * wd2
    p5y = y + l1delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1descr) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on right side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1 
    # only use the left side taps for circle move related things
    heading1basedh3 = heading3 + pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l2delxunit * rod
    p4y = y + l2delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l2delxunit * wd2
    p5y = y + l2delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
# returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
def calc_rod_midpoint_90deg(rod):
    # the factor is (1- 1/sqrt(2))
    factor = 0.292893
    ret = rod * factor
    return ret
end

# this is the main entry point for calculations, for Cover Corner.
# it takes in the 4 touchpoints, analyzes the shape of the box. 
# returns the pathpoints
# specifically for Around and Down then Straight (AtS)
# specifically for left-sided boxes (vertical weld on left side of edge)
# leftchoice is a boolean and deepcovercham is a boolean but leftwallthick, rightwallthick are decimals in inches. 
def main_calculate_cover(p11, p12, p21, p3, leftwallthick, rightwallthick, leftchoice, deepcovercham):
    struct1 = analyze_touchpoints_only_cover(p11, p12, p21, p3)
    if leftchoice:
        struct2 = calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham)
    else:
        struct2 = calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham)
    end
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
end

def calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end
    
    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 (start point on top of cover welding towards corner)
    p1x = x + l1delxunit * wd1 + deepchambumpmm * l2delxunit
    p1y = y + l1delyunit * wd1 + deepchambumpmm * l2delyunit
    point1 = p[p1x, p1y, z, rx, ry, rz]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l1delxunit * rod
    p2y = y + l1delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2. 
    if deepcovercham:
        speed = 6 # mm/s
        wtod = shutofftime * speed / 1000 #weldturnoffdistance
    else:
        speed = 10 # mm/s
        wtod = shutofftime * speed / 1000
    end
    p2ax = x + l1delxunit * wtod
    p2ay = y + l1delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]
    
    # calculate the rxryrz for facing the down the left side of the box
    # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx3 = rxryrz[0]
    ry3 = rxryrz[1]
    rz3 = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    #todo: calculate trail out points
    botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = x
    p101y = y
    p101z = z - wd2 + dist
    point101 = p[p101x, p101y, p101z, rx, ry, rz]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = x + l1delxunit * tiltraise * -1
    p102y = y + l1delyunit * tiltraise * -1
    p102z = z - wd2 + dist
    
    # calculate rxryrz
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point102 = p[p102x, p102y, p102z, rx, ry, rz]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * (leftwallthickmm + deepchambumpmm) + l2delxunit * pushtipforward 
    p201y = y + l1delyunit * (leftwallthickmm + deepchambumpmm) + l2delyunit * pushtipforward
    
    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading3 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l2delxunit * pushtipforward2
    p201by = p201y + l2delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
    return struct2
end

def calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 6 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 6 # second path (back away) # inches
    
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = pointintersect[2]
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        z = 0
    else:
        z = zpi
    end

    # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren&apos;t any circle motion)
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    #z = pointintersect[2] # replaced by z of lift column (directly above)
    pointtopvcham = p[x, y, z, 0, 0, 0]

    # calculate the rxryrz for the gun when it&apos;s at point1
    # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
    # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
    # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # next, calculate point1 (start point on top of cover welding towards corner)
    p1x = x + l2delxunit * wd1 + deepchambumpmm * l1delxunit
    p1y = y + l2delyunit * wd1 + deepchambumpmm * l1delyunit
    point1 = p[p1x, p1y, z, rx, ry, rz]

    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p2x = x + l2delxunit * rod
    p2y = y + l2delyunit * rod
    point2 = p[p2x, p2y, z, rx, ry, rz] 
    
    # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
    shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2. 
    if deepcovercham:
        speed = 6 # mm/s
        wtod = shutofftime * speed / 1000 #weldturnoffdistance
    else:
        speed = 10 # mm/s
        wtod = shutofftime * speed / 1000
    end
    p2ax = x + l2delxunit * wtod
    p2ay = y + l2delyunit * wtod
    point2a = p[p2ax, p2ay, z, rx, ry, rz]

    # calculate the rxryrz for facing the down the right side of the box
    # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]

    # calculate point4
    point4 = p[x, y, z - rod, rx, ry, rz]
    
    # calculate point5
    point5 = p[x, y, z - wd2, rx, ry, rz]

    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z - delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit

    # calculate rxryrz
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx3 = rxryrz[0]
    ry3 = rxryrz[1]
    rz3 = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]

    #todo: calculate trail out point
    botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
    tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
    # calculate point5a (point101) (start of tilt back) (start of unflatten)
    dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
    p101x = x
    p101y = y
    p101z = z - wd2 + dist
    point101 = p[p101x, p101y, p101z, rx, ry, rz]
    
    # calculate point5b (point 102) (end of unflatten)
    dist = 0.5 * 25.4 / 1000
    tiltraise = 0.006
    p102x = x + l2delxunit * tiltraise * -1
    p102y = y + l2delyunit * tiltraise * -1
    p102z = z - wd2 + dist
    
    # calculate rxryrz
    tiltangledeg = 10 # ten degree angle of tilt
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading3 - pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point102 = p[p102x, p102y, p102z, rx, ry, rz]
    
    # calculate point 5c (point 103) (end of smear)
    dist = -2 * 25.4/1000
    point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall&apos;s angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * (rightwallthickmm + deepchambumpmm) + l1delxunit * pushtipforward
    p201y = y + l2delyunit * (rightwallthickmm + deepchambumpmm) + l1delyunit * pushtipforward

    # calculate rxryrz
    # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 180 * pi / 180)
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + pi/2)
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 201&apos;s preheat
    pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
    preheatdistance = 0.010 # 10 mm . above what it would be pushed down
    point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
    p201bx = p201x + l1delxunit * pushtipforward2
    p201by = p201y + l1delyunit * pushtipforward2
    point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
    point201c = p[p201bx, p201by, z, rx, ry, rz]

    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]

    struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
    return struct2
end

def main_calculate_cover_straight(p11, p12, p21, p22, sidewallthick, leftpoint, rightpoint, deepcovercham):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_cover(struct1, sidewallthick, leftpoint, rightpoint, deepcovercham)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# calculates the line of intersection of the sidewall plane (assumed vertical) and the cover plane (assumed perpendicular to sidewall plane)
# returns a struct containing point0 (point on the intersection line, same y as leftpoint) and 3 components of the unit vector left to right and 2 components of the other direction in 2d
def analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint):
    # calculate slope of sidewall in x-y plane
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
    
    # calculate the cover plane
    # if two planes are perpendicular, then their normal vectors must be perpendicular. 
    # the first planes normal vector is n1, which is taken from the equation of the plane ax + by + cz = d -&gt; &lt;a, b, c&gt;
    # the second plane&apos;s normal vector is perpendicular to all vectors contained in the plane
    # p21 to p22 is a vector v contained within plane 2. 
    # n2 is normal to both n1 AND v. to achieve a vector that is normal to both, take the cross product
    
    # plane 1 (y = mx + b) -&gt; (b = -mx +1y +0z)
    n1 = [-1 * ml1, 1, 0]
    
    # v=P2P1=(x2x1,y2y1,z2z1)
    v = [p21[0]-p22[0], p21[1]-p22[1], p21[2]-p22[2]]
    
    #v n2 = cross product of n1 and v
    n2x = n1[1]*v[2] - n1[2]*v[1]
    n2y = n1[2]*v[0] - n1[0]*v[2]
    n2z = n1[0]*v[1] - n1[1]*v[0]
    n2 = [n2x, n2y, n2z]
    
    # find the d of the second plane
    # n2x * x + n2y * y + n2z * z = d0
    d = n2x * p21[0] + n2y * p21[1] + n2z * p21[2]
    
    # find the intersection line of the two planes
    # find the direction vector of that line by taking the cross product of the normal vector of those two planes
    v3x = n1[1]*n2[2] - n1[2]*n2[1]
    v3y = n1[2]*n2[0] - n1[0]*n2[2]
    v3z = n1[0]*n2[1] - n1[1]*n2[0]
    v3 = [v3x, v3y, v3z]
    
    # normalize the vector so the magnitude is 1
    magnitude2 = v3x * v3x + v3y * v3y + v3z * v3z
    magnitude = sqrt(magnitude2)
    v3xunit = v3x/magnitude
    v3yunit = v3y/magnitude
    v3zunit = v3z/magnitude
    
    # make sure it is going the right way (from left to right). make sure the v3yunit is positive
    if v3yunit &lt; 0:
        v3xunit = v3xunit * -1
        v3yunit = v3yunit * -1
        v3zunit = v3zunit * -1
    end
    
    # next we have to find a point on the line by setting one of the dimensions and solving the system of equations
    # i will pick the y value of the left teach point
    y = leftpoint[1]
    # plane 1: -ml1 * x + 1 * y + 0 * z = bl1
    # -ml1 * x = bl1 - y
    x = (bl1 - y)/ (-1 * ml1)
    # plane 2: d = n2x * x + n2y * y + n2z * z
    # (d - n2x * x - n2y * y) = n2z * z
    z = (d - n2x * x - n2y * y) / n2z
    
    # make point0 into a pose
    point0 = p[x, y, z, 0, 0, 0]
    
    # find heading of main line
    heading1 = convert_uv_to_heading(v3xunit, v3yunit)
    
    # make a unit vector perpendicular to this one in the xy plane pointing x -. will be used to move over the chamfer distance
    ml2 = -1 / ml1
    # y = ml2 * x + unknownB
    # vector = [1, ml2]
    mag2 = 1 + ml2 * ml2
    mag = sqrt(mag2)
    v4xunit = 1 / mag
    v4yunit = ml2 / mag
    # switch is to the x direction is negative
    v4xunit = -1 * v4xunit
    v4yunit = -1 * v4yunit
    
    ret = struct(point0=point0, v3xunit=v3xunit, v3yunit=v3yunit, v3zunit=v3zunit, heading1=heading1, v4xunit=v4xunit, v4yunit=v4yunit)
    return ret
end

def calculate_straight_points_cover(struct1, sidewallthick, leftpointteach, rightpointteach, deepcovercham):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    sidewallthick = sidewallthick
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = p0z
    if zpi &gt; 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        coverz = 0
    else:
        coverz = zpi
    end
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # calculate pointtopvcham
    chamferover = sidewallthick * 25.4 / 1000.0 + deepchambumpmm
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    x = p0x + v4xunit * chamferover
    y = p0y + v4yunit * chamferover
    z = coverz + tiltraise
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # second rotation is a 10 degree turn about the x axis (negative direction)
    m2 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 10 * pi / 180)
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = -1 * 25.4 / 1000.0 # move back 1 inch from 
    p1x = x + dist * v3xunit
    p1y = y + dist * v3yunit
    p1z = z + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x + dist * v3xunit
    p2y = y + dist * v3yunit
    p2z = z + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate rxryrz for nontilted
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    m5 = multiply_matrix(m3, m1)
    rxryrz = convert_matrix_to_axang(m5)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point3 (end of flatten)
    dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x + dist * v3xunit
    p3y = y + dist * v3yunit
    p3z = coverz + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that&apos;s what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    
    # calculate point4 (start of unflatten)
    dist = -1.5 * 25.4 / 1000.0 
    p4x = x2 + v3xunit * dist
    p4y = y2 + v3yunit * dist
    p4z = z2 + v3zunit * dist - tiltraise
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = -0.5 * 25.4 / 1000.0 
    p5x = x2 + v3xunit * dist
    p5y = y2 + v3yunit * dist
    p5z = z2 + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = 2 * 25.4 / 1000.0 
    p6x = x2 + v3xunit * dist
    p6y = y2 + v3yunit * dist
    p6z = z2 + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
    
end

def main_calculate_floor_straight(p11, p12, p21, p22, floorthick, leftpoint, rightpoint):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_floor(struct1, floorthick, leftpoint, rightpoint)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# the path for welding a floor straight weld with v chisels on both sides. 
# start at the right side and move left. 
def calculate_straight_points_floor(struct1, floorthick, leftpointteach, rightpointteach):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do not, because the floors are low)
    zpi = p0z
    floorz = zpi
    
    # calculate pointtopvcham (left point) (tilted and tiltraised)
    chamferup = floorthick * 25.4 / 1000.0
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    # on this one, move the tiltraise distance sideways (towards robot) and the chamferover distance up
    x = p0x + v4xunit * tiltraise * -1
    y = p0y + v4yunit * tiltraise * -1
    z = floorz + chamferup
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 90 degrees about y axis. positive direction. gun is now pointing in the x+ direction with preheat facing +y direction
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, 1, 90 * pi / 180) 
    # second rotation is about 180 degrees about the z axis. heading1 plus 90 degrees. gun is now pointing directly into the sidewall
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # third rotation is 10 degrees about the z axis. gun is now tilted back 10 degrees from the sidewall
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, 10 * pi / 180)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    # the non tilted angle is just m4
    rxryrz = convert_matrix_to_axang(m4)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that&apos;s what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2 (right point) (tilted and tiltraised)
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    pointtopvcham2 = p[x2, y2, z2, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = 1 * 25.4 / 1000.0 # move back 1 inch from ptvc2 (in this case back means positive)
    p1x = x2 + dist * v3xunit
    p1y = y2 + dist * v3yunit
    p1z = z2 + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = -0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x2 + dist * v3xunit
    p2y = y2 + dist * v3yunit
    p2z = z2 + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate point3 (end of flatten)
    dist = -1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x2 + dist * v3xunit + tiltraise * v4xunit
    p3y = y2 + dist * v3yunit + tiltraise * v4yunit
    p3z = z2 + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate point4 (start of unflatten)
    dist = 1.5 * 25.4 / 1000.0 
    p4x = x + v3xunit * dist + tiltraise * v4xunit
    p4y = y + v3yunit * dist + tiltraise * v4yunit
    p4z = z + v3zunit * dist
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = 0.5 * 25.4 / 1000.0 
    p5x = x + v3xunit * dist
    p5y = y + v3yunit * dist
    p5z = z + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = -2 * 25.4 / 1000.0 
    p6x = x + v3xunit * dist
    p6y = y + v3yunit * dist
    p6z = z + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
end

# this function determines the starting touchpoints for homing in on cover lt geometry
# includes two points above the cover lt, closer to the robot than the lt, facing down
def get_coverlt_homing_pathpoints(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from (in meters)
    d0 = 0.05 # how far from the cover to approach from
    d1 = 0.03 # how far the touchpints are pushed closer to the robot
    d2 = 0.00 # how far inwards the touchpoints are pushed
    
    # rxryrz
    rxryrz = [0.334, 3.124, 0]
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate the points
    ph1 = p[lpx + d1, lpy + d2, lpz + d0, rx, ry, rz] # left side approach
    ph2 = p[rpx + d1, rpy - d2, rpz + d0, rx, ry, rz] # right side approach
    
    ret = struct(ph1=ph1, ph2=ph2)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

def main_calculate_cover_lt(p11, p12, leftpoint, rightpoint):
    struct1 = analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint)
    struct2 = calculate_points_cover_lt(struct1)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

def analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint):
    # calculate the slope of the groove in xy plane
    l1p1x = leftpoint[0]
    l1p1y = leftpoint[1]
    l1p2x = rightpoint[0]
    l1p2y = rightpoint[1]
    
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
    
    # zraise (how much the z value changes from left point to right point
    zraise = p12[2] - p11[2]
    
    #get the calcpoints
    leftcalcpoint = [leftpoint[0], leftpoint[1], p11[2]]
    rightcalcpoint = [rightpoint[0], rightpoint[1], p12[2]]
    # get the vector from a to b
    vec = [rightcalcpoint[0] - leftcalcpoint[0], rightcalcpoint[1] - leftcalcpoint[1], rightcalcpoint[2] - leftcalcpoint[2]]
    # get the unit vector in 3d
    mag3d = sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])
    vec3dunit = [vec[0]/mag3d, vec[1]/mag3d, vec[2]/mag3d]
    # get the unit vector in 2d
    mag2d = sqrt(vec[0]*vec[0]+vec[1]*vec[1])
    vec2dunit = [vec[0]/mag2d, vec[1]/mag2d]
    # get the heading
    heading1 = convert_uv_to_heading(vec2dunit[0], vec2dunit[1])
    
    ret = struct(leftcalcpoint=leftcalcpoint, rightcalcpoint=rightcalcpoint, vxunit=vec3dunit[0], vyunit=vec3dunit[1], vzunit=vec3dunit[2], heading1=heading1)
    return ret
end

def calculate_points_cover_lt(struct1):
    # get the stuff from struct
    leftcalcpoint = struct1[0]
    x = leftcalcpoint[0]
    y = leftcalcpoint[1]
    z = leftcalcpoint[2]
    rightcalcpoint = struct1[1]
    x2 = rightcalcpoint[0]
    y2 = rightcalcpoint[1]
    z2 = rightcalcpoint[2]
    v3xunit = struct1[2]
    v3yunit = struct1[3]
    v3zunit = struct1[4]
    heading1 = struct1[5]
    
    # first calculate rxryrz f normal and tiltback
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # second rotation is a 10 degree turn about the x axis (negative direction)
    m2 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 10 * pi / 180)
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    
    # calculate rxryrz for nontilted
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 180 * pi / 180) 
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description(&quot;z&quot;, 1, pi/2 + heading1)
    m5 = multiply_matrix(m3, m1)
    rxryrz = convert_matrix_to_axang(m5)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    
    # calculate points 1-3
    # calculate point1 (preheat)
    dist = -1 * 25.4 / 1000.0 # move back 1 inch from 
    p1x = x + dist * v3xunit
    p1y = y + dist * v3yunit
    p1z = z + dist * v3zunit + tiltraise
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x + dist * v3xunit
    p2y = y + dist * v3yunit
    p2z = z + dist * v3zunit + tiltraise
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate point3 (end of flatten)
    dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x + dist * v3xunit
    p3y = y + dist * v3yunit
    p3z = z + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate points 4-6
    # calculate point4 (start of unflatten)
    dist = -1.5 * 25.4 / 1000.0 
    p4x = x2 + v3xunit * dist
    p4y = y2 + v3yunit * dist
    p4z = z2 + v3zunit * dist
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = -0.5 * 25.4 / 1000.0 
    p5x = x2 + v3xunit * dist
    p5y = y2 + v3yunit * dist
    p5z = z2 + v3zunit * dist + tiltraise
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = 2 * 25.4 / 1000.0 
    p6x = x2 + v3xunit * dist
    p6y = y2 + v3yunit * dist
    p6z = z2 + v3zunit * dist + tiltraise
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    # return struct
    ret = struct(pointtopvcham=leftcalcpoint, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
end

def main_calculate_sleeve_fillet(p1, p2, p3):
    struct1 = analyze_touchpoints_only_sleeve_fillet(p1, p2, p3)
    struct2 = calculate_points_sleeve_fillet_quadonly(struct1)
    return struct2
end

# given 3 points at the intersection of the sleeve and the sidewall, this calculates and returns 3 things:
# the centerpoint of the circle on the plane, the normal vector of the plane, and the radius of the circle
# then it returns 4 more things after converting to a vertical circle/plane: heading1 (into the plane), vecn, vecr, vecu
def analyze_touchpoints_only_sleeve_fillet(p1, p2, p3):
    x1 = p1[0]
    y1 = p1[1]
    z1 = p1[2]
    x2 = p2[0]
    y2 = p2[1]
    z2 = p2[2]
    x3 = p3[0]
    y3 = p3[1]
    z3 = p3[2]
    
    # calculate plane
    # calculate ab (1-&gt;2) vector
    abvec = [x2-x1, y2-y1, z2-z1]
    # calculate ac (1-&gt;3) vector
    acvec = [x3-x1, y3-y1, z3-z1]
    #calculate the plane&apos;s normal vector = ab x ac
    
    n = crossproduct(abvec, acvec)
    mag = sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2])
    n = [n[0]/mag, n[1]/mag, n[2]/mag]
    d = n[0] * x1 + n[1] * y1 + n[2] * z1
    
    # find the circle
    # Midpoint of AB:
    mab = [(x1 + x2)/2, (y1 + y2)/2, (z1 + z2)/2]
    # midpoint of ac
    mac = [(x3 + x1)/2, (y3 + y1)/2, (z3 + z1)/2]
    # Get Normal Vectors to AB and AC in the Plane
    # nab (normal to ab) = abvec x n
    nab = crossproduct(abvec, n)
    # nac (normal to ac) = acvec x n
    nac = crossproduct(acvec, n)
    # Define Perpendicular Bisector Lines
    # Each line goes through a midpoint and extends in the direction of the na_
    # we already have the equations of those lines in point vector form with l1 = mab + s * nab, and l2 = mac + t * nac
    # define all the terms so the math is simpler when i have to do math
    mabx = mab[0]
    maby = mab[1]
    mabz = mab[2]
    nabx = nab[0]
    naby = nab[1]
    nabz = nab[2]
    macx = mac[0]
    macy = mac[1]
    macz = mac[2]
    nacx = nac[0]
    nacy = nac[1]
    nacz = nac[2]
    # find the intersection point using the y and z equations
    # maby + s * naby = macy + t * nacy
    # mabz + s * nabz = macz + t * nacz
    # first solve for s and take
    # t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    # s = (t*nacz + macz - mabz) / nabz
    s = (t*nacz + macz - mabz) / nabz
    # find the point
    # pcenter = mac + t * nac
    pcenterx = macx + t * nacx
    pcentery = macy + t * nacy
    pcenterz = macz + t * nacz
    rxryrz = [0.528, 4.631, 0.258] # demo point of the welder pointing forward into a sleeve
    pcenter = p[pcenterx, pcentery, pcenterz, rxryrz[0], rxryrz[1], rxryrz[2]]
    radius = distance_between(pcenterx, pcentery, pcenterz, x1, y1, z1)
    
    # ------ start calculation of vertical assumption -----
    # assume the plane close to vertical
    # fix it to make it actually vertical
    # calculate the unit vector of up, and the unit vector of right. 
    # calculate the heading from the +x axis to pointing straight into the wall. 
    # the unit vector of up is [0, 0, 1] (because the plane is verticalized) (for easier calculations)
    # first calculate the normal vector INTO the sidewall (make sure x is negative) and make it a unit vector
    vecn = [n[0], n[1], 0] # vector normal
    if vecn[0] &gt; 0:
        vecn = [-n[0], -n[1], 0]
    end
    mag = sqrt(vecn[0]*vecn[0]+vecn[1]*vecn[1])
    vecn = [vecn[0]/mag, vecn[1]/mag, 0]
    # next calculate the right normal vector (the vector IN the plane that goes to the right)
    vecr = [vecn[1], -1*vecn[0], 0]
    vecu = [0, 0, 1] # vector up
    heading1 = convert_uv_to_heading(vecn[0], vecn[1])
    
    
    ret = struct(pcenter=pcenter, planenormalvec=n, radius=radius, heading1=heading1, vecn=vecn, vecr=vecr, vecu=vecu)
    return ret
end

def crossproduct(vec1, vec2):
    nx = vec1[1]*vec2[2] - vec1[2]*vec2[1]
    ny = vec1[2]*vec2[0] - vec1[0]*vec2[2]
    nz = vec1[0]*vec2[1] - vec1[1]*vec2[0]
    ret = [nx, ny, nz]
    return ret
end

def calculate_points_sleeve_fillet(struct1):
    
end

# this function calculates only the four points of the quadrants, for the not real program. 
# these calculations are easier so that&apos;s why i&apos;m starting with them first. 
# this assumes a vertical plane
def calculate_points_sleeve_fillet_quadonly(struct1):
    # get the stuff from the struct
    pcenter = struct1[0]
    pcx = pcenter[0]
    pcy = pcenter[1]
    pcz = pcenter[2]
    planenormalvec = struct1[1]
    radius = struct1[2]
    heading1 = struct1[3]
    vecn = struct1[4]
    vecnx = vecn[0]
    vecny = vecn[1]
    vecr = struct1[5]
    vecrx = vecr[0]
    vecry = vecr[1]
    vecu = struct1[6]
    vecuz = vecu[2]
    
    # define cushions (the backofhole can&apos;t actually touch the intersection of pipe and wall, it travels a certain distance around it
    cushout = 0.005 # 5mm # the cushion out from the wall
    cusharound = 0.005 # 5mm # the cushion around the sleeve. 
    
    # get the top point (point1)
    # take the center point and move up the radius plus the cushions
    p1x = pcx + vecnx * -1 * cushout
    p1y = pcy + vecny * -1 * cushout
    p1z = pcz + vecuz * radius + vecuz * cusharound
    
    # find rxryrz1
    # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, -1, 135 * pi / 180)
    # second rotation is heading1  180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - 180 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # get second point (right) (point2)
    # take the center point and move right the radius plus the cushions
    p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * cushout
    p2y = pcy + vecry * radius + vecry * cusharound + vecny * cushout
    p2z = pcz
    
    # find rxryrz2
    # first rotation is 90 degrees about the x- axis
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, -1, 90 * pi / 180)
    # second rotation is About 135 degrees about the z+ axis. This calculation is heading1  45 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 - 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
    
    # get the third point (bottom) (point3)
    p3x = pcx + vecnx * -1 * cushout
    p3y = pcy + vecny * -1 * cushout
    p3z = pcz - vecuz * radius - vecuz * cusharound
    
    # find rxryrz3
    # first rotation is 45 degrees about the y+ axis
    m1 = get_rotation_matrix_from_description(&quot;y&quot;, 1, 45 * pi / 180)
    # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    # get the fourth point (left) (point4)
    p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * cushout
    p4y = pcy - vecry * radius - vecry * cusharound + vecny * cushout
    p4z = pcz
    
    # find rxryrz4
    # first rotation is 90 degrees about the x+ axis
    m1 = get_rotation_matrix_from_description(&quot;x&quot;, 1, 90 * pi / 180)
    # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
    m2 = get_rotation_matrix_from_description(&quot;z&quot;, 1, heading1 + 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
    
    # return the points
    ret = struct(point1=point1, point2=point2, point3=point3, point4=point4)
    return ret
    
end
</cachedContents>
          <file>/programs/analyze_touchpoints.script</file>
        </Script>
        <Assignment valueSource="Expression">
          <variable name="path_pre" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="g"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="m"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="g"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="i"/>
            <ExpressionChar character="n"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="s"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="c"/>
            <ExpressionChar character="o"/>
            <ExpressionChar character="v"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="("/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph1" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="0"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph2" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="1"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph3" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="2"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph4" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="3"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph5" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="4"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph6" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="5"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <Assignment valueSource="Expression">
          <variable name="ph7" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionChar character="p"/>
            <ExpressionChar character="a"/>
            <ExpressionChar character="t"/>
            <ExpressionChar character="h"/>
            <ExpressionChar character="_"/>
            <ExpressionChar character="p"/>
            <ExpressionChar character="r"/>
            <ExpressionChar character="e"/>
            <ExpressionChar character="["/>
            <ExpressionChar character="6"/>
            <ExpressionChar character="]"/>
          </expression>
        </Assignment>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="ph2up" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="7"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="ph4up" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionChar character="p"/>
              <ExpressionChar character="a"/>
              <ExpressionChar character="t"/>
              <ExpressionChar character="h"/>
              <ExpressionChar character="_"/>
              <ExpressionChar character="p"/>
              <ExpressionChar character="r"/>
              <ExpressionChar character="e"/>
              <ExpressionChar character="["/>
              <ExpressionChar character="8"/>
              <ExpressionChar character="]"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[3]/variable"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_18" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.4527270065814086, -1.5335080666897793, 2.331465577553839, -0.7978622473340167, -0.6551352271038269, -4.318663923239541E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[4]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="p11" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[4]/variable"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_18" kinematicsFlags="-1">
              <motionParameters/>
              <position>
                <JointAngles angles="-1.4527270065814086, -1.5335080666897793, 2.331465577553839, -0.7978622473340167, -0.6551352271038269, -4.318663923239541E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[5]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Assignment" valueSource="Expression">
            <variable name="p13" prefersPersistentValue="false" favourite="false">
              <initializeExpression/>
            </variable>
            <expression>
              <ExpressionToken token="get_actual_tcp_pose"/>
              <ExpressionChar character="("/>
              <ExpressionChar character=")"/>
            </expression>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../SuppressedNode[4]/suppressedNode/variable"/>
              </Waypoint>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[5]/variable"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <gui.program.direction.MoveDirectionNode>
                <expression class="ExpressionBranch">
                  <ExpressionChar character="["/>
                  <ExpressionChar character="-"/>
                  <ExpressionChar character="1"/>
                  <ExpressionChar character=","/>
                  <ExpressionChar character="-"/>
                  <ExpressionChar character="1"/>
                  <ExpressionChar character="."/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character=","/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character="."/>
                  <ExpressionChar character="0"/>
                  <ExpressionChar character="]"/>
                </expression>
                <children>
                  <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
                </children>
              </gui.program.direction.MoveDirectionNode>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Assignment valueSource="Expression">
          <variable name="p12" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[5]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[3]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.9805802500330287, -1.776402843114571, 2.5402932176735167, -0.7636784153299869, 0.7364093853225739, -4.7636853491450637E-4"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.026244747181998207, -1.640187288787068, 2.4226740052170705, -0.6078304005137403, 2.4762680113591635, 0.13253734890858748"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702387017062684, 2.492185179387228, -1.7834822140135707, -0.33723670641054326, 1.8489984273910522"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_5" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.1354392210589808, -1.0039964479259034, 2.441021744404928, -2.875528474847311, -1.6043828169452112, 1.7329596281051636"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <SuppressedNode>
                <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_5" kinematicsFlags="1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.26738197008241826, -1.11244489372287, 2.793460194264547, -1.547202582736947, -4.00090462366213, 1.5620925426483154"/>
                    <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                      <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                      <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                      <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                      <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </suppressedNode>
              </SuppressedNode>
              <Waypoint type="Fixed" name="Waypoint_10" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.556256119404928, -1.0744255942157288, 2.9114087263690394, -1.7763501606383265, -4.185837809239523, 1.5288889408111572"/>
                  <TCPOffset pose="-0.0011568140153006695, -0.095603710023444, 0.2575950646467742, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[6]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode>
              <expression class="ExpressionBranch">
                <ExpressionChar character="["/>
                <ExpressionChar character="-"/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="1"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character=","/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="."/>
                <ExpressionChar character="0"/>
                <ExpressionChar character="]"/>
              </expression>
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable name="p21" prefersPersistentValue="false" favourite="false">
            <initializeExpression/>
          </variable>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[6]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Fixed" name="demo" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.009823083093752238, -1.0619960093747771, 1.6464553941979907, -0.40598839384763163, 2.538895015150203, 0.12566061136358356"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_8" kinematicsFlags="1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.01715496240946024, -1.494545279446406, 2.2672250278044364, -0.5958806326806094, 2.5316554411695993, 0.12363151404680206"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
            <Waypoint type="Fixed" name="Waypoint_10" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.02556298299657378, -1.7236099938373233, 2.481788294620727, -0.5833114718704184, 2.5232984892167174, 0.12127481998396572"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_11" kinematicsFlags="1">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.056348542397287815, -1.755951936284177, 2.687083281983292, -1.2239132866197675, 1.4020418579316969, 1.382286188783346"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Fixed" name="Waypoint_12" kinematicsFlags="3">
              <motionParameters/>
              <position>
                <JointAngles angles="-0.07847491298553244, -1.1667344858175497, 2.6853522647108843, -3.0537863367367724, -1.5263486092027065, 4.7222922273042975"/>
                <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                <Kinematics status="LINEARIZED" validChecksum="true">
                  <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                  <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                  <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                  <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                  <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                </Kinematics>
              </position>
              <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
            </Waypoint>
            <SuppressedNode>
              <suppressedNode class="Waypoint" type="Fixed" name="Waypoint_7" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-0.05711347261537725, -1.0985367459109803, 2.4025002161609095, -2.8401085338988246, -1.5255449453936976, 4.743709564208984"/>
                  <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                    <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                    <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                    <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                    <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </suppressedNode>
            </SuppressedNode>
          </children>
        </Move>
        <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[8]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[9]/variable"/>
            </Waypoint>
          </children>
        </Move>
        <Move motionType="MoveL" speed="0.02" acceleration="0.1" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <gui.program.direction.MoveDirectionNode selectedDirection="ZMinus">
              <children>
                <Until type="TOOL_CONTACT_DETECTION" allowActions="false" retraction="0.0" decelerationAcceleration="3.0" decelerationAngularAcceleration="34.90658503988659"/>
              </children>
            </gui.program.direction.MoveDirectionNode>
          </children>
        </Move>
        <Assignment valueSource="Expression">
          <variable reference="../../../../SubProgram[3]/children/Assignment[3]/variable"/>
          <expression>
            <ExpressionToken token="get_actual_tcp_pose"/>
            <ExpressionChar character="("/>
            <ExpressionChar character=")"/>
          </expression>
        </Assignment>
        <Move motionType="MoveL" speed="0.25" acceleration="1.2" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
          <feature class="GeomFeatureReference" reference="../../../../SpecialSequence/children/Folder/children/Move/feature"/>
          <children>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[9]/variable"/>
            </Waypoint>
            <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
              <motionParameters/>
              <variable reference="../../../../Assignment[8]/variable"/>
            </Waypoint>
            <Move motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
              <feature class="GeomFeatureReference" reference="../../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
              <children>
                <Waypoint type="Fixed" name="Waypoint_13" kinematicsFlags="-1">
                  <motionParameters/>
                  <position>
                    <JointAngles angles="-0.07847491298553244, -1.1667344858175497, 2.6853522647108843, -3.0537863367367724, -1.5263486092027065, 4.7222922273042975"/>
                    <TCPOffset pose="-0.0010317764122757048, -0.018062446645763904, 0.28523420717101033, 0.0, 0.0, 0.0"/>
                    <Kinematics status="LINEARIZED" validChecksum="true">
                      <deltaTheta value="-1.5962755862096445E-7, -0.4093566246988793, 7.293325569322967, -0.6007835331993939, -9.474458176003415E-7, -6.462621208922457E-7"/>
                      <a value="-7.133902600040746E-5, -0.7902806658119381, -0.6006938928654277, 6.0657740713218347E-5, -3.875010694163168E-5, 0.0"/>
                      <d value="0.2362715792740406, 604.4659451309549, 132.1165125128308, -736.3822386147384, 0.15926769713534844, 0.15400525677887147"/>
                      <alpha value="1.5702541303342112, -5.67239338460821E-4, 5.588615929674638E-4, 1.5717091054691175, -1.5699900472530834, 0.0"/>
                      <jointChecksum value="-1455923929, -1469580461, 686663807, -1452292534, -1484659803, -1456257139"/>
                    </Kinematics>
                  </position>
                  <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
                </Waypoint>
              </children>
            </Move>
          </children>
        </Move>
        <SuppressedNode>
          <suppressedNode class="Move" motionType="MoveJ" speed="1.0471975511965976" acceleration="1.3962634015954636" useActiveTCP="true" positionType="CartesianPose" optimoveEnabled="false" optiMoveSpeed="0.3" optiMoveAcceleration="0.09">
            <feature class="GeomFeatureReference" reference="../../../../../SpecialSequence/children/Folder/children/Move/feature"/>
            <children>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[9]/variable"/>
              </Waypoint>
              <Waypoint type="Variable" name="Variable" kinematicsFlags="-1">
                <motionParameters/>
                <variable reference="../../../../../Assignment[8]/variable"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_14" kinematicsFlags="-1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702451390079041, 2.492171827946798, -3.0669099293150843, 1.575993537902832, 2.355180025100708"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_4" kinematicsFlags="-1">
                <motionParameters/>
                <position>
                  <JointAngles angles="-1.350241486226217, -0.9702387017062684, 2.492185179387228, -1.7834822140135707, -0.33723670641054326, 1.8489984273910522"/>
                  <TCPOffset pose="0.0, 0.0, 0.246, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Waypoint type="Fixed" name="Waypoint_41" kinematicsFlags="3">
                <motionParameters/>
                <position>
                  <JointAngles angles="-3.4579578081714075, -2.0569120846190394, 2.3265841642962855, -0.22706885755572515, -0.1993349234210413, -0.10534984270204717"/>
                  <TCPOffset pose="0.0, -0.004, 0.284, 0.0, 0.0, 0.0"/>
                  <Kinematics status="LINEARIZED" validChecksum="true">
                    <deltaTheta value="-1.4899131651953954E-7, -0.5163156704236374, 5.626292263290917, 1.173211441187188, 7.813190464889264E-7, -4.300337819590494E-7"/>
                    <a value="-2.1311773410863242E-5, -0.748896650969478, -0.2818596402230846, -4.017768931271778E-5, -5.5248926104535545E-5, 0.0"/>
                    <d value="0.23622484809471647, -424.08293337258226, -1564.6687202774174, 1988.9516200232913, 0.15909435754571752, 0.1538726401599885"/>
                    <alpha value="1.5708436258517133, 0.001002489552312882, 3.374880014158008E-4, 1.571488190319432, -1.569996211212667, 0.0"/>
                    <jointChecksum value="-1252576034, -1269366749, 685297201, -1257350671, -1278514167, -1281348999"/>
                  </Kinematics>
                </position>
                <BaseToFeature pose="0.0, 0.0, 0.0, 0.0, 0.0, 0.0"/>
              </Waypoint>
              <Comment comment="above waypoint is home"/>
            </children>
          </suppressedNode>
        </SuppressedNode>
        <SafeHome positionOptionType="SPEED_AND_ACCELERATION" speed="1.0471975511965976" acceleration="1.3962634015954636" nextMotionTime="2.0"/>
      </children>
    </SubProgram>
    <Thread name="Thread_1" runOnlyOnce="true">
      <children>
        <Loop type="While" checkContinuously="false">
          <expression>
            <ExpressionToken token=" True "/>
          </expression>
          <children>
            <If type="If" checkContinuously="false">
              <expression>
                <ExpressionVariable>
                  <ProgramVariable reference="../../../../../../../../SubProgram[5]/children/Assignment/variable"/>
                </ExpressionVariable>
                <ExpressionChar character=""/>
                <ExpressionToken token=" True "/>
              </expression>
              <children>
                <Script type="Line">
                  <expression>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="i"/>
                    <ExpressionChar character="v"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="m"/>
                    <ExpressionChar character="o"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="("/>
                    <ExpressionChar character=")"/>
                  </expression>
                </Script>
                <Assignment valueSource="Expression">
                  <variable name="free_dr_already" prefersPersistentValue="false" favourite="false">
                    <initializeExpression/>
                  </variable>
                  <expression>
                    <ExpressionToken token=" True "/>
                  </expression>
                </Assignment>
              </children>
            </If>
            <If type="Else" checkContinuously="false">
              <expression/>
              <children>
                <If type="If" checkContinuously="false">
                  <expression>
                    <ExpressionChar character="f"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="_"/>
                    <ExpressionChar character="a"/>
                    <ExpressionChar character="l"/>
                    <ExpressionChar character="r"/>
                    <ExpressionChar character="e"/>
                    <ExpressionChar character="a"/>
                    <ExpressionChar character="d"/>
                    <ExpressionChar character="y"/>
                  </expression>
                  <children>
                    <Script type="Line">
                      <expression>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="n"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="_"/>
                        <ExpressionChar character="f"/>
                        <ExpressionChar character="r"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="r"/>
                        <ExpressionChar character="i"/>
                        <ExpressionChar character="v"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="_"/>
                        <ExpressionChar character="m"/>
                        <ExpressionChar character="o"/>
                        <ExpressionChar character="d"/>
                        <ExpressionChar character="e"/>
                        <ExpressionChar character="("/>
                        <ExpressionChar character=")"/>
                      </expression>
                    </Script>
                  </children>
                </If>
              </children>
            </If>
            <Script type="Line">
              <expression>
                <ExpressionChar character="s"/>
                <ExpressionChar character="y"/>
                <ExpressionChar character="n"/>
                <ExpressionChar character="c"/>
                <ExpressionChar character="("/>
                <ExpressionChar character=")"/>
              </expression>
            </Script>
          </children>
        </Loop>
      </children>
    </Thread>
    <SuppressedNode>
      <suppressedNode class="Thread" name="Thread_2" runOnlyOnce="false">
        <children>
          <Loop type="While" checkContinuously="false">
            <expression>
              <ExpressionToken token=" True "/>
            </expression>
            <children>
              <If type="If" checkContinuously="false">
                <expression>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="h"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="a"/>
                  <ExpressionChar character="d"/>
                  <ExpressionChar character="2"/>
                  <ExpressionChar character="t"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character="i"/>
                  <ExpressionChar character="g"/>
                  <ExpressionChar character="g"/>
                  <ExpressionChar character="e"/>
                  <ExpressionChar character="r"/>
                  <ExpressionChar character=""/>
                  <ExpressionToken token=" True "/>
                </expression>
                <children>
                  <Comment comment="do the dot extrude"/>
                  <Wait type="Sleep">
                    <waitTime>5.0</waitTime>
                  </Wait>
                  <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
                    <dataModel>
                      <data key="byte_array" value="true"/>
                      <data key="NODE_TITLE" value="Serial Bridge uR1"/>
                      <data key="Command" value="[252,82,49]"/>
                      <data key="QUERY" value="false"/>
                      <data key="OUTPUT_ENTRY" value="Static"/>
                      <Variable key="OUTPUT_VARIABLE">
                        <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                          <initializeExpression/>
                        </variable>
                      </Variable>
                    </dataModel>
                  </Contributed>
                  <Wait type="Sleep">
                    <waitTime>2.0</waitTime>
                  </Wait>
                  <Contributed strategyClass="com.wiretank.WireTank-Serial.WireTankSerial" strategyProgramNodeType="WireTank Serial" strategyURCapDeveloper="WireTank, LLC" strategyURCapName="WireTank Serial">
                    <dataModel>
                      <data key="QUERY" value="false"/>
                      <data key="NODE_TITLE" value="Serial Bridge uR0"/>
                      <data key="Command" value="[252,82,48]"/>
                      <data key="byte_array" value="true"/>
                      <data key="OUTPUT_ENTRY" value="Static"/>
                      <Variable key="OUTPUT_VARIABLE">
                        <variable name="HwResp" prefersPersistentValue="false" favourite="false">
                          <initializeExpression/>
                        </variable>
                      </Variable>
                    </dataModel>
                  </Contributed>
                  <Assignment valueSource="Expression">
                    <variable name="thread2trigger" prefersPersistentValue="false" favourite="false">
                      <initializeExpression/>
                    </variable>
                    <expression>
                      <ExpressionToken token=" False "/>
                    </expression>
                  </Assignment>
                </children>
              </If>
              <Script type="Line">
                <expression>
                  <ExpressionChar character="s"/>
                  <ExpressionChar character="y"/>
                  <ExpressionChar character="n"/>
                  <ExpressionChar character="c"/>
                  <ExpressionChar character="("/>
                  <ExpressionChar character=")"/>
                </expression>
              </Script>
            </children>
          </Loop>
        </children>
      </suppressedNode>
    </SuppressedNode>
  </children>
</URProgram>