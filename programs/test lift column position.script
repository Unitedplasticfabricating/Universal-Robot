def test_lift_column_position():
  global _hidden_verificationVariable=0
  step_count_a2416ea4_cf31_44d2_a405_df90891c5051 = 0.0
  thread Step_Counter_Thread_15f17497_b945_4186_aba7_8c005dbfed89():
    while (True):
      step_count_a2416ea4_cf31_44d2_a405_df90891c5051 = step_count_a2416ea4_cf31_44d2_a405_df90891c5051 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_15f17497_b945_4186_aba7_8c005dbfed89()
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_gravity([0.0, 0.0, 9.82])
  set_safety_mode_transition_hardness(1)
  set_target_payload(10.450000, [0.000000, -0.064000, 0.064000], [0.076889, 0.076889, 0.076889, 0.000000, 0.000000, 0.000000])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_tcp(p[0.00451,-0.328,0.10639,1.2092,-1.2092,1.2092])
  global Point_1=p[0.0,0.0,0.0,0.0,0.0,0.0]
  # begin: URCap Installation Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  def waitForResponse(expected_response_vention, cname_vention):
  response_vention = socket_read_string(cname_vention,timeout=15)
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  end
  def sendString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringNAck(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while(response_vention != expected_response_vention and response_vention != "nAck"):
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received",blocking=True)
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringWithTimeout(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=10)
  if(response_vention == "nAck"):
  popup("nAck received"+string_vention)
  end
  sleep(0.01)
  sync()
  end
  def pollString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(1)
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendVariable(var_vention, data_vention, expected_response_vention, cname_vention):
  socket_set_var(var_vention, data_vention, cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def intToString(integer_vention,cname_vention):
  stringFix=""
  multiplier_vention123=1
  if integer_vention<0:
  stringFix="-"
  multiplier_vention123=-1
  end
  socket_set_var("GetString",integer_vention*multiplier_vention123,cname_vention)
  string_vention=""
  while string_vention=="":
  sleep(0.01)
  string_vention=socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  string_vention=stringFix+string_vention
  return string_vention
  end
  string_vention=""
  isVentionMovementBusy = False
  isVentionParallelMovementSendingScript = False
  ventionThreadHandle = 1
  isVentionMovementBusyMachineMotion1 = False
  isVentionParallelMovementSendingScriptMachineMotion1 = False
  socket_vention = socket_open("192.168.3.52", 9999, "MachineMotion1")
  if socket_vention==False:
  popup("Check configuration, can't connect to MachineMotion")
  end
  waitForResponse("MachineMotion connection established", "MachineMotion1")
  sendString("isReady", "MachineMotion isReady = true", "MachineMotion1")
  sendStringWithTimeout("setURCapVersion2", "setURCapVersion loaded", "MachineMotion1")
  sendString("SET speed_v2 1000000", "Ack", "MachineMotion1")
  sendString("SET acceleration_v2 100000", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_microsteps_config 8", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_mechanical_gain_config_v2 150000.0", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_direction_config 1", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_type_config Custom Actuator ", "Ack", "MachineMotion1")
  sendString("de_axis_1_config_exec", "Ack", "MachineMotion1")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: WireTank Serial, 4.9.0, WireTank, LLC
  #   Type: WireTank Serial
  WTSerialBridge = rpc_factory("xmlrpc","http://127.0.0.1:40511/RPC2")
  # end: URCap Installation Node
  $ 2 "Robot Program"
  $ 3 "'test'"
  # 'test'
  $ 4 "var_1â‰”0.0"
  global var_1=0.0
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  $ 5 "MachineLogic Get Position"
  while isVentionMovementBusyMachineMotion1==True:
  sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
  isVentionMovementBusyMachineMotion1 = True
  socket_send_string("estop/status;", "MachineMotion1")
  temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
  while(temp_estop_var_vention=="estop/status true"):
  if temp_estop_var_vention=="estop/status true":
  sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
  end
  socket_send_string("estop/status;", "MachineMotion1")
  temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
  if temp_estop_var_vention=="estop/status true":
  popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
  end
  end
  else:
  popup("resource is being used already: MachineMotion1")
  halt
  end
  socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
  temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
  $ 6 "Popup"
  popup(str_cat("",var_1), "Message", False, False, blocking=True)
  $ 7 "Script: analyze_touchpoints.script"
  # this file creates the function for analyzing touchpoints
  # define pi
  pi = 3.1415926535
  
  # this is the main entry point for calculations.
  # it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
  # specifically for Down, Over, then Around (DOtA)
  # specifically for right-sided boxes (vertical weld on right side of edge)
  def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
      validity = check_validity_right(struct1, struct2)
      return struct2
  end
  
  # this is the main entry point for calculations.
  # it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
  # specifically for Down, Over, then Around (DOtA)
  # specifically for left-sided boxes (vertical weld on left side of edge)
  def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
      validity = check_validity_left(struct1, struct2)
      return struct2
  end
  
  # this is the main entry point for calculations, for Floor Corner Extended.
  # it takes in the 7 touchpoints, analyzes the shape of the box.
  # takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points
  # loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
  # returns the pathpoints
  # specifically for Down, Over, then Around (DOtA)
  # specifically for right-sided boxes (vertical weld on right side of edge)
  def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, tcp_pose_top):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, tcp_pose_top)
      validity = check_validity_right(struct1, struct2)
      return struct2
  end
  
  # this is the main entry point for calculations, for Floor Corner Extended.
  # it takes in the 7 touchpoints, analyzes the shape of the box.
  # takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points
  # loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
  # returns the pathpoints
  # specifically for Down, Over, then Around (DOtA)
  # specifically for left-sided boxes (vertical weld on left side of edge)
  def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, tcp_pose_top):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, tcp_pose_top)
      validity = check_validity_left(struct1, struct2)
      return struct2
  end
  
  # it takes 5 arguments as points
  # it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
  # specifically for Around then Up (AtU)
  def analyze_touchpoints(p11, p12, p21, p22, p3):
    # FIND THE INTERSECTION
    # comment get the z
    zcoord=p3[2]
  
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]
  
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
  
    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]
    l2p2x=p22[0]
    l2p2y=p22[1]
  
    # equate the second line in 2d space
    ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)
  
    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x
  
  
    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1
  
    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect
  
    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)
  
    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p2x - xintersect
    l2delyfull = l2p2y - yintersect
  
    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)
  
    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag
  
    # FIND THE FOUR POINTS ON THE LINES
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance = 8
    roundoverdistance = 0.05
    zup = .375
    # inches
    wd = welddistance * 25.4 / 1000
    rod = roundoverdistance * 25.4 / 1000
    zup = zup * 25.4 / 1000
  
    # now we have the unit vector. extend the weld distance from the intersection
    x = xintersect + l1delxunit * wd
    y = yintersect + l1delyunit * wd
    z = zcoord + zup
  
    point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now
  
    x = xintersect + l1delxunit * rod
    y = yintersect + l1delyunit * rod
  
    point2 = p[x,y,z,1.570796,0,0]
  
    # now we have the unit vector. extend the weld distance from the intersection
    x = xintersect + l2delxunit * wd
    y = yintersect + l2delyunit * wd
  
    point5 = p[x,y,z,0,-1.570796,0]
  
    x = xintersect + l2delxunit * rod
    y = yintersect + l2delyunit * rod
  
    point4 = p[x,y,z,0,-1.570796,0]
  
    #DEFINE APPROACH POINTS
    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
    pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
    pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
    pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
    headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (headingvector1 + headingvector2)/2
    # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
    heading1 = headingvector1 + pi/2
    heading3 = headingvector2 - pi/2
  
    #FIND POINT 3
    #see if we have to / can find point 3
    findpoint3 = True
    if roundoverdistance == 0:
      findpoint3 = False
    end
    if findpoint3:
      # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
      # the direction of movement is from pointintersect in the direction of heading2
      # how much movement though? this will depend on whether it is actually a 90 degree angle or not.
      # first, find the perpendicular lines through points 2 and 4
      perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
      perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
      # next, find the intersection of those two lines
      perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
      radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
      # find a vector the direction of heading2
      uvx = cos(heading2)
      uvy = sin(heading2)
      # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
      point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
      point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
    end
  
    #APPLY ACTUAL RXRYRZ TO POINTS
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
    pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
    point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
    point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
    rxryrz = convert_heading_to_axang(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    if findpoint3:
      point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
    else:
      point3 = point2
    end
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
    point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
    pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
    #find path2 (the part that goes up)
    four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
    path2r1 = four_vertical_points[0]
    path2r2 = four_vertical_points[1]
    path2l1 = four_vertical_points[2]
    path2l2 = four_vertical_points[3]
  
    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
    return ret
  end
  
  # it takes 5 arguments as points
  # it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
  def analyze_touchpoints_only(p11, p12, p21, p22, p3):
    # FIND THE INTERSECTION
    # comment get the z
    zcoord=p3[2]
  
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]
  
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
  
    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]
    l2p2x=p22[0]
    l2p2y=p22[1]
  
    # equate the second line in 2d space
    ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)
  
    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x
  
  
    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1
  
    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect
  
    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)
  
    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p2x - xintersect
    l2delyfull = l2p2y - yintersect
  
    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)
  
    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag
  
    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
    headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (headingvector1 + headingvector2)/2
    # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
    heading1 = headingvector1 + pi/2
    heading3 = headingvector2 - pi/2
  
    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for right, for non-extended
  def calculate_DOtA_points_right(struct1, listleans, chamferover):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l1delxunit * wd2
      y = y + l1delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * wd3
      y = pointintersect[1] + l2delyunit * wd3
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_5 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
  
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for left, for non-extended
  def calculate_DOtA_points_left(struct1, listleans, chamferover):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l2delxunit * wd2
      y = y + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * wd3
      y = pointintersect[1] + l1delyunit * wd3
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_5 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
      #point 3 will not have the correct rxryrz though because now the gun needs to be face up.
      rxryrz = convert_heading_to_axang_ccw(heading2)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for right, for extended
  def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      # welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      # wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      wd1 = tcp_pose_top[2] - pointintersect[2] - zup
  
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l1delxunit * wd2
      y = y + l1delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * wd3
      y = pointintersect[1] + l2delyunit * wd3
      point_5 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
  
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for left, for extended
  def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      # welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      # wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      wd1 = tcp_pose_top[2] - pointintersect[2] - zup
  
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l2delxunit * wd2
      y = y + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      # extend the weld distance from the intersection
      valid1 = True
      # start with the seed
      x = pointintersect[0] + l1delxunit * wd3
      y = pointintersect[1] + l1delyunit * wd3
      point_5 = p[x, y, z, rx, ry, rz]
      seed = p[x, y, z, rx, ry, rz]
      valid1 = get_inverse_kin_has_solution(seed)
      # define the increment
      increment = 1.0 # inches
      increment = increment * 25.4 / 1000 # meters
      while valid1 == True:
          wd3 = wd3 + increment
          x = pointintersect[0] + l1delxunit * wd3
          y = pointintersect[1] + l1delyunit * wd3
          seed = p[x, y, z, rx, ry, rz]
          valid1 = get_inverse_kin_has_solution(seed)
      end
      # move back 1 to get the highest valid wd3
      # move back 3 to get the third highest valid wd3
      wd3 = wd3 - (3.0 * increment)
      x = pointintersect[0] + l1delxunit * wd3
      y = pointintersect[1] + l1delyunit * wd3
      point_5 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
      #point 3 will not have the correct rxryrz though because now the gun needs to be face up
      rxryrz = convert_heading_to_axang_ccw(heading2)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # this function analyzes the vertical points
  # calculates the slope of the edge in question
  # specifically, for each inch up in the z direction, what is the change in x and change in y direction
  # returns a list of [nx, ny]
  def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
      # first, find the equations of the planes from the 6 points
      plane1 = findplane(p11, p12, p13)
      plane2 = findplane(p21, p22, p23)
      # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
      nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
      ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
      nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
      # normalize the vector so the z length is 1
      multiplier = 1 / nz
      nx = nx * multiplier
      ny = ny * multiplier
      nz = nz * multiplier # should become equal to 1
      ret = [nx, ny]
      return ret
  end
  
  # given 3 points, this finds the plane and its equation
  # rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
  def findplane(p11, p12, p13):
      # extract coordinates
      x1 = p11[0]
      y1 = p11[1]
      z1 = p11[2]
      x2 = p12[0]
      y2 = p12[1]
      z2 = p12[2]
      x3 = p13[0]
      y3 = p13[1]
      z3 = p13[2]
      # create vectors from the points
      v1x = x2-x1
      v1y = y2-y1
      v1z = z2-z1
      v2x = x3-x1
      v2y = y3-y1
      v2z = z3-z1
      #calculate the normal vector using the cross product
      nx = v1y*v2z - v1z*v2y # i component
      ny = v1z*v2x - v1x*v2z # j component
      nz = v1x*v2y - v1y*v2x # k component
      # calculate d in the plane equation
      d = -1 * (nx*x1 + ny*y1 + nz*z1)
      ret = [nx, ny, nz, d]
      return ret
  end
  
  # given a heading, (ccw from +x axis), find the mx+b slope
  # fails if exactly vertical
  def get_slope_from_heading(heading):
      return tan(heading)
  end
  
  
  
  # this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
  def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
    # find right side stuff
    # find the point in 3d space that is .375 up and .375 over
    x = pointintersect[0] + l1delxunit * offset
    y = pointintersect[1] + l1delyunit * offset
    z = pointintersect[2] + offset
    # find rxryrz
    rxryrz = convert_heading_to_axang_preheatup(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    path2r1 = p[x, y, z, rx, ry, rz]
    path2r2 = p[x, y, z + wd, rx, ry, rz]
  
    # find left side
    # find the point in 3d space that is .375 up and .375 over
    x = pointintersect[0] + l2delxunit * offset
    y = pointintersect[1] + l2delyunit * offset
    z = pointintersect[2] + offset
    # find rxryrz
    rxryrz = convert_heading_to_axang_preheatup(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    path2l1 = p[x, y, z, rx, ry, rz]
    path2l2 = p[x, y, z + wd, rx, ry, rz]
  
    ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
    return ret
  end
  
  # this function converts a unit vector to its heading angle ccw from x+ axis
  # takes uvx and uvy
  # returns heading in radians
  def convert_uv_to_heading(uvx, uvy):
    baseang = atan(uvy/uvx)
    if uvx < 0:
      ang = baseang + pi
    elif uvy < 0:
      ang = baseang + pi * 2
    else:
      ang = baseang
    end
    return ang
  end
  
  # this function finds the equation of a line, perpendicular to a given line, and going through a given point
  # takes 3 arguments: m (the original line's slope), x (point's x coord), y (point's y coord). the b of the original line is not needed
  # returns a list of [m,b] (the slope and intercept of the new line)
  def find_perpendicular_line(origm, x, y):
    m = (1/origm) * -1
    b = y - m*x
    ret = [m, b]
    return ret
  end
  
  # this function finds the intersection point between two lines in the xy plane
  # takes 4 arguments: m1, b1, m2, b2
  # returns a list of [x,y] (the point of intersection)
  def find_intersection(m1, b1, m2, b2):
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    x = (b2-b1) / (m1-m2)
    y = m1 * x + b1
    ret = [x, y]
    return ret
  end
  
  # this function finds the distance between 2 points in 3d space
  # it takes 6 arguments: x1, y1, z1, x2, y2, z2
  # it returns a distance
  def distance_between(x1, y1, z1, x2, y2, z2):
    distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
    dist = sqrt(distsquared)
    return dist
  end
  
  # this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
  # it returns a point as a list of coordinates
  def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
    xf = xi + uvx * delta
    yf = yi + uvy * delta
    zf = zi + uvz * delta
    ret = [xf, yf, zf]
    return ret
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the bottom side of the gun facing up.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang(heading):
   axisxraw = -1 * sin(heading)
   axisyraw = cos(heading) + 1
   axiszraw = sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatup(heading):
   axisxraw = -sin(heading) + 1
   axisyraw = cos(heading)
   axiszraw = cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatdown(heading):
   axisxraw = -sin(heading) - 1
   axisyraw = cos(heading)
   axiszraw = -cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_ccw(heading):
   axisxraw = -sin(heading)
   axisyraw = cos(heading) - 1
   axiszraw = -sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function takes two rotation matrices, and multiplies them together, returning one matrix.
  # all matrices are in the form of a list.
  # all matrix values have constant values (no variables)
  def multiply_matrix(matrix1, matrix2):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
      b11 = matrix2[0]
      b12 = matrix2[1]
      b13 = matrix2[2]
      b21 = matrix2[3]
      b22 = matrix2[4]
      b23 = matrix2[5]
      b31 = matrix2[6]
      b32 = matrix2[7]
      b33 = matrix2[8]
      #calculate c values
      c11 = a11*b11 + a12*b21 + a13*b31
      c12 = a11*b12 + a12*b22 + a13*b32
      c13 = a11*b13 + a12*b23 + a13*b33
      c21 = a21*b11 + a22*b21 + a23*b31
      c22 = a21*b12 + a22*b22 + a23*b32
      c23 = a21*b13 + a22*b23 + a23*b33
      c31 = a31*b11 + a32*b21 + a33*b31
      c32 = a31*b12 + a32*b22 + a33*b32
      c33 = a31*b13 + a32*b23 + a33*b33
      # return resulting matrix
      ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
      return ret
  end
  
  # this function converts a matrix to axis angle representations
  # this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
  # returns a list of [rx,ry,rz]
  def convert_matrix_to_axang(matrix1):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
  
      # First Half: find the angle
      # find the trace
      # using the formula: trace = a11 + a22 + a33
      trace = a11 + a22 + a33
      # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
      angle = acos((trace - 1.0)/2.0)
  
      # Second Half: calculate the rotation axis
      axisxraw = a32 - a23
      axisyraw = a13 - a31
      axiszraw = a21 - a12
      # normalize axis
      magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
      axisxunit = axisxraw / magnitude
      axisyunit = axisyraw / magnitude
      axiszunit = axiszraw / magnitude
  
      # combine axis and angle into rxryrz representation
      rxout = axisxunit * angle
      ryout = axisyunit * angle
      rzout = axiszunit * angle
      return [rxout, ryout, rzout]
  end
  
  # this function takes a rotation and calculates the corresponding rotation matrix
  # input is (axis, direction, angle in radians)
  # example is ("x", 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
  # returns a matrix (a list of 9 values)
  def get_rotation_matrix_from_description(axis, direction, angle):
      # get the angle
      a = angle * direction
      # get the axis
      if axis == "x" or axis == "X":
          matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
          return matrix
      end
      if axis == "y" or axis == "Y":
          matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
          return matrix
      end
      if axis == "z" or axis == "Z":
          matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
          return matrix
      end
      # bad
      popuptext = "Error in get_rotation_matrix_from_description. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Code Error",blocking=True)
      end
  end
  
  # this function is for getting the points along the path of the corner homing 45
  # point0 is the point where they touched
  def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
  
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.03 # first distance from init point
    d2 = 0.15 # second distance from init point
    d3 = 0.125 #vertical distance from first point
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
    ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
    # go back to ph1
    ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, 0] # approach point for under turn
    # moveL from ph1 to ph6
    ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, 0]
  
    # add the vertical touch points
    if pointtop[2] == 0:
      ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
      ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
    else:
      ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
      ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
    end
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
    is_robot_at_reachable_spot(point0, ret)
    return ret
  end
  
  # this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
  # if everything looks good, it continues.
  # if it detects a problem, it infinite loops a popup
  def is_robot_at_reachable_spot(point0, struct_touchpoints):
    # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z < -350)
    if point0[2] < -0.350:
      # bad
      popuptext = "Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
  
  
    # next, check whether the touchpoints are reachable
    structlength = 9
    i = 0
    allvalid = True
    listproblems = ""
    listnames = ["ph1", "ph2", "ph3", "ph4", "ph5", "ph6", "ph7", "ph2up", "ph4up"]
    while i < structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        allvalid = False
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
  
    if not allvalid:
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
  end
  
  # checks the validity of all points during a left weld
  def check_validity_left(struct1, struct2):
    #first, check whether robot is too close
    pointintersect = struct1[0]
    # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X > -1300)
    # if y < 0, then x < -1300. if y < 480, then y > (1300+x)*8. if y > 480, then y > (1235+x)*4 + 500
    toocloseleftweld = False
    if pointintersect[1] < 0:
      if pointintersect[0] > -1.300:
        toocloseleftweld = True
      end
    elif pointintersect[1] < 0.480:
      if pointintersect[1] < (1.300 + pointintersect[0])*8:
        toocloseleftweld = True
      end
    else:
      if pointintersect[1] < (1.235 + pointintersect[0])*4 + 0.500:
        toocloseleftweld = True
      end
    end
    if toocloseleftweld:
      # bad
      popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    #next, check whether all the points in the weldpath are valid
    structlength = 9
    i = 0
    allvalid = True
    listproblems = ""
    listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
    while i < structlength:
      curr = struct2[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        allvalid = False
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
  
    if not allvalid:
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    # check whether the path involves weird turns or joint limits. currently just checks the first position
    p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
    joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180
      difference = joint_curr - p_prev[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
  
    if not allGood:
      # display
      popuptext = "Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
  end
  
  # checks the validity of all points during a right weld
  def check_validity_right(struct1, struct2):
    # first, check whether the right pivot will bonk itself
    pointintersect = struct1[0]
    heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
    #first, check whether the heading is just too far offset
    # more than 15 degrees off of 45 is too much
    # normal heading is 216 degrees
    #201 degrees to 231 degrees
    heading1degrees = heading1 * 180 / pi
    if heading1degrees < 201 or heading1degrees > 231 :
      # then out of range
      popuptext = "Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=" + str_cat("",heading1degrees)
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    #TODO: add the checks for whether x is too close, given the heading
    # add checks for whether x is too close, given the heading
    # different equations for whether heading offset > 5 degrees or less (inc. negative)
    headingoffset = heading1degrees - 216
    if headingoffset < 5:
      # then calculate a and b
      a = 0.4584 + -0.02369 * headingoffset
      b = (-1151.4 + 13.83 * headingoffset) / 1000
      # check whether x > a*y+b
      if pointintersect[0] > a * pointintersect[1] + b:
        # bad
        popuptext = "Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. "
        # infinite loop
        while 1==1:
          popup(popuptext, title="Robot Positioning Warning",blocking=True)
        end
      end
    else:
      # headingoffset > 5 degrees
      if pointintersect[1] < 0:
        if pointintersect[0] > -1150.0 / 1000.0:
          #bad
          popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. "
          # infinite loop
          while 1==1:
            popup(popuptext, title="Robot Positioning Warning",blocking=True)
          end
        end
      else:
        # if x > .7736 y - 1101.9 then bad
        if pointintersect[0] > 0.7736 * pointintersect[1] - 1101.9 / 1000:
          popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. "
          # infinite loop
          while 1==1:
            popup(popuptext, title="Robot Positioning Warning",blocking=True)
          end
        end
      end
    end
  
    #next, check whether all the points in the weldpath are valid
    structlength = 9
    i = 0
    allvalid = True
    listproblems = ""
    listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
    while i < structlength:
      curr = struct2[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        allvalid = False
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
  
    if not allvalid:
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    # check whether the path involves weird turns or joint limits. currently just checks the first position
    p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
    joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180
      difference = joint_curr - p_prev[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
  
    if not allGood:
      # display
      popuptext = "Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  end
  
  # this function sends a signal to turn extrusion on
  def turn_extrusion_on():
    # flush the channel
    resp0 = send_serial_signal(["u", "r", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "R", "1"])
    # if resp <> "uR1"
    if resp1 != [252,82,49]:
      # turn off extrusion and heating. inform calvin
      resp2 = send_serial_signal(["u", "R", "0"])
      resp3 = send_serial_signal(["u", "H", "0"])
      popuptext = "Error code encountered while trying to start extrusion. Find Calvin. "
      while 1==1:
        popup(popuptext, title="Extrusion Error Code",blocking=True)
        popup(resp1, blocking=True)
      end
    end
  end
  
  # this function sends a signal and receives a response
  # signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
  def send_serial_signal(signal):
    signal2char = signal[1]
    signal3char = signal[2]
    listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
    resp1 = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", listsignal, True)
    return resp1
  end
  
  # this function converts a letter into its ascii number
  def get_corr_number(letter):
    if letter == "A":
      return 65
    elif letter == "H":
      return 72
    elif letter == "R":
      return 82
    elif letter == "M":
      return 77
    elif letter == "E":
      return 69
    elif letter == "a":
      return 97
    elif letter == "b":
      return 98
    elif letter == "h":
      return 104
    elif letter == "r":
      return 114
    elif letter == "s":
      return 115
    elif letter == "m":
      return 109
    elif letter == "0":
      return 48
    elif letter == "1":
      return 49
    elif letter == "2":
      return 50
    elif letter == "3":
      return 51
    elif letter == "4":
      return 52
    elif letter == "5":
      return 53
    elif letter == "6":
      return 54
    elif letter == "7":
      return 55
    elif letter == "8":
      return 56
    elif letter == "9":
      return 57
    elif letter == "?":
      return 63
    end
  end
  
  # this function checks whether the welder is in the ready state.
  # to be called at the beginning of Main Program
  def welder_state_ready():
    # flush the channel
    resp0 = send_serial_signal(["u", "s", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "s", "?"])
    # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
    if resp1 != [252,115,49]:
      popuptext = "Welder is not ready for extrusion. Follow the instructions to start heating welder. "
      while 1==1:
        popup(popuptext, title="Welder Not Ready",blocking=True)
      end
    end
  
  end
  
  def get_lift_column_height():
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    #$ 5 "MachineLogic Get Position"
    while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
        if temp_estop_var_vention=="estop/status true":
          sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
        end
        socket_send_string("estop/status;", "MachineMotion1")
        temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
        if temp_estop_var_vention=="estop/status true":
          popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
        end
      end
    else:
      popup("resource is being used already: MachineMotion1")
      halt
    end
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    global var_1 = temp_drive[1]
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
  end
  
  def get_lift_column_height_condensed():
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    ret = temp_drive[1]
    return ret
  end
  $ 8 "var_2â‰”get_lift_column_height_condensed()"
  global var_2=get_lift_column_height_condensed()
  $ 9 "Popup"
  popup(str_cat("",var_2), "Message", False, False, blocking=True)
end
