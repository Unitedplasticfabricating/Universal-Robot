# this file creates the function for analyzing touchpoints

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    validity = check_validity_right(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations.
# it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
    validity = check_validity_left(struct1, struct2)
    return struct2
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended, but on a step so tilt back and ride both of the two exits.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for right-sided boxes (vertical weld on right side of edge)
# the only difference is adding the extra points in struct2, and passing them in check validity
def main_calculate_right_step_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_right_step_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_right(struct1, struct2)
    return struct3
end

# this is the main entry point for calculations, for Floor Corner Extended, but on a step so tilt back and ride both of the two exits.
# it takes in the 7 touchpoints, analyzes the shape of the box. 
# takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points 
# loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
# returns the pathpoints
# specifically for Down, Over, then Around (DOtA)
# specifically for left-sided boxes (vertical weld on left side of edge)
def main_calculate_left_step_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    struct2 = calculate_DOtA_points_left_step_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    struct3 = check_validity_left(struct1, struct2)
    return struct3
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
# specifically for Around then Up (AtU)
def analyze_touchpoints(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1

  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  # FIND THE FOUR POINTS ON THE LINES
  # find locations 8 inches away from  intersect point
  # CONST
  welddistance = 8
  roundoverdistance = 0.05
  zup = .375
  # inches
  wd = welddistance * 25.4 / 1000
  rod = roundoverdistance * 25.4 / 1000
  zup = zup * 25.4 / 1000

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l1delxunit * wd
  y = yintersect + l1delyunit * wd
  z = zcoord + zup

  point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now

  x = xintersect + l1delxunit * rod
  y = yintersect + l1delyunit * rod

  point2 = p[x,y,z,1.570796,0,0]

  # now we have the unit vector. extend the weld distance from the intersection
  x = xintersect + l2delxunit * wd
  y = yintersect + l2delyunit * wd

  point5 = p[x,y,z,0,-1.570796,0]

  x = xintersect + l2delxunit * rod
  y = yintersect + l2delyunit * rod

  point4 = p[x,y,z,0,-1.570796,0]

  #DEFINE APPROACH POINTS
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
  pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
  pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #FIND POINT 3
  #see if we have to / can find point 3
  findpoint3 = True
  if roundoverdistance == 0:
    findpoint3 = False
  end
  if findpoint3:
    # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
    # the direction of movement is from pointintersect in the direction of heading2
    # how much movement though? this will depend on whether it is actually a 90 degree angle or not. 
    # first, find the perpendicular lines through points 2 and 4
    perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
    perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
    # next, find the intersection of those two lines
    perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
    radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
    # find a vector the direction of heading2
    uvx = cos(heading2)
    uvy = sin(heading2)
    # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
    point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
    point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
  end
  
  #APPLY ACTUAL RXRYRZ TO POINTS
  # convert the headings to rxryrz and insert those values into the relevant points
  rxryrz = convert_heading_to_axang(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
  pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
  point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
  point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
  rxryrz = convert_heading_to_axang(heading2)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  if findpoint3:
    point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
  else:
    point3 = point2
  end
  rxryrz = convert_heading_to_axang(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
  point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
  pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
  #find path2 (the part that goes up)
  four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
  path2r1 = four_vertical_points[0]
  path2r2 = four_vertical_points[1]
  path2l1 = four_vertical_points[2]
  path2l2 = four_vertical_points[3]
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret
end

# this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
# used in original analyze_touchpoints() function
def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
  # find right side stuff
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l1delxunit * offset
  y = pointintersect[1] + l1delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading1)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2r1 = p[x, y, z, rx, ry, rz]
  path2r2 = p[x, y, z + wd, rx, ry, rz]
  
  # find left side 
  # find the point in 3d space that is .375 up and .375 over
  x = pointintersect[0] + l2delxunit * offset
  y = pointintersect[1] + l2delyunit * offset
  z = pointintersect[2] + offset
  # find rxryrz
  rxryrz = convert_heading_to_axang_preheatup(heading3)
  rx = rxryrz[0]
  ry = rxryrz[1]
  rz = rxryrz[2]
  path2l1 = p[x, y, z, rx, ry, rz]
  path2l2 = p[x, y, z + wd, rx, ry, rz]
  
  ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
  return ret  
end

# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
def analyze_touchpoints_only(p11, p12, p21, p22, p3):
  # FIND THE INTERSECTION
  # comment get the z
  zcoord=p3[2]

  # get the raw points from the first line
  l1p1x=p11[0]
  l1p1y=p11[1]
  l1p2x=p12[0]
  l1p2y=p12[1]

  # equate the first line in 2d space
  ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

  # b = y - mx
  bl1 = l1p1y - ml1 * l1p1x

  # get the raw points from the second line
  l2p1x=p21[0]
  l2p1y=p21[1]
  l2p2x=p22[0]
  l2p2y=p22[1]

  # equate the second line in 2d space
  ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)

  # b = y - mx
  bl2 = l2p1y - ml2 * l2p1x


  # find the intersection of the two lines
  # m1x+b1 = m2x+b2
  # m1x - m2x = b2 - b1
  # x = (b2-b1) / (m1-m2)
  xintersect = (bl2-bl1) / (ml1-ml2)
  yintersect = ml1 * xintersect + bl1
  
  pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
  #FIND THE VECTORS
  #define a vector from the intersection to the second point on the first line
  l1delxfull = l1p2x - xintersect
  l1delyfull = l1p2y - yintersect

  l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)

  l1delxunit = l1delxfull / l1delmag
  l1delyunit = l1delyfull / l1delmag
  
  #define a vector from the intersection to the second point on the second line
  l2delxfull = l2p2x - xintersect
  l2delyfull = l2p2y - yintersect

  l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)

  l2delxunit = l2delxfull / l2delmag
  l2delyunit = l2delyfull / l2delmag
  
  #FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
  headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
  # find halfway heading
  heading2 = (headingvector1 + headingvector2)/2
  # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
  heading1 = headingvector1 + pi/2
  heading3 = headingvector2 - pi/2
  
  #RETURN STRUCT
  ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
  return ret
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for non-extended
def calculate_DOtA_points_right(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for non-extended
def calculate_DOtA_points_left(struct1, listleans, chamferover):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # vertical weld distance
    welddistance2 = 6 # first path second leg
    welddistance3 = 8 # second path second leg
    zup = .375
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = zup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_5 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up. 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 5 # first path second leg
    welddistance3 = 5 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 5 # first path second leg
    welddistance3 = 5 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for right, for extended
def calculate_DOtA_points_right_step_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 3.5 # first path second leg
    welddistance3 = 4.0 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l1delxunit * wd2
    y = y + l1delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    # in order to find the tilt back and ride points like the floor straight, i first need to calculate the rxryrz of the tilt back
    # and i also need to calculate the v3 and v4 unit vectors. v3 points parallel with the path. v4 points perpendicular, out from box
    
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * chamferovermm
    y = pointintersect[1] + l1delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]

    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]

    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * wd3
    y = pointintersect[1] + l2delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    atret5 = atret[5]
    point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
    
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# given a struct from analyze_touchpoints_only(), calculate the points 
# for left, for extended
def calculate_DOtA_points_left_step_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    # welddistance1 = 8 # vertical weld distance
    welddistance2 = 5 # first path second leg
    welddistance3 = 5 # second path second leg
    
    # inches
    # wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    zup = chamferup * 25.4 / 1000
    chamferovermm =  chamferover * 25.4 / 1000
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    wd1 = tcp_pose_top[2] - pointintersect[2] - zup 
    
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    z = pointintersect[2] + zup
    
    #apply actual rxryrz to points
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
    point2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    point4 = p[x, y, z, rx, ry, rz]
    x = x + l2delxunit * wd2
    y = y + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l2delxunit * chamferovermm
    y = pointintersect[1] + l2delyunit * chamferovermm
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_1 = p[x, y, z, rx, ry, rz]
    
    x = pointintersect[0] + l2delxunit * rod
    y = pointintersect[1] + l2delyunit * rod
    point_2 = p[x, y, z, rx, ry, rz]
    
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang_ccw(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    x = pointintersect[0] + l1delxunit * rod
    y = pointintersect[1] + l1delyunit * rod
    point_4 = p[x, y, z, rx, ry, rz]
    
    # now we have the unit vector. extend the weld distance from the intersection
    x = pointintersect[0] + l1delxunit * wd3
    y = pointintersect[1] + l1delyunit * wd3
    point_5 = p[x, y, z, rx, ry, rz]
    
    #FIND POINT 3
    # by calling analyze_touchpoints()
    atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
    point_3 = atret[5]
    #point 3 will not have the correct rxryrz though because now the gun needs to be face up 
    rxryrz = convert_heading_to_axang_ccw(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
    return struct2
end

# this function analyzes the vertical points
# calculates the slope of the edge in question
# specifically, for each inch up in the z direction, what is the change in x and change in y direction
# returns a list of [nx, ny]
def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
    # first, find the equations of the planes from the 6 points
    plane1 = findplane(p11, p12, p13)
    plane2 = findplane(p21, p22, p23)
    # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
    nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
    ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
    nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
    # normalize the vector so the z length is 1
    multiplier = 1 / nz
    nx = nx * multiplier
    ny = ny * multiplier
    nz = nz * multiplier # should become equal to 1
    ret = [nx, ny]
    return ret
end

# this function is for getting the points along the path of the corner homing 45
# point0 is the point where they touched
def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
  p0x = point0[0]
  p0y = point0[1]
  p0z = point0[2]
  p0rx = point0[3]
  p0ry = point0[4]
  p0rz = point0[5]
  
  #constants
  #distances of how far away from point the touchpoints are
  d0 = 0.10 # how far from the box to retreat and approach
  d1 = 0.06 # first distance from init point
  d2 = 0.15 # second distance from init point
  d3 = 0.125 #vertical distance from first point
  sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
  ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
  ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
  ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
  ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
  ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
  # go back to ph1
  ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, pi] # approach point for under turn
  # moveL from ph1 to ph6
  ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, pi]
  
  # add the vertical touch points
  if pointtop[2] == 0:
    ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
  elif pointtop[2] > p0z + 0.914: # 0.914m = 36 inches
    ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
  else:
    ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
    ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
  end
  ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
  is_robot_at_reachable_spot(point0, ret)
  return ret
end

def get_corner_homing_45_pathpoints_cover(point0):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
    
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.04 # first distance from init point
    d2 = 0.15 # second distance from init point
    d4 = 0.06 # top distance from init point - larger to avoid large chamfers
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
    
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
    
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
    #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
    
    # approach point for top
    ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner. 
    
    # top point
    ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
    is_robot_at_reachable_spot(point0, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_cover(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points (the rxryrz are given in pretend_welder_top coordinates. they match pure rotations of 90 degrees)
    ph1 = p[lpx + d0, lpy, lpz - d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz - d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d2, lpy, lpz + d0, 2.221, -2.221, 0] # left top approach
    ph4 = p[rpx - d2, rpy, rpz + d0, 2.221, -2.221, 0] # right top approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_floor(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points
    ph1 = p[lpx + d0, lpy, lpz + d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz + d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d1, lpy, lpz - d0, 0, 0, 0] # left bottom approach
    ph4 = p[rpx - d1, rpy, rpz - d0, 0, 0, 0] # right bottom approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret, 4)
    return ret
end

# this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
# if everything looks good, it continues.
# if it detects a problem, it infinite loops a popup
def is_robot_at_reachable_spot(point0, struct_touchpoints, structlength = 9):
  # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z < -400)
  lc_height = get_lift_column_height_condensed()
  # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
  totalheight = 1.04775 + lc_height + point0[2]
  if totalheight < 1.04775 - 0.400:
    # bad
    popuptext = "Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. "
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
  
  
  
  # next, check whether the touchpoints are reachable
  allvalid = check_structofpoints_validity(struct_touchpoints)
  if not allvalid:
      
    # then unreachable
    # generate message
    listproblems = ""
    listnames = ["ph1", "ph2", "ph3", "ph4", "ph5", "ph6", "ph7", "ph2up", "ph4up"]
    i = 0
    # structlength = 9 # used to be a declare statement here. now it is a parameter. floor corner has 9. other features have less
    while i < structlength:
      curr = struct_touchpoints[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        listproblems = listproblems + listnames[i]
      end
      i = i + 1
    end
    # display
    popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
  
end

# checks the validity of all points during a left weld
# takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
def check_validity_left(struct1, struct2):
  #first, check whether robot is too close
  pointintersect = struct1[0]
  # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X > -1300)
  # if y < 0, then x < -1300. if y < 480, then y > (1300+x)*8. if y > 480, then y > (1235+x)*4 + 500
  toocloseleftweld = False
  if pointintersect[1] < 0:
    if pointintersect[0] > -1.300:
      toocloseleftweld = True
    end
  elif pointintersect[1] < 0.480:
    if pointintersect[1] < (1.300 + pointintersect[0])*8:
      toocloseleftweld = True
    end
  else:
    if pointintersect[1] < (1.235 + pointintersect[0])*4 + 0.500:
      toocloseleftweld = True
    end
  end
  if toocloseleftweld:
    # bad
    popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. "
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = ""
  listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
  while i < structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      if i > 0:
        allvalid = False
        listproblems = listproblems + listnames[i]
      end
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. currently just checks the first position
  p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i < structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr > degreesmax or joint_curr < degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference > maxdifference or difference * -1 > maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    # call lift column extend function
    struct2 = floor_corner_lift_column_extend_left(struct2)
    
  end
  
  # return struct2 back
  return struct2
end

# checks the validity of all points during a right weld
def check_validity_right(struct1, struct2):
  # first, check whether the right pivot will bonk itself
  pointintersect = struct1[0]
  heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
  #first, check whether the heading is just too far offset
  # more than 15 degrees off of 45 is too much
  # normal heading is 216 degrees
  #201 degrees to 231 degrees
  heading1degrees = heading1 * 180 / pi
  if heading1degrees < 201 or heading1degrees > 231 :
    # then out of range
    popuptext = "Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=" + str_cat("",heading1degrees)
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
    
  #TODO: add the checks for whether x is too close, given the heading
  # add checks for whether x is too close, given the heading
  # different equations for whether heading offset > 5 degrees or less (inc. negative)
  headingoffset = heading1degrees - 216
  if headingoffset < 5:
    # then calculate a and b
    a = 0.4584 + -0.02369 * headingoffset
    b = (-1151.4 + 13.83 * headingoffset) / 1000
    # check whether x > a*y+b
    if pointintersect[0] > a * pointintersect[1] + b:
      # bad
      popuptext = "Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. " 
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  else:
    # headingoffset > 5 degrees
    if pointintersect[1] < 0:
      if pointintersect[0] > -1150.0 / 1000.0:
        #bad
        popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. " 
        # infinite loop
        while 1==1:
          popup(popuptext, title="Robot Positioning Warning",blocking=True)
        end
      end
    else:
      # if x > .7736 y - 1101.9 then bad
      if pointintersect[0] > 0.7736 * pointintersect[1] - 1101.9 / 1000:
        popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. " 
        # infinite loop
        while 1==1:
          popup(popuptext, title="Robot Positioning Warning",blocking=True)
        end
      end
    end
  end
  
  #next, check whether all the points in the weldpath are valid
  structlength = 9
  i = 0
  allvalid = True
  listproblems = ""
  listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
  while i < structlength:
    curr = struct2[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      if i > 0:
        allvalid = False
        listproblems = listproblems + listnames[i]
      end
    end
    i = i + 1
  end
  
  if not allvalid:
    # display
    popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  end
  
  # check whether the path involves weird turns or joint limits. first position
  p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
  joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
  allGood = True
  i = 0
  structlength = 6
  while i < structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr > degreesmax or joint_curr < degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference > maxdifference or difference * -1 > maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_lift_column_extend_right(struct2)
  end
  
  # check whether the path involves weird turns or joint limits. final position (end of leg 3)
  joints_raa4 = [-0.8909156958209437, -1.3431089532426377, 2.273750130330221, 0.7266384798237304, 1.5611975193023682, 1.8127720355987549]
  joints_p_3 = get_inverse_kin(struct2[6], joints_raa4) # struct2[6] is p_3
  joints_p_4 = get_inverse_kin(struct2[7], joints_p_3) # struct2[7] is p_4
  joints_p_5 = get_inverse_kin(struct2[8], joints_p_4) # struct2[8] is p_5
  joints_1 = joints_p_5
  p_prev = joints_p_4
  allGood = True
  i = 0
  structlength = 6
  while i < structlength:
    joint_curr = joints_1[i]
    # check for anything that exceeds joint limits
    degreesmax = 360 * pi / 180 
    if joint_curr > degreesmax or joint_curr < degreesmax * -1:
      allGood = False
    end
    # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
    maxdifference = 150 * pi / 180 
    difference = joint_curr - p_prev[i]
    if difference > maxdifference or difference * -1 > maxdifference:
      allGood = False
    end
    i = i + 1
  end
  
  if not allGood:
    struct2 = floor_corner_right_p_3_reduce(struct2)
  end
  
  # return struct2 back
  return struct2
end

def floor_corner_lift_column_extend_right(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2.0 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
    testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
  end
  
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
  liftcolumnzneeded = liftColumnHeightTest
  ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
  return ret
  
end

# this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
# this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable. 
# it determines the height that the lift column needs to raise to make the first point reachable
# it then checks whether that height will allow the other points to be reachable
# if its all good, it sets the global variable liftcolumnzneeded, modifies struct2's points, and returns struct2
# if its not all good, then it displays an error message popup. 
def floor_corner_lift_column_extend_left(struct2):
  # we know that p1 cannot be accessed without a twist 
  # calculate the height needed to get to p1
  liftcolumnincrement = 2 # mm
  enoughHeightAdded = False
  liftColumnHeightTest = 0
  while not enoughHeightAdded:
    liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
    # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
    # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
    # get the modified point:
    origp1 = struct2[0]
    testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
    enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
  end
  
  
  # check whether the other 3 points are valid
  valid = True
  # get the modified point
  origp2 = struct2[1]
  testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
  # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
  # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
  valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
  # get the modified point
  origp4 = struct2[2]
  testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
  # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
  # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
  valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
  # get the modified point
  origp5 = struct2[3]
  testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
  # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
  valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
  if not valid:
    # display
    popuptext = "Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. "
    # infinite loop
    while 1==1:
      popup(popuptext, title="Robot Positioning Warning",blocking=True)
    end
  else:
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  end
end

# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
  
end

def floor_corner_right_p_3_reduce(struct2, orig_joints):
  # we know that p_5 cannot be accessed without a twist 
  # calculate the distance p_5 needs to be changed (in the direction of p_4)
  
  #calculate unit vector from p_5 towards p_4
  point_4 = struct2[7]
  point_5 = struct2[8]
  vecx = point_4[0] - point_5[0]
  vecy = point_4[1] - point_5[1]
  vecz = point_4[2] - point_5[2]
  mag = sqrt(vecx*vecx + vecy*vecy + vecz*vecz)
  uvx = vecx / mag
  uvy = vecy / mag
  uvz = vecz / mag
  
  moveincrement = 2.0 # mm
  enoughMoveAdded = False
  movement = 0
  
  while not enoughMoveAdded:
    movement = movement + moveincrement
    # set the orig_joints for p_4. p1 was calculated and passed into this function
    # get the modified point:
    testp_5 = p[point_5[0] + uvx*movement, point_5[1] + uvy*movement, point_5[2] + uvz*movement, point_5[3], point_5[4], point_5[5]]
    enoughMoveAdded = can_pose_be_reached_without_twist(testp_5, orig_joints)
  end
  
  ret = struct(point1=struct2[0],point2=struct2[1],point4=struct2[2],point5=struct2[3],point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=testp_5)
  return ret
end

