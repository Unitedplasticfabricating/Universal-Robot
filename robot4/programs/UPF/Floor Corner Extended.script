def Floor_Corner_Extended():
  global _hidden_verificationVariable=0
  set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_target_payload(10.800000, [-0.001000, -0.053000, 0.068000], [0.081228, 0.081228, 0.081228, 0.000000, 0.000000, 0.000000])
  global robot_number=4
  # begin: URCap Installation Node
  #   Source: UR Connect, 1.13.79, Universal Robots
  #   Type: UR Connect
  myurRPC = rpc_factory("xmlrpc","http://127.0.0.1:40474")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  def waitForResponse(expected_response_vention, cname_vention):
  response_vention = socket_read_string(cname_vention,timeout=15)
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  end
  def sendString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringNAck(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while(response_vention != expected_response_vention and response_vention != "nAck"):
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received",blocking=True)
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringWithTimeout(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=10)
  if(response_vention == "nAck"):
  popup("nAck received"+string_vention)
  end
  sleep(0.01)
  sync()
  end
  def pollString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(1)
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendVariable(var_vention, data_vention, expected_response_vention, cname_vention):
  socket_set_var(var_vention, data_vention, cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def intToString(integer_vention,cname_vention):
  stringFix=""
  multiplier_vention123=1
  if integer_vention<0:
  stringFix="-"
  multiplier_vention123=-1
  end
  socket_set_var("GetString",integer_vention*multiplier_vention123,cname_vention)
  string_vention=""
  while string_vention=="":
  sleep(0.01)
  string_vention=socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  string_vention=stringFix+string_vention
  return string_vention
  end
  string_vention=""
  isVentionMovementBusy = False
  isVentionParallelMovementSendingScript = False
  ventionThreadHandle = 1
  isVentionMovementBusyMachineMotion1 = False
  isVentionParallelMovementSendingScriptMachineMotion1 = False
  socket_vention = socket_open("192.168.3.52", 9999, "MachineMotion1")
  if socket_vention==False:
  popup("Check configuration, can't connect to MachineMotion")
  end
  waitForResponse("MachineMotion connection established", "MachineMotion1")
  sendString("isReady", "MachineMotion isReady = true", "MachineMotion1")
  sendStringWithTimeout("setURCapVersion2", "setURCapVersion loaded", "MachineMotion1")
  sendString("SET speed_v2 1000000", "Ack", "MachineMotion1")
  sendString("SET acceleration_v2 100000", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_microsteps_config 8", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_mechanical_gain_config_v2 150000.0", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_direction_config 1", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_type_config Custom Actuator ", "Ack", "MachineMotion1")
  sendString("de_axis_1_config_exec", "Ack", "MachineMotion1")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: WireTank Serial, 4.9.0, WireTank, LLC
  #   Type: WireTank Serial
  WTSerialBridge = rpc_factory("xmlrpc","http://127.0.0.1:40511/RPC2")
  # end: URCap Installation Node
  step_count_7e362d8d_4085_4301_8c01_995a02cddc0d = 0.0
  thread Step_Counter_Thread_66588e56_dc3d_406e_b1d0_3ab32d779333():
    while (True):
      step_count_7e362d8d_4085_4301_8c01_995a02cddc0d = step_count_7e362d8d_4085_4301_8c01_995a02cddc0d + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_66588e56_dc3d_406e_b1d0_3ab32d779333()
  global free_dr_already=  False  
  global freedrive_m_var=  False  
  global Waypoint_76_p=p[.886939072471, .356263001241, .442999104957, 2.316306590719, 2.057646408592, .074101958719]
  global Waypoint_76_q=[-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966]
  global Waypoint_50_p=p[-.568711442653, .230601791901, .220208834751, -1.519093932087, -.535128035721, .573965472012]
  global Waypoint_50_q=[-0.021522347127095998, -1.2794721287539979, 2.4323821703540247, 5.090870934515753, -2.2996109167682093, 1.533644199371338]
  global Waypoint_51_p=p[-.689649894186, .139001107022, .230693120258, -.852023156701, -1.645963115617, 1.645984943001]
  global Waypoint_51_q=[-1.1454814116107386, -1.5427037247321387, 2.8454700152026575, 4.979047852545538, -4.902958456669943, 1.5718834400177002]
  global Waypoint_52_p=p[-.160992057407, .970528182050, .722037363514, -.554955923310, .106486629259, .328544950173]
  global Waypoint_52_q=[-1.2978580633746546, -1.3217003357461472, 2.2583277861224573, 3.7025129038044433, -2.952825371419088, 0.9627944231033325]
  global Waypoint_53_p=p[-.157624488365, .513351401913, .815670293526, -.672704566373, -1.852329693545, -.055423312366]
  global Waypoint_53_q=[-2.7676661650287073, -1.8206430874266566, 2.312763277684347, 1.0122546392628173, -1.0765226523028772, -0.8102834860431116]
  global Waypoint_54_p=p[-.308528116178, .606080777007, .242371251996, -2.133736658076, .349438277129, 2.130953356703]
  global Waypoint_54_q=[-1.9617512861834925, -1.2994225782207032, 2.207935158406393, 0.745708628291748, 1.5955500602722168, 1.41863214969635]
  global Waypoint_65_p=p[-.850299549699, -.229060500451, .580194265918, -.066683564301, -1.566406749139, -.045536147896]
  global Waypoint_65_q=[0.11527767777442932, -1.206728772526123, 2.660132948552267, 3.2525827127644042, -4.69939905801882, -0.18521625200380498]
  global Waypoint_55_p=p[-.850295942693, .369353811615, .580190947871, -.066690142153, -1.566409865149, -.045506050424]
  global Waypoint_55_q=[-0.89636737505068, -1.198587493305542, 2.6061368624316614, 3.3119169908710937, -4.700617257748739, 0.826545238494873]
  global Waypoint_59_p=p[-.689650832419, .138973473550, .230700469426, -.851985360280, -1.645991124348, 1.645990580233]
  global Waypoint_59_q=[-1.1454528013812464, -1.5427289356342335, 2.8454795519458216, 4.979044186859884, -4.902960960065023, 1.5718833208084106]
  global Waypoint_71_p=p[-.289684660393, .534258475721, .757199031184, -.295236718653, -.653013693815, .389426431276]
  global Waypoint_71_q=[-1.3941848913775843, -1.6550847492613734, 2.7336130777942103, 4.156678839320801, -3.798194471989767, 1.7310842275619507]
  global Waypoint_58_p=p[.191120239889, .567518478899, .815512910186, -.135765364935, .396070873472, .208834263225]
  global Waypoint_58_q=[-1.651280705128805, -1.7712346516051234, 2.617981735860006, 3.3066598612019042, -2.656208101903097, 0.8563313484191895]
  global Waypoint_56_p=p[-.254568281661, .502958752129, 1.135400507516, -.261908057482, -.749714619963, 1.349050618455]
  global Waypoint_56_q=[-2.0344861189471644, -1.9012485943236292, 2.469647232686178, 2.2012061315723876, -1.1677187124835413, -0.5094392935382288]
  global Waypoint_57_p=p[-.009221327687, .593713365169, .505808930157, -1.424394189587, -2.344106819810, -.527597949261]
  global Waypoint_57_q=[-2.920837704335348, -1.9932075939574183, 2.3856611887561243, 0.6815890508839111, -0.5688460508929651, -1.1506975332843226]
  global Waypoint_67_p=p[-.339169194335, .114271165560, .051007401747, -.434162127311, 1.872717119498, -1.885153895998]
  global Waypoint_67_q=[-1.410516087208883, -0.9778240484050293, 2.47756010690798, -1.72361483196401, -0.3956816832171839, 1.808600902557373]
  global Waypoint_69_p=p[-.760826542313, -.049762698068, .082649581767, -1.026233921905, -1.612699318499, 1.547123897415]
  global Waypoint_69_q=[-0.22154647508730108, -1.118469015961029, 2.7561236063586634, -1.5568565337783475, -3.851987902318136, 1.559481143951416]
  global Waypoint_70_p=p[-.154414768496, .636923137577, .016979120256, -.302753655748, 1.486961848367, .122240024639]
  global Waypoint_70_q=[-1.1281922499286097, -1.0678585332683106, 2.4290812651263636, -2.7994214497008265, -1.6034835020648401, 1.7401196956634521]
  global Waypoint_49_p=p[.397354147848, .356263001249, .319808682466, 2.316306590727, 2.057646408591, .074101958728]
  global Waypoint_49_q=[-3.4579480330096644, -2.0568953953185023, 2.3266006151782435, -0.2270372670939942, -0.1993797461139124, -0.10534602800478154]
  global Waypoint_75_p=p[.886939072471, .356263001241, .442999104957, 2.316306590719, 2.057646408592, .074101958719]
  global Waypoint_75_q=[-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966]
  global Waypoint_46_p=p[.897631799353, .353934909904, .354805178378, 2.318109555057, 2.056931948624, .061383861333]
  global Waypoint_46_q=[-3.2637236754046843, -1.174605057840683, 1.6528332869159141, 1.0000695425220945, -0.0017340818988245132, -1.5358897417550086]
  global Waypoint_20_p=p[.833090611797, .298095916052, .522915034559, -2.069934341898, -1.817090229983, .262480162787]
  global Waypoint_20_q=[-3.3684676667627205, -1.191816195275802, 1.4015747865517827, 0.7519456332104983, -0.12742073350990069, -0.5504001287532203]
  global Waypoint_8_p=p[-.689650873132, .138963273545, .230691387978, -.851994598965, -1.645998530536, 1.646007616333]
  global Waypoint_8_q=[-0.9414032141314905, -1.501500443821289, 2.801856819783346, 4.981602895050802, -4.698942009602682, 1.571649193763733]
  global raa1_p=p[-.689643170661, .139073527807, .230690921608, -.852069296672, -1.645944888292, 1.645881185303]
  global raa1_q=[-1.1455705801593226, -1.5426994071206828, 2.8454588095294397, 4.979022520571508, -4.9029627482043665, 1.5718539953231812]
  global raa2_p=p[-.114157470946, .855108345894, .597477301975, -.505907028801, .325764798924, .388694870300]
  global raa2_q=[-1.2560303846942347, -1.339010552769043, 2.4151175657855433, 3.6540276247211914, -2.7377544085132044, 1.1360299587249756]
  global raa3_p=p[-.308547482234, .387797636904, .242407099860, 1.976327760240, .350206946999, -1.916000398832]
  global raa3_q=[-1.8931763807879847, -1.3096025747111817, 2.212959591542379, 0.7217818933674316, 1.639076590538025, 0.8125834465026855]
  global raa4_p=p[-.733576132099, .077690893520, .242409727900, 1.976419296976, .350069431278, -1.916084616091]
  global raa4_q=[-0.8909156958209437, -1.3431089532426377, 2.273750130330221, 0.7266384798237304, 1.5611975193023682, 1.8127720355987549]
  global Waypoint_23_p=p[-.540166575654, .215949141041, .034631452617, -1.505795438113, 1.057579835594, 1.573514753692]
  global Waypoint_23_q=[-0.46167117754091436, -1.1365486842444916, 2.508885685597555, 0.15223841249432368, 1.4952874183654785, 3.819530963897705]
  global Waypoint_24_p=p[-.308525559537, .606096497354, .242373144855, -2.133742737559, .349425192770, 2.130939839044]
  global Waypoint_24_q=[-1.8709262053119105, -1.2877716285041352, 2.192875687276022, 0.7510036665150146, 1.5878156423568726, 1.5091480016708374]
  global Waypoint_39_p=p[.397377312153, .356253310648, .319810281486, 2.316317670744, 2.057592854035, .074120023159]
  global Waypoint_39_q=[-3.4579551855670374, -2.0568958721556605, 2.3265963236438196, -0.22706706941638188, -0.19935590425600225, -0.10534030595888311]
  global Waypoint_37_p=p[.397366630181, .356258644196, .319813668943, 2.316299214281, 2.057614642521, .074125657910]
  global Waypoint_37_q=[-3.4579508940326136, -2.056904455224508, 2.3265963236438196, -0.2270481151393433, -0.19937020937074834, -0.10535222688783819]
  global Waypoint_15_p=p[-.157621040248, .513353603496, .815677694745, -.672699538592, -1.852318447516, -.055422773001]
  global Waypoint_15_q=[-2.770456854497091, -1.8207680187621058, 2.3065691629992884, 1.0170823770710449, -1.0767205397235315, -0.8071182409869593]
  global Waypoint_25_p=p[-.161036555831, .970524399959, .722042384791, -.554954311189, .106465018540, .328580879483]
  global Waypoint_25_q=[-1.3071630636798304, -1.3366777312806626, 2.2083633581744593, 3.7187773424335937, -2.9519384543048304, 0.9132363796234131]
  global Waypoint_72_p=p[-.289685725237, .534256396594, .757196155975, -.295237726329, -.653009715205, .389435972469]
  global Waypoint_72_q=[-1.394179646168844, -1.6550847492613734, 2.7336154619800013, 4.156686468715332, -3.7981911341296595, 1.731092095375061]
  global Waypoint_26_p=p[-.689650873132, .138963273545, .230691387978, -.851994598965, -1.645998530536, 1.646007616333]
  global Waypoint_26_q=[-0.9414032141314905, -1.501500443821289, 2.801856819783346, 4.981602895050802, -4.698942009602682, 1.571649193763733]
  global Waypoint_27_p=p[-.568724745609, .230601805298, .220208295176, -1.519097711196, -.535155391172, .573964121010]
  global Waypoint_27_q=[-0.04883271852602178, -1.2753942471793671, 2.4771457354175013, 5.041022258787908, -2.326899592076437, 1.532160997390747]
  global Waypoint_28_p=p[-.568724745609, .230601805298, .220208295176, -1.519097711196, -.535155391172, .573964121010]
  global Waypoint_28_q=[-0.04883271852602178, -1.2753942471793671, 2.4771457354175013, 5.041022258787908, -2.326899592076437, 1.532160997390747]
  global Waypoint_29_p=p[-.689650873132, .138963273545, .230691387978, -.851994598965, -1.645998530536, 1.646007616333]
  global Waypoint_29_q=[-0.9414032141314905, -1.501500443821289, 2.801856819783346, 4.981602895050802, -4.698942009602682, 1.571649193763733]
  global Waypoint_30_p=p[-.853851193668, .133266829906, .060418082908, -.274178222953, -2.359710051999, .046821166283]
  global Waypoint_30_q=[-0.608560864125387, -1.0122360748103638, 2.787060801182882, 3.7283646303364257, -4.940747324620382, 0.3777344226837158]
  global Waypoint_31_p=p[-.979398188272, -.259625449453, .211289397035, -.673010443572, -1.459355862765, -.640164958946]
  global Waypoint_31_q=[0.36968713998794556, -0.5732358259013672, 2.138303581868307, 3.1253925996967773, -4.70385724702944, -1.2100523153888147]
  global Waypoint_32_p=p[-.826865752305, .369357632284, .043113676955, .574997346548, -1.492225541214, .597128135378]
  global Waypoint_32_q=[-1.0355513731585901, -0.33930082738909917, 2.126244846974508, 2.9386045175739746, -4.711197797452108, 1.7860286235809326]
  global Waypoint_33_p=p[-.689650873132, .138963273545, .230691387978, -.851994598965, -1.645998530536, 1.646007616333]
  global Waypoint_33_q=[-0.9414032141314905, -1.501500443821289, 2.801856819783346, 4.981602895050802, -4.698942009602682, 1.571649193763733]
  global Waypoint_73_p=p[-.289671192632, .534275423553, .757232902417, -.295189983811, -.652980753171, .389398176275]
  global Waypoint_73_q=[-1.39418870607485, -1.65509094814443, 2.7335642019854944, 4.156684561366699, -3.7981610933886927, 1.731088399887085]
  global Waypoint_16_p=p[.191112811238, .567512170908, .815514010937, -.135771161622, .396053809900, .208825693369]
  global Waypoint_16_q=[-1.6536315123187464, -1.762029310266012, 2.6225650946246546, 3.2891055780598144, -2.6549678484546106, 0.8520665764808655]
  global Waypoint_17_p=p[-.254565633623, .502963426820, 1.135401557820, -.261910507478, -.749716086887, 1.349041636154]
  global Waypoint_17_q=[-2.035229508076803, -1.8928028545775355, 2.468372408543722, 2.19391576826062, -1.167032543812887, -0.5091407934771937]
  global Waypoint_18_p=p[-.009208376822, .593717720951, .505810027228, -1.424406033077, -2.344120510145, -.527630245278]
  global Waypoint_18_q=[-2.9172328154193323, -1.9945279560484828, 2.3804522196399134, 0.6930715280720214, -0.5671199003802698, -1.1566088835345667]
  global Waypoint_38_p=p[.397379749540, .356252016937, .319817140705, 2.316310534508, 2.057580214841, .074134378577]
  global Waypoint_38_q=[-3.457958761845724, -2.0569073162474574, 2.3265913168536585, -0.22705944002185063, -0.19935638109316045, -0.10534793535341436]
  global Waypoint_40_p=p[.360688403366, .270119715397, .646144746546, .057805349154, 2.125995180379, 2.134053153683]
  global Waypoint_40_q=[-3.4579489866839808, -2.0569035015501917, 2.3265796343432825, -0.22706706941638188, -0.1993501822101038, -0.10534793535341436]
  global Waypoint_2_p=p[-.548957282596, .386284559177, .143710178207, 1.570800598292, -.000025190822, .000004803470]
  global Waypoint_2_q=[-1.0516188780414026, -1.010990933781006, 2.1562450567828577, -1.143702046280243, -1.0526168982135218, -0.0017235914813440445]
  global r1_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r1_ek_oldhome_q=[-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569]
  global r1_ek_extrude_p=p[.454852104155, .405448828659, .064015413765, 2.316807606413, 2.051392071696, .076664825947]
  global r1_ek_extrude_q=[-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624]
  global r1_ek_front_p=p[.439064809878, .405452261046, .065996139932, 2.316843937268, 2.051427632497, .076607106393]
  global r1_ek_front_q=[-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741]
  global r1_ek_middle_p=p[.419010105608, .404850828431, .065994665459, 2.309574128677, 2.044678176343, .089098333896]
  global r1_ek_middle_q=[-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249]
  global r1_ek_middle2_p=p[.417011768852, .405435328663, .065002627117, 2.316867113472, 2.051334925313, .076628493429]
  global r1_ek_middle2_q=[-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365]
  global r1_ek_bottom_p=p[.413071667620, .405431286494, .067999701073, 2.316819721954, 2.051304037200, .076688572349]
  global r1_ek_bottom_q=[-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436]
  global r1_ek_end_p=p[.389998638281, .405443674081, .068004818811, 2.316851991921, 2.051367741778, .076612018685]
  global r1_ek_end_q=[-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702]
  global r2_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r2_ek_oldhome_q=[-3.461132842686933, -2.062320779349874, 2.32916033290004, -0.21924456446492258, -0.20097883707844666, -0.11039879152527199]
  global r2_ek_extrude_p=p[.612885745678, .429305279732, .100477107124, 2.149994969793, 2.225764025207, .087353352584]
  global r2_ek_extrude_q=[-3.199475796455825, -1.4862854517875999, 2.263543898005424, -0.6928175084157413, -0.09183293866530295, -0.15653548683830643]
  global r2_ek_front_p=p[.556405415915, .429305279815, .076984362723, -2.170411249256, -2.268200695165, -.015853660170]
  global r2_ek_front_q=[-3.2029012478485694, -1.4943971905029905, 2.3176866046272355, -0.727203417516419, -0.10461513056100813, -0.1013922369747533]
  global r2_ek_middle_p=p[.550033970532, .429305279917, .076253920653, -2.170411249261, -2.268200695170, -.015853660159]
  global r2_ek_middle_q=[-3.2036200175167613, -1.5006788185274456, 2.326226188945654, -0.730095076239345, -0.10533288811000929, -0.10075548926859312]
  global r2_ek_bottom_p=p[.546594660555, .429305280025, .080868477599, -2.170411249265, -2.268200695174, -.015853660149]
  global r2_ek_bottom_q=[-3.204010221105431, -1.5099366263094405, 2.3272215014458872, -0.722096275899732, -0.10572512264357048, -0.10049057923478166]
  global r2_ek_end_p=p[.537335106646, .429305280055, .080868477459, -2.170411249266, -2.268200695175, -.015853660146]
  global r2_ek_end_q=[-3.205098875769389, -1.5204959829395506, 2.3387656715508855, -0.724001524008818, -0.10681294496314919, -0.09956563917089412]
  global r4_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r4_ek_oldhome_q=[-3.4680860338785493, -2.070376223306912, 2.3329367157510497, -0.22828162349163783, -0.20619604348947362, -0.09694130604598783]
  global r4_ek_extrude_p=p[.458670548589, .429305279741, .125141489362, 2.149994969793, 2.225764025207, .087353352584]
  global r4_ek_extrude_q=[-3.224306558956634, -1.7135315940479465, 2.43410270276974, -0.6768839938806144, -0.1154143142053492, -0.11562209601533713]
  global r4_ek_front_p=p[.420084046436, .429305279533, .122370065986, -2.206701899775, -2.177374452500, .052747240372]
  global r4_ek_front_q=[-3.2223885287117087, -1.7265329174617632, 2.4434355314143925, -0.6644243149558609, -0.06512925128431313, -0.01659929377642566]
  global r4_ek_middle_p=p[.385663706386, .429305279588, .119862350556, -2.206701899778, -2.177374452500, .052747240377]
  global r4_ek_middle_q=[-3.2295441306515738, -1.774240686665987, 2.4822688267544946, -0.6583601229072489, -0.07232201786773373, -0.0137735297523216]
  global r4_ek_bottom_p=p[.385663706260, .429305279599, .122809894660, -2.206701899778, -2.177374452501, .052747240377]
  global r4_ek_bottom_q=[-3.2295577467539287, -1.7778480193330992, 2.4794176409730713, -0.6518633442593682, -0.07233077879629679, -0.013811892538432069]
  global r4_ek_end_p=p[.366757227289, .429305279628, .122809894538, -2.206701899780, -2.177374452501, .052747240380]
  global r4_ek_end_q=[-3.2341047638544715, -1.8072551968371293, 2.4987903200913473, -0.6435011221874376, -0.07689850609233773, -0.01212997029934737]
  global oldhome_p=p[.397683836105, .356251384911, .315246899233, 2.316304177919, 2.057561756051, .074146544723]
  global oldhome_q=[-3.457960907612936, -2.0569125614561976, 2.326589886342184, -0.22707636774096684, -0.19935208955873662, -0.10534269014467412]
  global Waypoint_34_p=p[.695155464390, .367451880816, .502522491683, 2.093108370749, 1.857548644474, .308841595089]
  global Waypoint_34_q=[-3.249415699635641, -1.9387923679747523, 2.3226097265826624, 3.981850786800049, -0.05697328249086553, 1.5286790132522583]
  global Waypoint_35_p=p[.687527620967, .415165960724, .537921070000, 2.127101811831, 1.929915403723, .470130777221]
  global Waypoint_35_q=[-3.249424997960226, -1.9387947521605433, 2.32263428369631, 3.9818588930317382, -6.198007937763826, 1.5286580324172974]
  global Waypoint_36_p=p[-.693756081485, .141369193308, .218584735520, -.851978179689, -1.646001533937, 1.646008371360]
  global Waypoint_36_q=[-1.1533568541156214, -1.4924076360515137, 2.8518698851214808, 4.922323781042852, -4.910887185727255, 1.5719373226165771]
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global Waypoint_4_p=p[-.658264763546, .299530128456, .030909835036, .426821001551, -1.621505068649, .437070885767]
  global Waypoint_4_q=[-1.350241486226217, -0.9702387017062684, 2.492185179387228, -1.7834822140135707, -0.33723670641054326, 1.8489984273910522]
  global Waypoint_13_p=p[-.343952006273, .632142227752, .615174722549, -.025948978133, -.008794819136, -.567469912202]
  global Waypoint_13_q=[-1.350241486226217, -0.9702451390079041, 2.492171827946798, -3.0669099293150843, 1.575993537902832, 2.355180025100708]
  global Waypoint_1_p=p[-.343952006258, .632142227456, .615174722551, -.025016780489, .033118613186, -3.068519793995]
  global Waypoint_1_q=[-1.3432858302651205, -0.8819789687502322, 2.478150442072055, -3.1920490209023007, 1.5816449765089289, -0.1549241290366341]
  global Waypoint_14_p=p[-.343952006273, .632142227752, .615174722549, -.025948978133, -.008794819136, -.567469912202]
  global Waypoint_14_q=[-1.350241486226217, -0.9702451390079041, 2.492171827946798, -3.0669099293150843, 1.575993537902832, 2.355180025100708]
  global Waypoint_41_p=p[.392127936214, .533269017847, .644148583936, .057822570580, 2.125982462550, 2.134033989912]
  global Waypoint_41_q=[-3.4579578081714075, -2.0569120846190394, 2.3265841642962855, -0.22706885755572515, -0.1993349234210413, -0.10534984270204717]
  def move_path_3right():
    $ 134 "move_path_3right" "noBreak"
    $ 135 "'this is the path for Down, Over, then Back Around'"
    # 'this is the path for Down, Over, then Back Around'
    $ 136 "Comment"
    # Comment
    $ 145 "align_ready_for_welding()"
    align_ready_for_welding()
    $ 146 "Comment"
    # Comment
    $ 147 "p1≔pathturn[0]"
    global p1=pathturn[0]
    $ 148 "p2≔pathturn[1]"
    global p2=pathturn[1]
    $ 149 "p4≔pathturn[2]"
    global p4=pathturn[2]
    $ 150 "p5≔pathturn[3]"
    global p5=pathturn[3]
    $ 151 "pa1≔p[p1[0]+0.05,p1[1]+0.05,p1[2],p1[3],p1[4],p1[5]]"
    global pa1=p[p1[0]+0.05,p1[1]+0.05,p1[2],p1[3],p1[4],p1[5]]
    $ 152 "liftcolumnup"
    $ 153 "liftcolumnz≔liftcolumnzneeded"
    global liftcolumnz=liftcolumnzneeded
    $ 154 "If liftcolumnz>0"
    if (liftcolumnz>0):
      # begin: URCap Program Node
      #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
      #   Type: MachineLogic for Universal Robots
      $ 155 "MachineLogic Move to Position"
      while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
      end
      if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
      if temp_estop_var_vention=="estop/status true":
      sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
      end
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      if temp_estop_var_vention=="estop/status true":
      popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
      end
      end
      else:
      popup("resource is being used already: MachineMotion1")
      halt
      end
      sendString("SET speed_v2 3000000.000", "Ack", "MachineMotion1")
      sendString("SET acceleration_v2 50000.000", "Ack", "MachineMotion1")
      string_vention=intToString(liftcolumnz*1000,"MachineMotion1")
      sendString("SET de_move_abs_1 "+string_vention, "Ack", "MachineMotion1")
      sendString("de_move_abs_exec", "Ack", "MachineMotion1")
      isVentionParallelMovementSendingScriptMachineMotion1 = False
      pollString("isMotionCompleted", "MachineMotion isMotionCompleted = true", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sleep(0.03)
      # end: URCap Program Node
    end
    $ 156 "MoveJ"
    $ 157 "pa1" "breakAfter"
    movej(pa1, a=1.3962634015954636, v=0.3490658503988659)
    $ 158 "MoveL"
    $ 159 "p1" "breakAfter"
    movel(p1, a=0.2, v=0.05)
    $ 160 "Wait: 8.0"
    sleep(8.0)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 161 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 162 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 163 "Wait: 1.0"
    sleep(1.0)
    $ 165 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 166 "MoveL"
    $ 167 "p2" "breakAfter"
    movel(p2, a=0.1, v=0.01)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 168 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 169 "Wait: 0.5"
    sleep(0.5)
    $ 170 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 171 "MoveL"
    $ 172 "p4" "breakAfter"
    movel(p4, a=0.01, v=0.12)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 173 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 174 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 175 "Wait: 1.0"
    sleep(1.0)
    $ 177 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 178 "MoveL"
    $ 179 "p5" "breakAfter"
    movel(p5, a=0.1, v=0.01)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 180 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 181 "Wait: 2.0"
    sleep(2.0)
    $ 182 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 183 "Comment"
    # Comment
    $ 184 "pret1≔p[p5[0]+.1,p5[1],p5[2],p5[3],p5[4],p5[5]]"
    global pret1=p[p5[0]+.1,p5[1],p5[2],p5[3],p5[4],p5[5]]
    $ 185 "p_1≔pathturn[4]"
    global p_1=pathturn[4]
    $ 186 "p_2≔pathturn[5]"
    global p_2=pathturn[5]
    $ 187 "p_3≔pathturn[6]"
    global p_3=pathturn[6]
    $ 188 "p_4≔pathturn[7]"
    global p_4=pathturn[7]
    $ 189 "p_5≔pathturn[8]"
    global p_5=pathturn[8]
    $ 190 "p_preheat≔p[p_3[0]+.01,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]"
    global p_preheat=p[p_3[0]+.01,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]
    $ 191 "p_pre_ret≔p[p_1[0]+.03,p_1[1]+.03,p_1[2],p_1[3],p_1[4],p_1[5]]"
    global p_pre_ret=p[p_1[0]+.03,p_1[1]+.03,p_1[2],p_1[3],p_1[4],p_1[5]]
    $ 192 "p_pre_ret2≔p[p_3[0]+.1,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]"
    global p_pre_ret2=p[p_3[0]+.1,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]
    $ 193 "'twist'"
    # 'twist'
    $ 194 "MoveJ"
    $ 195 "pret1" "breakAfter"
    movej(pret1, a=1.3962634015954636, v=1.3962634015954636)
    $ 196 "Waypoint_8" "breakAfter"
    movej(get_inverse_kin(Waypoint_8_p, qnear=Waypoint_8_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 198 "MoveJ"
    $ 199 "raa1" "breakAfter"
    movej(get_inverse_kin(raa1_p, qnear=raa1_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 200 "raa2" "breakAfter"
    movej(get_inverse_kin(raa2_p, qnear=raa2_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 201 "raa3" "breakAfter"
    movej(get_inverse_kin(raa3_p, qnear=raa3_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 202 "raa4" "breakAfter"
    movej(get_inverse_kin(raa4_p, qnear=raa4_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 204 "If liftcolumnz≠0.0"
    if (liftcolumnz != 0.0):
      # begin: URCap Program Node
      #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
      #   Type: MachineLogic for Universal Robots
      $ 205 "MachineLogic Homing"
      while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
      end
      if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
      if temp_estop_var_vention=="estop/status true":
      sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
      end
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      if temp_estop_var_vention=="estop/status true":
      popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
      end
      end
      else:
      popup("resource is being used already: MachineMotion1")
      halt
      end
      isVentionMovementBusyMachineMotion1 = True
      sendString("im_home_axis_1", "MachineMotion im_home_axis_1 = completed", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sendString("SET im_set_encoder_pos_aux_1 0.000", "Ack", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sleep(0.03)
      # end: URCap Program Node
    end
    $ 206 "'preheat'"
    # 'preheat'
    $ 209 "MoveL"
    $ 210 "p_pre_ret2" "breakAfter"
    movel(p_pre_ret2, a=1.2, v=0.25)
    $ 211 "p_preheat" "breakAfter"
    movel(p_preheat, a=1.2, v=0.25)
    $ 212 "Wait: 6.0"
    sleep(6.0)
    $ 213 "MoveL"
    $ 214 "p_pre_ret2" "breakAfter"
    movel(p_pre_ret2, a=1.2, v=0.25)
    $ 215 "p_pre_ret" "breakAfter"
    movel(p_pre_ret, a=1.2, v=0.25)
    $ 216 "Set"
    set_tcp(p[0.00451,-0.328,0.105,1.2092,-1.2092,1.2092])
    $ 217 "MoveL"
    $ 218 "p_1" "breakAfter"
    movel(p_1, a=1.2, v=0.05)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 219 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 220 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 221 "Wait: 1.0"
    sleep(1.0)
    $ 222 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 224 "Wait: 1.0"
    sleep(1.0)
    $ 225 "MoveL"
    $ 226 "p_2" "breakAfter"
    movel(p_2, a=1.2, v=0.01)
    $ 227 "MoveP"
    $ 228 "CircleMove"
    $ 229 "p_3" "noBreak"
    
    $ 230 "p_4" "breakAfter"
    movec(p_3, p_4, a=0.01, v=5.0E-4, r=0.0, mode=1)
    $ 231 "MoveL"
    $ 232 "p_5" "breakAfter"
    movel(p_5, a=1.2, v=0.012)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 233 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 234 "Wait: 2.0"
    sleep(2.0)
    $ 235 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 236 "MoveL"
    $ 237 "Waypoint_23" "breakAfter"
    movel(Waypoint_23_p, a=1.2, v=0.25)
    $ 238 "MoveJ"
    $ 239 "Waypoint_24" "breakAfter"
    movej(get_inverse_kin(Waypoint_24_p, qnear=Waypoint_24_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 240 "Waypoint_39" "breakAfter"
    movej(get_inverse_kin(Waypoint_39_p, qnear=Waypoint_39_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 241 "'above waypoint is home'"
    # 'above waypoint is home'
  end
  def move_path_3left():
    $ 242 "move_path_3left" "noBreak"
    $ 243 "'this is the path for Down, Over, then Back Around'"
    # 'this is the path for Down, Over, then Back Around'
    $ 244 "Comment"
    # Comment
    $ 245 "MoveJ"
    $ 246 "Waypoint_37" "breakAfter"
    movej(get_inverse_kin(Waypoint_37_p, qnear=Waypoint_37_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 247 "'above point is home'"
    # 'above point is home'
    $ 248 "liftcolumnup"
    $ 249 "liftcolumnz≔liftcolumnzneeded"
    global liftcolumnz=liftcolumnzneeded
    $ 250 "If liftcolumnz>0"
    if (liftcolumnz>0):
      # begin: URCap Program Node
      #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
      #   Type: MachineLogic for Universal Robots
      $ 251 "MachineLogic Move to Position"
      while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
      end
      if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
      if temp_estop_var_vention=="estop/status true":
      sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
      end
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      if temp_estop_var_vention=="estop/status true":
      popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
      end
      end
      else:
      popup("resource is being used already: MachineMotion1")
      halt
      end
      sendString("SET speed_v2 3000000.000", "Ack", "MachineMotion1")
      sendString("SET acceleration_v2 50000.000", "Ack", "MachineMotion1")
      string_vention=intToString(liftcolumnz*1000,"MachineMotion1")
      sendString("SET de_move_abs_1 "+string_vention, "Ack", "MachineMotion1")
      sendString("de_move_abs_exec", "Ack", "MachineMotion1")
      isVentionParallelMovementSendingScriptMachineMotion1 = False
      pollString("isMotionCompleted", "MachineMotion isMotionCompleted = true", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sleep(0.03)
      # end: URCap Program Node
    end
    $ 252 "Waypoint_15" "breakAfter"
    movej(get_inverse_kin(Waypoint_15_p, qnear=Waypoint_15_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 253 "Waypoint_25" "breakAfter"
    movej(get_inverse_kin(Waypoint_25_p, qnear=Waypoint_25_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 254 "Waypoint_72" "breakAfter"
    movej(get_inverse_kin(Waypoint_72_p, qnear=Waypoint_72_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 255 "Waypoint_26" "breakAfter"
    movej(get_inverse_kin(Waypoint_26_p, qnear=Waypoint_26_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 256 "Waypoint_27" "breakAfter"
    movej(get_inverse_kin(Waypoint_27_p, qnear=Waypoint_27_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 261 "Comment"
    # Comment
    $ 262 "p1≔pathturn[0]"
    global p1=pathturn[0]
    $ 263 "p2≔pathturn[1]"
    global p2=pathturn[1]
    $ 264 "p4≔pathturn[2]"
    global p4=pathturn[2]
    $ 265 "p5≔pathturn[3]"
    global p5=pathturn[3]
    $ 266 "pa1≔p[p1[0]+0.05,p1[1]-0.05,p1[2],p1[3],p1[4],p1[5]]"
    global pa1=p[p1[0]+0.05,p1[1]-0.05,p1[2],p1[3],p1[4],p1[5]]
    $ 267 "MoveJ"
    $ 268 "pa1" "breakAfter"
    movej(pa1, a=1.3962634015954636, v=1.0471975511965976)
    $ 269 "MoveL"
    $ 270 "p1" "breakAfter"
    movel(p1, a=0.1, v=0.05)
    $ 271 "Wait: 8.0"
    sleep(8.0)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 272 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 273 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 274 "Wait: 1.0"
    sleep(1.0)
    $ 276 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 277 "MoveL"
    $ 278 "p2" "breakAfter"
    movel(p2, a=0.1, v=0.01)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 279 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 280 "Wait: 0.5"
    sleep(0.5)
    $ 281 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 282 "MoveL"
    $ 283 "p4" "breakAfter"
    movel(p4, a=0.01, v=0.12)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 284 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 285 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 286 "Wait: 1.0"
    sleep(1.0)
    $ 288 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 289 "MoveL"
    $ 290 "p5" "breakAfter"
    movel(p5, a=0.1, v=0.01)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 291 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 292 "Wait: 2.0"
    sleep(2.0)
    $ 293 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 294 "Comment"
    # Comment
    $ 295 "pret1≔p[p5[0]+.1,p5[1],p5[2],p5[3],p5[4],p5[5]]"
    global pret1=p[p5[0]+.1,p5[1],p5[2],p5[3],p5[4],p5[5]]
    $ 296 "p_1≔pathturn[4]"
    global p_1=pathturn[4]
    $ 297 "p_2≔pathturn[5]"
    global p_2=pathturn[5]
    $ 298 "p_3≔pathturn[6]"
    global p_3=pathturn[6]
    $ 299 "p_4≔pathturn[7]"
    global p_4=pathturn[7]
    $ 300 "p_5≔pathturn[8]"
    global p_5=pathturn[8]
    $ 301 "p_preheat≔p[p_3[0]+.01,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]"
    global p_preheat=p[p_3[0]+.01,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]
    $ 302 "p_pre_ret≔p[p_1[0]+.03,p_1[1]-.03,p_1[2],p_1[3],p_1[4],p_1[5]]"
    global p_pre_ret=p[p_1[0]+.03,p_1[1]-.03,p_1[2],p_1[3],p_1[4],p_1[5]]
    $ 303 "p_pre_ret2≔p[p_3[0]+.03,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]"
    global p_pre_ret2=p[p_3[0]+.03,p_3[1],p_3[2],p_3[3],p_3[4],p_3[5]]
    $ 304 "MoveJ"
    $ 305 "pret1" "breakAfter"
    movej(pret1, a=1.3962634015954636, v=1.3962634015954636)
    $ 306 "Waypoint_28" "breakAfter"
    movej(get_inverse_kin(Waypoint_28_p, qnear=Waypoint_28_q), a=1.3962634015954636, v=1.3962634015954636)
    $ 307 "If liftcolumnz≠0.0"
    if (liftcolumnz != 0.0):
      # begin: URCap Program Node
      #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
      #   Type: MachineLogic for Universal Robots
      $ 308 "MachineLogic Homing"
      while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
      end
      if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
      if temp_estop_var_vention=="estop/status true":
      sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
      end
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      if temp_estop_var_vention=="estop/status true":
      popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
      end
      end
      else:
      popup("resource is being used already: MachineMotion1")
      halt
      end
      isVentionMovementBusyMachineMotion1 = True
      sendString("im_home_axis_1", "MachineMotion im_home_axis_1 = completed", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sendString("SET im_set_encoder_pos_aux_1 0.000", "Ack", "MachineMotion1")
      isVentionMovementBusyMachineMotion1 = False
      sleep(0.03)
      # end: URCap Program Node
    end
    $ 309 "'now go into the ccw weld position'"
    # 'now go into the ccw weld position'
    $ 310 "Waypoint_29" "breakAfter"
    movej(get_inverse_kin(Waypoint_29_p, qnear=Waypoint_29_q), a=1.3962634015954636, v=1.3962634015954636)
    $ 311 "Comment"
    # Comment
    $ 312 "Waypoint_30" "breakAfter"
    movej(get_inverse_kin(Waypoint_30_p, qnear=Waypoint_30_q), a=1.3962634015954636, v=1.3962634015954636)
    $ 313 "Waypoint_31" "breakAfter"
    movej(get_inverse_kin(Waypoint_31_p, qnear=Waypoint_31_q), a=1.3962634015954636, v=1.3962634015954636)
    $ 322 "MoveL"
    $ 323 "p_pre_ret" "breakAfter"
    movel(p_pre_ret, a=1.2, v=0.25)
    $ 324 "p_pre_ret2" "breakAfter"
    movel(p_pre_ret2, a=1.2, v=0.25)
    $ 325 "p_preheat" "breakAfter"
    movel(p_preheat, a=1.2, v=0.25)
    $ 326 "Wait: 6.0"
    sleep(6.0)
    $ 327 "MoveL"
    $ 328 "p_pre_ret2" "breakAfter"
    movel(p_pre_ret2, a=1.2, v=0.25)
    $ 329 "p_pre_ret" "breakAfter"
    movel(p_pre_ret, a=1.2, v=0.25)
    $ 330 "Set"
    set_tcp(p[0.00451,-0.328,0.105,1.2092,-1.2092,1.2092])
    $ 331 "MoveL"
    $ 332 "p_1" "breakAfter"
    movel(p_1, a=0.1, v=0.05)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 333 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 334 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 335 "Wait: 1.0"
    sleep(1.0)
    $ 336 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 338 "Wait: 1.0"
    sleep(1.0)
    $ 339 "MoveL"
    $ 340 "p_2" "breakAfter"
    movel(p_2, a=1.2, v=0.01)
    $ 341 "MoveP"
    $ 342 "CircleMove"
    $ 343 "p_3" "noBreak"
    
    $ 344 "p_4" "breakAfter"
    movec(p_3, p_4, a=0.01, v=5.0E-4, r=0.0, mode=1)
    $ 345 "MoveL"
    $ 346 "p_5" "breakAfter"
    movel(p_5, a=1.2, v=0.012)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 347 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 348 "Wait: 2.0"
    sleep(2.0)
    $ 349 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 354 "MoveJ"
    $ 355 "Waypoint_32" "breakAfter"
    movej(get_inverse_kin(Waypoint_32_p, qnear=Waypoint_32_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 356 "Waypoint_33" "breakAfter"
    movej(get_inverse_kin(Waypoint_33_p, qnear=Waypoint_33_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 357 "Waypoint_73" "breakAfter"
    movej(get_inverse_kin(Waypoint_73_p, qnear=Waypoint_73_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 358 "Comment"
    # Comment
    $ 359 "MoveJ"
    $ 360 "Waypoint_16" "breakAfter"
    movej(get_inverse_kin(Waypoint_16_p, qnear=Waypoint_16_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 361 "Waypoint_17" "breakAfter"
    movej(get_inverse_kin(Waypoint_17_p, qnear=Waypoint_17_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 362 "Waypoint_18" "breakAfter"
    movej(get_inverse_kin(Waypoint_18_p, qnear=Waypoint_18_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 363 "Waypoint_38" "breakAfter"
    movej(get_inverse_kin(Waypoint_38_p, qnear=Waypoint_38_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 364 "'above point is home'"
    # 'above point is home'
  end
  def Test_Teach_Position():
    $ 365 "Test_Teach_Position" "noBreak"
    $ 369 "MoveJ"
    $ 370 "Waypoint_40" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_40_p, qnear=Waypoint_40_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 371 "'above waypoint is home'"
    # 'above waypoint is home'
    $ 372 "Waypoint_2" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 373 "Set"
    set_tcp(p[-9.8E-4,-0.015880000000000002,0.284,0.0,0.0,0.0])
    $ 374 "freedrive_m_var≔ False "
    global freedrive_m_var=  False  
    $ 375 "freedrive_m_var≔ True "
    global freedrive_m_var=  True  
    $ 376 "Popup: Move the TCP to the top of the weld, then click 'Continue'"
    popup("Move the TCP to the top of the weld, then click 'Continue'", "Message", False, False, blocking=True)
    $ 377 "tcp_pose_top≔get_actual_tcp_pose()"
    global tcp_pose_top= get_actual_tcp_pose ()
    $ 378 "Popup: Move the TCP to the corner of the tank, then click 'Continue'"
    popup("Move the TCP to the corner of the tank, then click 'Continue'", "Message", False, False, blocking=True)
    $ 379 "tcp_pose≔get_actual_tcp_pose()"
    global tcp_pose= get_actual_tcp_pose ()
    $ 380 "freedrive_m_var≔ False "
    global freedrive_m_var=  False  
    $ 381 "Wait: 0.25"
    sleep(0.25)
    $ 382 "sync()"
    sync()
  end
  def align_tcp_left():
    $ 383 "align_tcp_left" "noBreak"
    $ 384 "'this program aligns the tcp parallel to the y direction'"
    # 'this program aligns the tcp parallel to the y direction'
    $ 385 "cp≔get_actual_tcp_pose()"
    global cp= get_actual_tcp_pose ()
    $ 386 "aligned_y_pose≔p[cp[0],cp[1],cp[2],1.570796,0,0]"
    global aligned_y_pose=p[cp[0],cp[1],cp[2],1.570796,0,0]
    $ 387 "MoveJ"
    $ 388 "aligned_y_pose" "breakAfter"
    movej(aligned_y_pose, a=1.3962634015954636, v=1.0471975511965976)
  end
  def extrude_knife3():
    $ 389 "extrude_knife3" "noBreak"
    $ 390 "pre program stuff"
    $ 391 "Set"
    set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
    $ 392 "ek_sp≔get_actual_tcp_pose()"
    global ek_sp= get_actual_tcp_pose ()
    $ 393 "MoveL"
    $ 394 "ek_sp" "breakAfter"
    movel(ek_sp, a=1.2, v=0.005)
    $ 395 "'list possible points'"
    # 'list possible points'
    $ 396 "robot 1 moves"
    $ 397 "If 1≟2"
    if (1 == 2):
      $ 398 "MoveJ"
      $ 399 "r1_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r1_ek_oldhome_p, qnear=r1_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 400 "r1_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r1_ek_extrude_p, qnear=r1_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 401 "r1_ek_front" "breakAfter"
      movej(get_inverse_kin(r1_ek_front_p, qnear=r1_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 402 "r1_ek_middle" "breakAfter"
      movej(get_inverse_kin(r1_ek_middle_p, qnear=r1_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 403 "r1_ek_middle2" "breakAfter"
      movej(get_inverse_kin(r1_ek_middle2_p, qnear=r1_ek_middle2_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 404 "r1_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r1_ek_bottom_p, qnear=r1_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 405 "r1_ek_end" "breakAfter"
      movej(get_inverse_kin(r1_ek_end_p, qnear=r1_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 406 "robot 2 moves"
    $ 407 "If 1≟2"
    if (1 == 2):
      $ 408 "MoveJ"
      $ 409 "r2_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r2_ek_oldhome_p, qnear=r2_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 411 "r2_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r2_ek_extrude_p, qnear=r2_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 412 "r2_ek_front" "breakAfter"
      movej(get_inverse_kin(r2_ek_front_p, qnear=r2_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 413 "r2_ek_middle" "breakAfter"
      movej(get_inverse_kin(r2_ek_middle_p, qnear=r2_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 414 "r2_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r2_ek_bottom_p, qnear=r2_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 415 "r2_ek_end" "breakAfter"
      movej(get_inverse_kin(r2_ek_end_p, qnear=r2_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 416 "robot 4 moves"
    $ 417 "If 1≟2"
    if (1 == 2):
      $ 418 "MoveJ"
      $ 419 "r4_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r4_ek_oldhome_p, qnear=r4_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 420 "r4_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r4_ek_extrude_p, qnear=r4_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 421 "r4_ek_front" "breakAfter"
      movej(get_inverse_kin(r4_ek_front_p, qnear=r4_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 422 "r4_ek_middle" "breakAfter"
      movej(get_inverse_kin(r4_ek_middle_p, qnear=r4_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 423 "r4_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r4_ek_bottom_p, qnear=r4_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 424 "r4_ek_end" "breakAfter"
      movej(get_inverse_kin(r4_ek_end_p, qnear=r4_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 425 "'detemine correct points for which robot'"
    # 'detemine correct points for which robot'
    $ 426 "If robot_number≟1"
    if (robot_number == 1):
      $ 427 "robot1 positions"
      $ 428 "ek_oldhome≔r1_ek_oldhome_p"
      global ek_oldhome=r1_ek_oldhome_p
      $ 429 "ek_extrude≔r1_ek_extrude_p"
      global ek_extrude=r1_ek_extrude_p
      $ 430 "ek_front≔r1_ek_front_p"
      global ek_front=r1_ek_front_p
      $ 431 "ek_middle≔r1_ek_middle_p"
      global ek_middle=r1_ek_middle_p
      $ 432 "ek_middle2≔r1_ek_middle2_p"
      global ek_middle2=r1_ek_middle2_p
      $ 433 "ek_bottom≔r1_ek_bottom_p"
      global ek_bottom=r1_ek_bottom_p
      $ 434 "ek_end≔r1_ek_end_q"
      global ek_end=r1_ek_end_q
    else:
      $ 435 "ElseIf robot_number≟2"
      if (robot_number == 2):
        $ 436 "robot2 positions"
        $ 437 "ek_oldhome≔r2_ek_oldhome_p"
        global ek_oldhome=r2_ek_oldhome_p
        $ 438 "ek_extrude≔r2_ek_extrude_p"
        global ek_extrude=r2_ek_extrude_p
        $ 439 "ek_front≔r2_ek_front_p"
        global ek_front=r2_ek_front_p
        $ 440 "ek_middle≔r2_ek_middle_p"
        global ek_middle=r2_ek_middle_p
        $ 441 "ek_middle2≔r2_ek_middle_p"
        global ek_middle2=r2_ek_middle_p
        $ 442 "ek_bottom≔r2_ek_bottom_p"
        global ek_bottom=r2_ek_bottom_p
        $ 443 "ek_end≔r2_ek_end_q"
        global ek_end=r2_ek_end_q
      else:
        $ 444 "ElseIf robot_number≟4"
        if (robot_number == 4):
          $ 445 "robot4 positions"
          $ 446 "ek_oldhome≔r4_ek_oldhome_p"
          global ek_oldhome=r4_ek_oldhome_p
          $ 447 "ek_extrude≔r4_ek_extrude_p"
          global ek_extrude=r4_ek_extrude_p
          $ 448 "ek_front≔r4_ek_front_p"
          global ek_front=r4_ek_front_p
          $ 449 "ek_middle≔r4_ek_middle_p"
          global ek_middle=r4_ek_middle_p
          $ 450 "ek_middle2≔r4_ek_middle_p"
          global ek_middle2=r4_ek_middle_p
          $ 451 "ek_bottom≔r4_ek_bottom_p"
          global ek_bottom=r4_ek_bottom_p
          $ 452 "ek_end≔r4_ek_end_q"
          global ek_end=r4_ek_end_q
        end
      end
    end
    $ 453 "'start of program'"
    # 'start of program'
    $ 455 "Set"
    set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
    $ 456 "MoveJ"
    $ 458 "ek_oldhome" "breakAfter"
    movej(ek_oldhome, a=1.3962634015954636, v=1.0471975511965976)
    $ 459 "'above waypoint is home'"
    # 'above waypoint is home'
    $ 460 "'move above bucket'"
    # 'move above bucket'
    $ 461 "MoveJ"
    $ 463 "ek_extrude" "breakAfter"
    movej(ek_extrude, a=1.3962634015954636, v=1.0471975511965976)
    $ 464 "'extrude out a foot'"
    # 'extrude out a foot'
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 466 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 467 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 468 "Wait: 24.0"
    sleep(24.0)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 469 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 470 "Wait: 1.0"
    sleep(1.0)
    $ 471 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 472 "'slice'"
    # 'slice'
    $ 473 "MoveL"
    $ 479 "ek_front" "breakAfter"
    movel(ek_front, a=0.05, v=0.03)
    $ 480 "ek_middle" "breakAfter"
    movel(ek_middle, a=0.05, v=0.03)
    $ 481 "ek_middle2" "breakAfter"
    movel(ek_middle2, a=0.05, v=0.03)
    $ 482 "ek_bottom" "breakAfter"
    movel(ek_bottom, a=0.05, v=0.03)
    $ 483 "ek_end" "breakAfter"
    movel(ek_end, a=0.05, v=0.03)
    $ 484 "MoveJ"
    $ 486 "ek_oldhome" "breakAfter"
    movej(ek_oldhome, a=1.3962634015954636, v=1.0471975511965976)
    $ 487 "'above waypoint is home'"
    # 'above waypoint is home'
  end
  def align_tcp_forward():
    $ 489 "align_tcp_forward" "noBreak"
    $ 490 "'this program aligns the tcp parallel to the y direction'"
    # 'this program aligns the tcp parallel to the y direction'
    $ 491 "cp≔get_actual_tcp_pose()"
    global cp= get_actual_tcp_pose ()
    $ 492 "aligned_y_pose≔p[cp[0],cp[1],cp[2],0,-1.570796,0]"
    global aligned_y_pose=p[cp[0],cp[1],cp[2],0,-1.570796,0]
    $ 493 "MoveJ"
    $ 494 "aligned_y_pose" "breakAfter"
    movej(aligned_y_pose, a=1.3962634015954636, v=1.0471975511965976)
  end
  def align_tcp_up():
    $ 495 "align_tcp_up" "noBreak"
    $ 496 "'this program aligns the tcp parallel to the y direction'"
    # 'this program aligns the tcp parallel to the y direction'
    $ 497 "cp≔get_actual_tcp_pose()"
    global cp= get_actual_tcp_pose ()
    $ 498 "aligned_y_pose≔p[cp[0],cp[1],cp[2],0,0,0]"
    global aligned_y_pose=p[cp[0],cp[1],cp[2],0,0,0]
    $ 499 "MoveJ"
    $ 500 "aligned_y_pose" "breakAfter"
    movej(aligned_y_pose, a=1.3962634015954636, v=1.0471975511965976)
  end
  def align_ready_for_welding():
    $ 501 "align_ready_for_welding" "noBreak"
    $ 502 "'this program takes the welder from home to a position alined ready for welding (vertically down)'"
    # 'this program takes the welder from home to a position alined ready for welding (vertically down)'
    $ 503 "MoveJ"
    $ 504 "oldhome" "breakAfter"
    movej(get_inverse_kin(oldhome_p, qnear=oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 505 "Waypoint_34" "breakAfter"
    movej(get_inverse_kin(Waypoint_34_p, qnear=Waypoint_34_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 506 "Waypoint_35" "breakAfter"
    movej(get_inverse_kin(Waypoint_35_p, qnear=Waypoint_35_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 507 "Waypoint_36" "breakAfter"
    movej(get_inverse_kin(Waypoint_36_p, qnear=Waypoint_36_q), a=1.3962634015954636, v=1.0471975511965976)
  end
  def Corner_Homing_45():
    $ 508 "Corner_Homing_45" "noBreak"
    $ 509 "'Use this program when tool is already positioned close to corner at 45deg'"
    # 'Use this program when tool is already positioned close to corner at 45deg'
    $ 510 "'tool flange will seek all 3 sides. will save those 5 locs in p__'"
    # 'tool flange will seek all 3 sides. will save those 5 locs in p__'
    $ 511 "Set"
    set_tcp(p[-9.8E-4,-0.015880000000000002,0.284,0.0,0.0,0.0])
    $ 520 "Wait: 1.0"
    sleep(1.0)
    $ 521 "tp≔get_actual_tcp_pose()"
    global tp= get_actual_tcp_pose ()
    $ 525 "path_pre≔get_corner_homing_45_pathpoints(tp,tcp_pose_top)"
    global path_pre=get_corner_homing_45_pathpoints(tp,tcp_pose_top)
    $ 526 "ph1≔path_pre[0]"
    global ph1=path_pre[0]
    $ 527 "ph2≔path_pre[1]"
    global ph2=path_pre[1]
    $ 528 "ph3≔path_pre[2]"
    global ph3=path_pre[2]
    $ 529 "ph4≔path_pre[3]"
    global ph4=path_pre[3]
    $ 530 "ph5≔path_pre[4]"
    global ph5=path_pre[4]
    $ 531 "ph6≔path_pre[5]"
    global ph6=path_pre[5]
    $ 532 "ph7≔path_pre[6]"
    global ph7=path_pre[6]
    $ 533 "ph2up≔path_pre[7]"
    global ph2up=path_pre[7]
    $ 534 "ph4up≔path_pre[8]"
    global ph4up=path_pre[8]
    $ 535 "MoveL"
    $ 536 "ph1" "breakAfter"
    movel(ph1, a=0.2, v=0.25)
    $ 537 "ph2" "breakAfter"
    movel(ph2, a=0.2, v=0.25)
    $ 538 "Wait: 0.5"
    sleep(0.5)
    $ 539 "MoveL"
    $ 540 "Direction: Base"
    global move_thread_flag_540=0
    thread move_thread_540():
      enter_critical
      move_thread_flag_540 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_540 = 2
      exit_critical
    end
    move_thread_flag_540 = 0
    move_thread_han_540 = run move_thread_540()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_540
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 541 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 542 "p11≔get_actual_tcp_pose()"
    global p11= get_actual_tcp_pose ()
    $ 543 "MoveJ"
    $ 544 "ph2" "breakAfter"
    movej(ph2, a=1.3962634015954636, v=1.0471975511965976)
    $ 545 "ph2up" "breakAfter"
    movej(ph2up, a=1.3962634015954636, v=1.0471975511965976)
    $ 546 "Wait: 0.5"
    sleep(0.5)
    $ 547 "MoveL"
    $ 548 "Direction: Base"
    global move_thread_flag_548=0
    thread move_thread_548():
      enter_critical
      move_thread_flag_548 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_548 = 2
      exit_critical
    end
    move_thread_flag_548 = 0
    move_thread_han_548 = run move_thread_548()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_548
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 549 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 550 "p13≔get_actual_tcp_pose()"
    global p13= get_actual_tcp_pose ()
    $ 551 "MoveJ"
    $ 552 "ph2up" "breakAfter"
    movej(ph2up, a=1.3962634015954636, v=1.0471975511965976)
    $ 553 "ph3" "breakAfter"
    movej(ph3, a=1.3962634015954636, v=1.0471975511965976)
    $ 554 "Wait: 0.5"
    sleep(0.5)
    $ 555 "MoveL"
    $ 556 "Direction: Base"
    global move_thread_flag_556=0
    thread move_thread_556():
      enter_critical
      move_thread_flag_556 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_556 = 2
      exit_critical
    end
    move_thread_flag_556 = 0
    move_thread_han_556 = run move_thread_556()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_556
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 557 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 558 "p12≔get_actual_tcp_pose()"
    global p12= get_actual_tcp_pose ()
    $ 562 "MoveL"
    $ 563 "ph3" "breakAfter"
    movel(ph3, a=1.2, v=0.25)
    $ 564 "ph1" "breakAfter"
    movel(ph1, a=1.2, v=0.25)
    $ 569 "MoveL"
    $ 570 "ph4" "breakAfter"
    movel(ph4, a=1.2, v=0.25)
    $ 571 "Wait: 0.5"
    sleep(0.5)
    $ 572 "MoveL"
    $ 573 "Direction: Base"
    global move_thread_flag_573=0
    thread move_thread_573():
      enter_critical
      move_thread_flag_573 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1.0,1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_573 = 2
      exit_critical
    end
    move_thread_flag_573 = 0
    move_thread_han_573 = run move_thread_573()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_573
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 574 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 575 "p21≔get_actual_tcp_pose()"
    global p21= get_actual_tcp_pose ()
    $ 576 "MoveL"
    $ 577 "ph4" "breakAfter"
    movel(ph4, a=1.2, v=0.25)
    $ 578 "ph4up" "breakAfter"
    movel(ph4up, a=1.2, v=0.25)
    $ 579 "Wait: 0.5"
    sleep(0.5)
    $ 580 "MoveL"
    $ 581 "Direction: Base"
    global move_thread_flag_581=0
    thread move_thread_581():
      enter_critical
      move_thread_flag_581 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1.0,1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_581 = 2
      exit_critical
    end
    move_thread_flag_581 = 0
    move_thread_han_581 = run move_thread_581()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_581
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 582 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 583 "p23≔get_actual_tcp_pose()"
    global p23= get_actual_tcp_pose ()
    $ 584 "MoveL"
    $ 585 "ph4up" "breakAfter"
    movel(ph4up, a=1.2, v=0.25)
    $ 586 "ph5" "breakAfter"
    movel(ph5, a=1.2, v=0.25)
    $ 587 "Wait: 0.5"
    sleep(0.5)
    $ 588 "MoveL"
    $ 589 "Direction: Base"
    global move_thread_flag_589=0
    thread move_thread_589():
      enter_critical
      move_thread_flag_589 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1.0,1.0,0.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_589 = 2
      exit_critical
    end
    move_thread_flag_589 = 0
    move_thread_han_589 = run move_thread_589()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_589
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 590 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 591 "p22≔get_actual_tcp_pose()"
    global p22= get_actual_tcp_pose ()
    $ 602 "MoveJ"
    $ 603 "ph5" "breakAfter"
    movej(ph5, a=1.3962634015954636, v=1.0471975511965976)
    $ 604 "MoveL"
    $ 605 "ph4" "breakAfter"
    movel(ph4, a=1.2, v=0.25)
    $ 606 "ph1" "breakAfter"
    movel(ph1, a=1.2, v=0.25)
    $ 607 "MoveJ"
    $ 608 "Waypoint_4" "breakAfter"
    movej(get_inverse_kin(Waypoint_4_p, qnear=Waypoint_4_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 609 "Waypoint_13" "breakAfter"
    movej(get_inverse_kin(Waypoint_13_p, qnear=Waypoint_13_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 610 "Waypoint_1" "breakAfter"
    movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 611 "ph6" "breakAfter"
    movej(ph6, a=1.3962634015954636, v=1.0471975511965976)
    $ 612 "ph7" "breakAfter"
    movej(ph7, a=1.3962634015954636, v=1.0471975511965976)
    $ 613 "Wait: 1.0"
    sleep(1.0)
    $ 617 "MoveL"
    $ 618 "Direction: Base Z+"
    global move_thread_flag_618=0
    thread move_thread_618():
      enter_critical
      move_thread_flag_618 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [0.0,0.0,1.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_618 = 2
      exit_critical
    end
    move_thread_flag_618 = 0
    move_thread_han_618 = run move_thread_618()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_618
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 619 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 620 "p3≔get_actual_tcp_pose()"
    global p3= get_actual_tcp_pose ()
    $ 621 "MoveJ"
    $ 622 "ph7" "breakAfter"
    movej(ph7, a=1.3962634015954636, v=1.0471975511965976)
    $ 623 "ph6" "breakAfter"
    movej(ph6, a=1.3962634015954636, v=1.0471975511965976)
    $ 624 "Waypoint_14" "breakAfter"
    movej(get_inverse_kin(Waypoint_14_p, qnear=Waypoint_14_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 625 "Waypoint_4" "breakAfter"
    movej(get_inverse_kin(Waypoint_4_p, qnear=Waypoint_4_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 626 "Waypoint_41" "breakAfter"
    movej(get_inverse_kin(Waypoint_41_p, qnear=Waypoint_41_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 627 "'above waypoint is home'"
    # 'above waypoint is home'
    $ 629 "Comment"
    # Comment
    $ 630 "Comment"
    # Comment
    $ 631 "Comment"
    # Comment
    $ 632 "Comment"
    # Comment
    $ 633 "Comment"
    # Comment
    $ 634 "Comment"
    # Comment
  end
  $ 2 "BeforeStart"
  $ 3 "Safe Home Folder"
  $ 4 "'if robot is not at home, send it back to home safely'"
  # 'if robot is not at home, send it back to home safely'
  $ 5 "'make sure the tcp is welder'"
  # 'make sure the tcp is welder'
  $ 6 "Set"
  set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
  $ 7 "sp≔get_actual_tcp_pose()"
  global sp= get_actual_tcp_pose ()
  $ 8 "MoveL"
  $ 9 "sp" "breakAfter"
  movel(sp, a=1.2, v=0.25)
  $ 10 "'if first move is to a variable, skip automove'"
  # 'if first move is to a variable, skip automove'
  $ 11 "'turn off welder'"
  # 'turn off welder'
  # begin: URCap Program Node
  #   Source: WireTank Serial, 4.9.0, WireTank, LLC
  #   Type: WireTank Serial
  $ 12 "Serial Bridge uR0"
  SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
  # end: URCap Program Node
  $ 13 "Set DO[0]=Off"
  set_standard_digital_out(0, False)
  $ 14 "jp≔get_actual_joint_positions()"
  global jp= get_actual_joint_positions ()
  $ 15 "If sp[0]>0.600"
  if (sp[0]>0.600):
    $ 16 "'if x > 600 then above then home'"
    # 'if x > 600 then above then home'
    $ 17 "MoveJ"
    $ 19 "Waypoint_76" "breakAfter"
    movej(get_inverse_kin(Waypoint_76_p, qnear=Waypoint_76_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 20 "Home"
    movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  else:
    $ 21 "Else" "noBreak"
    $ 22 "Popup: retreating to home"
    popup("retreating to home", "Message", False, False, blocking=True)
    $ 23 "'for rules 2-8, finish with oldhome then above then home'"
    # 'for rules 2-8, finish with oldhome then above then home'
    $ 24 "If -1.74<jp[4] and jp[4]<1.05 and -1.74<jp[3] and jp[3]<1.74"
    if (-1.74<jp[4]  and  jp[4]<1.05  and  -1.74<jp[3]  and  jp[3]<1.74):
      $ 25 "'if oldhome, test teach, then go straight to oldhome'"
      # 'if oldhome, test teach, then go straight to oldhome'
    else:
      $ 26 "ElseIf sp[0]<-.5 and jp[3]>3.14 and -2.62<jp[4] and jp[4]<-0.87"
      if (sp[0]<-.5  and  jp[3]>3.14  and  -2.62<jp[4]  and  jp[4]<-0.87):
        $ 27 "'if left side weld approach, left weld approach in reverse'"
        # 'if left side weld approach, left weld approach in reverse'
        $ 28 "MoveJ"
        $ 29 "Waypoint_50" "breakAfter"
        movej(get_inverse_kin(Waypoint_50_p, qnear=Waypoint_50_q), a=1.3962634015954636, v=1.0471975511965976)
        $ 30 "Waypoint_51" "breakAfter"
        movej(get_inverse_kin(Waypoint_51_p, qnear=Waypoint_51_q), a=1.3962634015954636, v=1.0471975511965976)
        $ 31 "Waypoint_52" "breakAfter"
        movej(get_inverse_kin(Waypoint_52_p, qnear=Waypoint_52_q), a=1.3962634015954636, v=1.0471975511965976)
        $ 32 "Waypoint_53" "breakAfter"
        movej(get_inverse_kin(Waypoint_53_p, qnear=Waypoint_53_q), a=1.3962634015954636, v=1.0471975511965976)
      else:
        $ 33 "ElseIf sp[0]<0 and 0<jp[3] and jp[3]<1.74 and 0.87<jp[4] and jp[4]<2.62"
        if (sp[0]<0  and  0<jp[3]  and  jp[3]<1.74  and  0.87<jp[4]  and  jp[4]<2.62):
          $ 34 "'if right side around, move back then wapoint 24 then oldhome'"
          # 'if right side around, move back then wapoint 24 then oldhome'
          $ 35 "If sp[0]<-1.0"
          if (sp[0]<-1.0):
            $ 36 "xback≔p[-1.0,sp[1],sp[2],sp[3],sp[4],sp[5]]"
            global xback=p[-1.0,sp[1],sp[2],sp[3],sp[4],sp[5]]
            $ 37 "MoveJ"
            $ 38 "xback" "breakAfter"
            movej(xback, a=1.3962634015954636, v=1.0471975511965976)
          end
          $ 39 "MoveJ"
          $ 40 "Waypoint_54" "breakAfter"
          movej(get_inverse_kin(Waypoint_54_p, qnear=Waypoint_54_q), a=1.3962634015954636, v=1.0471975511965976)
        else:
          $ 41 "ElseIf jp[3]>2.62 and jp[4]<-3.84"
          if (jp[3]>2.62  and  jp[4]<-3.84):
            $ 42 "'if left side second half, then left weld ending sequence'"
            # 'if left side second half, then left weld ending sequence'
            $ 43 "If jp[5]<0.35"
            if (jp[5]<0.35):
              $ 44 "MoveJ"
              $ 45 "Waypoint_65" "breakAfter"
              movej(get_inverse_kin(Waypoint_65_p, qnear=Waypoint_65_q), a=1.3962634015954636, v=1.0471975511965976)
            end
            $ 46 "MoveJ"
            $ 51 "'above is testing, below is real'"
            # 'above is testing, below is real'
            $ 52 "Waypoint_55" "breakAfter"
            movej(get_inverse_kin(Waypoint_55_p, qnear=Waypoint_55_q), a=1.3962634015954636, v=1.0471975511965976)
            $ 54 "Waypoint_59" "breakAfter"
            movej(get_inverse_kin(Waypoint_59_p, qnear=Waypoint_59_q), t=2.0)
            $ 55 "Waypoint_71" "breakAfter"
            movej(get_inverse_kin(Waypoint_71_p, qnear=Waypoint_71_q), a=1.3962634015954636, v=1.0471975511965976)
            $ 56 "Waypoint_58" "breakAfter"
            movej(get_inverse_kin(Waypoint_58_p, qnear=Waypoint_58_q), a=1.3962634015954636, v=1.0471975511965976)
            $ 57 "Waypoint_56" "breakAfter"
            movej(get_inverse_kin(Waypoint_56_p, qnear=Waypoint_56_q), a=1.3962634015954636, v=1.0471975511965976)
            $ 58 "Waypoint_57" "breakAfter"
            movej(get_inverse_kin(Waypoint_57_p, qnear=Waypoint_57_q), a=1.3962634015954636, v=1.0471975511965976)
          else:
            $ 59 "ElseIf jp[3]<-2.09"
            if (jp[3]<-2.09):
              $ 60 "'bottom homing'"
              # 'bottom homing'
              $ 61 "MoveJ"
              $ 63 "Comment"
              # Comment
              $ 64 "If sp[0]<-0.95"
              if (sp[0]<-0.95):
                $ 65 "xback≔p[-0.95,sp[1],sp[2],sp[3],sp[4],sp[5]]"
                global xback=p[-0.95,sp[1],sp[2],sp[3],sp[4],sp[5]]
                $ 66 "MoveL"
                $ 67 "xback" "breakAfter"
                movel(xback, a=1.2, v=0.25)
              end
              $ 68 "Waypoint_67" "breakAfter"
              movej(get_inverse_kin(Waypoint_67_p, qnear=Waypoint_67_q), a=1.3962634015954636, v=1.0471975511965976)
            else:
              $ 69 "ElseIf jp[3]<0 and jp[4]<-3.14"
              if (jp[3]<0  and  jp[4]<-3.14):
                $ 70 "'if left side homing, special unspin'"
                # 'if left side homing, special unspin'
                $ 71 "MoveJ"
                $ 73 "Comment"
                # Comment
                $ 74 "Waypoint_69" "breakAfter"
                movej(get_inverse_kin(Waypoint_69_p, qnear=Waypoint_69_q), a=1.3962634015954636, v=1.0471975511965976)
                $ 75 "Waypoint_70" "breakAfter"
                movej(get_inverse_kin(Waypoint_70_p, qnear=Waypoint_70_q), a=1.3962634015954636, v=1.0471975511965976)
              else:
                $ 76 "ElseIf (sp[4]<-3 or sp[4]>3) and -0.02<sp[5] and sp[5]<0.02"
                if ((sp[4]<-3  or  sp[4]>3)  and  -0.02<sp[5]  and  sp[5]<0.02):
                  $ 77 "'go straight to home'"
                  # 'go straight to home'
                else:
                  $ 78 "ElseIf 2>1"
                  if (2>1):
                    $ 79 "'if none of the other options, then error continuously'"
                    # 'if none of the other options, then error continuously'
                    $ 80 "Loop 2>1"
                    while (2>1):
                      $ 81 "Popup: Unknown Position. Find Calvin for Assistance"
                      popup("Unknown Position. Find Calvin for Assistance", "Message", False, False, blocking=True)
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    $ 82 "'insert logic for how to get back to oldhome'"
    # 'insert logic for how to get back to oldhome'
    $ 83 "'finish with oldhome then above then home'"
    # 'finish with oldhome then above then home'
    $ 84 "MoveJ"
    $ 85 "Waypoint_49" "breakAfter"
    movej(get_inverse_kin(Waypoint_49_p, qnear=Waypoint_49_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 87 "Waypoint_75" "breakAfter"
    movej(get_inverse_kin(Waypoint_75_p, qnear=Waypoint_75_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 88 "Home"
    movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    $ 89 "MachineLogic Homing"
    while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    while(temp_estop_var_vention=="estop/status true"):
    if temp_estop_var_vention=="estop/status true":
    sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
    end
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    if temp_estop_var_vention=="estop/status true":
    popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
    end
    end
    else:
    popup("resource is being used already: MachineMotion1")
    halt
    end
    isVentionMovementBusyMachineMotion1 = True
    sendString("im_home_axis_1", "MachineMotion im_home_axis_1 = completed", "MachineMotion1")
    isVentionMovementBusyMachineMotion1 = False
    sendString("SET im_set_encoder_pos_aux_1 0.000", "Ack", "MachineMotion1")
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
  end
  $ 635 "Thread_1"
  thread Thread_1():
    $ 636 "Loop  True "
    while (  True  ):
      $ 637 "If freedrive_m_var≟ True "
      if (freedrive_m_var ==   True  ):
        $ 638 "freedrive_mode()"
        freedrive_mode()
        $ 639 "free_dr_already≔ True "
        global free_dr_already=  True  
      else:
        $ 640 "Else" "noBreak"
        $ 641 "If free_dr_already"
        if (free_dr_already):
          $ 642 "end_freedrive_mode()"
          end_freedrive_mode()
        end
      end
      $ 643 "sync()"
      sync()
    end
  end
  threadId_Thread_1 = run Thread_1()
  $ 90 "Robot Program"
  $ 91 "'start of main program'"
  # 'start of main program'
  $ 92 "Set"
  set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
  $ 93 "Home"
  movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  $ 94 "Script: analyze_touchpoints.script"
  # this file creates the function for analyzing touchpoints
  # define pi
  pi = 3.1415926535
  # initialize a lift column extension needed of 0.0
  global liftcolumnzneeded = 0.0 # set this variable in mm
  
  # this is the main entry point for calculations.
  # it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
  # specifically for Down, Over, then Around (DOtA)
  # specifically for right-sided boxes (vertical weld on right side of edge)
  def main_calculate_right(p11, p12, p21, p22, p3, p13, p23, chamferover):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
      validity = check_validity_right(struct1, struct2)
      return struct2
  end
  
  # this is the main entry point for calculations.
  # it takes in the 5 points, analyzes the shape of the box, and then calculates path points and returns them
  # specifically for Down, Over, then Around (DOtA)
  # specifically for left-sided boxes (vertical weld on left side of edge)
  def main_calculate_left(p11, p12, p21, p22, p3, p13, p23, chamferover):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_left(struct1, list1, chamferover)
      validity = check_validity_left(struct1, struct2)
      return struct2
  end
  
  # this is the main entry point for calculations, for Floor Corner Extended.
  # it takes in the 7 touchpoints, analyzes the shape of the box.
  # takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points
  # loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
  # returns the pathpoints
  # specifically for Down, Over, then Around (DOtA)
  # specifically for right-sided boxes (vertical weld on right side of edge)
  def main_calculate_right_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_right_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      struct3 = check_validity_right(struct1, struct2)
      return struct3
  end
  
  # this is the main entry point for calculations, for Floor Corner Extended.
  # it takes in the 7 touchpoints, analyzes the shape of the box.
  # takes in the user defined point for the top of the weld (tcp_pose_top) and then calculates path points
  # loopingly tries to calculate the extension along the sidewall that fulfills get_inverse_kin_has_solution() and provides the farthest extension possible
  # returns the pathpoints
  # specifically for Down, Over, then Around (DOtA)
  # specifically for left-sided boxes (vertical weld on left side of edge)
  def main_calculate_left_extended(p11, p12, p21, p22, p3, p13, p23, chamferover, chamferup, tcp_pose_top):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      struct3 = check_validity_left(struct1, struct2)
      return struct3
  end
  
  # it takes 5 arguments as points
  # it returns a struct containing: (pointintersect, pointapproach1, pointapproach2, point1, point2, point3, point4, point5, pointreturn1, heading1, heading2, heading3, path2r1, path2r2, path2l1, path2l2)
  # specifically for Around then Up (AtU)
  def analyze_touchpoints(p11, p12, p21, p22, p3):
    # FIND THE INTERSECTION
    # comment get the z
    zcoord=p3[2]
  
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]
  
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
  
    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]
    l2p2x=p22[0]
    l2p2y=p22[1]
  
    # equate the second line in 2d space
    ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)
  
    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x
  
  
    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1
  
    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect
  
    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)
  
    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p2x - xintersect
    l2delyfull = l2p2y - yintersect
  
    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)
  
    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag
  
    # FIND THE FOUR POINTS ON THE LINES
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance = 8
    roundoverdistance = 0.05
    zup = .375
    # inches
    wd = welddistance * 25.4 / 1000
    rod = roundoverdistance * 25.4 / 1000
    zup = zup * 25.4 / 1000
  
    # now we have the unit vector. extend the weld distance from the intersection
    x = xintersect + l1delxunit * wd
    y = yintersect + l1delyunit * wd
    z = zcoord + zup
  
    point1 = p[x,y,z,1.570796,0,0] # dummy orientation for now
  
    x = xintersect + l1delxunit * rod
    y = yintersect + l1delyunit * rod
  
    point2 = p[x,y,z,1.570796,0,0]
  
    # now we have the unit vector. extend the weld distance from the intersection
    x = xintersect + l2delxunit * wd
    y = yintersect + l2delyunit * wd
  
    point5 = p[x,y,z,0,-1.570796,0]
  
    x = xintersect + l2delxunit * rod
    y = yintersect + l2delyunit * rod
  
    point4 = p[x,y,z,0,-1.570796,0]
  
    #DEFINE APPROACH POINTS
    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
    pointapproach1 = p[xintersect+0.1,yintersect+0.1,z,1.570796,0,0]
    pointapproach2 = p[point1[0], point1[1]+0.1, point1[2], point1[3], point1[4], point1[5]]
    pointreturn1 = p[point5[0]+0.1, point5[1], point5[2], point5[3], point5[4], point5[5]]
  
    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
    headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (headingvector1 + headingvector2)/2
    # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
    heading1 = headingvector1 + pi/2
    heading3 = headingvector2 - pi/2
  
    #FIND POINT 3
    #see if we have to / can find point 3
    findpoint3 = True
    if roundoverdistance == 0:
      findpoint3 = False
    end
    if findpoint3:
      # i need to find the point3 such that the arc from p2 to p3 to p4 is tangent to p1-p2 and p4-p5. making this a smooth path will be good
      # the direction of movement is from pointintersect in the direction of heading2
      # how much movement though? this will depend on whether it is actually a 90 degree angle or not.
      # first, find the perpendicular lines through points 2 and 4
      perp2 = find_perpendicular_line(ml1, point2[0], point2[1])
      perp4 = find_perpendicular_line(ml2, point4[0], point4[1])
      # next, find the intersection of those two lines
      perpintersect = find_intersection(perp2[0], perp2[1], perp4[0], perp4[1])
      radiusofcircle = distance_between(perpintersect[0], perpintersect[1], 0, point2[0], point2[1], 0)
      # find a vector the direction of heading2
      uvx = cos(heading2)
      uvy = sin(heading2)
      # compute point3. pass in negative radius because the direction is into the tank but we want to move from the intersection out to the rounded edge
      point3coords = add_vectordistance_to_point(perpintersect[0], perpintersect[1], z, uvx, uvy, 0, -1 * radiusofcircle)
      point3 = p[point3coords[0], point3coords[1], point3coords[2], 0, 0, 0]
    end
  
    #APPLY ACTUAL RXRYRZ TO POINTS
    # convert the headings to rxryrz and insert those values into the relevant points
    rxryrz = convert_heading_to_axang(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    pointapproach1 = p[pointapproach1[0], pointapproach1[1], pointapproach1[2], rx, ry, rz]
    pointapproach2 = p[pointapproach2[0], pointapproach2[1], pointapproach2[2], rx, ry, rz]
    point1 = p[point1[0], point1[1], point1[2], rx, ry, rz]
    point2 = p[point2[0], point2[1], point2[2], rx, ry, rz]
    rxryrz = convert_heading_to_axang(heading2)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    if findpoint3:
      point3 = p[point3[0], point3[1], point3[2], rx, ry, rz]
    else:
      point3 = point2
    end
    rxryrz = convert_heading_to_axang(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[point4[0], point4[1], point4[2], rx, ry, rz]
    point5 = p[point5[0], point5[1], point5[2], rx, ry, rz]
    pointreturn1 = p[pointreturn1[0], pointreturn1[1], pointreturn1[2], rx, ry, rz]
  
    #find path2 (the part that goes up)
    four_vertical_points = find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, zup, wd, heading1, heading3)
    path2r1 = four_vertical_points[0]
    path2r2 = four_vertical_points[1]
    path2l1 = four_vertical_points[2]
    path2l2 = four_vertical_points[3]
  
    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, pointapproach1=pointapproach1, pointapproach2=pointapproach2, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, pointreturn1=pointreturn1, heading1=heading1, heading2=heading2, heading3=heading3, path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
    return ret
  end
  
  # based on a Corner Homing 45 Cover pattern of touchpoints
  # this uses those touchpoints to create a representation of the corner in 3d robot space.
  def analyze_touchpoints_only_cover(p11, p12, p21, p3):
      zcoord=p3[2]
  
      # get the raw points from the first line
      l1p1x=p11[0]
      l1p1y=p11[1]
      l1p2x=p12[0]
      l1p2y=p12[1]
  
      # equate the first line in 2d space
      ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
      # b = y - mx
      bl1 = l1p1y - ml1 * l1p1x
  
      # get the raw points from the second line
      l2p1x=p21[0]
      l2p1y=p21[1]
  
      # equate the second line in 2d space
      # ml2 = opposite reciprocal of ml1 (because they are perpendicular) (assume perpendicular to make calculation of weldpath much easier)
      ml2 = -1 / ml1
  
      # b = y - mx
      bl2 = l2p1y - ml2 * l2p1x
  
      # find the intersection of the two lines
      # m1x+b1 = m2x+b2
      # m1x - m2x = b2 - b1
      # x = (b2-b1) / (m1-m2)
      xintersect = (bl2-bl1) / (ml1-ml2)
      yintersect = ml1 * xintersect + bl1
  
      pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
      #FIND THE VECTORS
      #define a vector from the intersection to the second point on the first line
      l1delxfull = l1p2x - xintersect
      l1delyfull = l1p2y - yintersect
  
      l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)
  
      l1delxunit = l1delxfull / l1delmag
      l1delyunit = l1delyfull / l1delmag
  
      #define a vector from the intersection to the second point on the second line
      l2delxfull = l2p1x - xintersect
      l2delyfull = l2p1y - yintersect
  
      l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)
  
      l2delxunit = l2delxfull / l2delmag
      l2delyunit = l2delyfull / l2delmag
  
      #FIND HEADINGS
      #for each heading, find the angle of the line with respect to the pos x axis. this line is from pointintersect and along each edge of the corner
      heading1 = convert_uv_to_heading(l1delxunit, l1delyunit)
      heading3 = convert_uv_to_heading(l2delxunit, l2delyunit)
      # find halfway heading
      heading2 = (heading1 + heading3)/2
  
      #RETURN STRUCT
      ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
      return ret
  end
  
  # it takes 5 arguments as points
  # it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
  def analyze_touchpoints_only(p11, p12, p21, p22, p3):
    # FIND THE INTERSECTION
    # comment get the z
    zcoord=p3[2]
  
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]
  
    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
  
    # get the raw points from the second line
    l2p1x=p21[0]
    l2p1y=p21[1]
    l2p2x=p22[0]
    l2p2y=p22[1]
  
    # equate the second line in 2d space
    ml2 = (l2p2y-l2p1y) / (l2p2x-l2p1x)
  
    # b = y - mx
    bl2 = l2p1y - ml2 * l2p1x
  
  
    # find the intersection of the two lines
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    xintersect = (bl2-bl1) / (ml1-ml2)
    yintersect = ml1 * xintersect + bl1
  
    pointintersect = p[xintersect,yintersect,zcoord,0,0,0]
  
    #FIND THE VECTORS
    #define a vector from the intersection to the second point on the first line
    l1delxfull = l1p2x - xintersect
    l1delyfull = l1p2y - yintersect
  
    l1delmag = sqrt(l1delxfull*l1delxfull + l1delyfull*l1delyfull)
  
    l1delxunit = l1delxfull / l1delmag
    l1delyunit = l1delyfull / l1delmag
  
    #define a vector from the intersection to the second point on the second line
    l2delxfull = l2p2x - xintersect
    l2delyfull = l2p2y - yintersect
  
    l2delmag = sqrt(l2delxfull*l2delxfull + l2delyfull*l2delyfull)
  
    l2delxunit = l2delxfull / l2delmag
    l2delyunit = l2delyfull / l2delmag
  
    #FIND HEADINGS
    #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
    headingvector1 = convert_uv_to_heading(l1delxunit, l1delyunit)
    headingvector2 = convert_uv_to_heading(l2delxunit, l2delyunit)
    # find halfway heading
    heading2 = (headingvector1 + headingvector2)/2
    # find headings that the robot should face while traveling, perpendicular to the vectors of the sides of the box
    heading1 = headingvector1 + pi/2
    heading3 = headingvector2 - pi/2
  
    #RETURN STRUCT
    ret = struct(pointintersect=pointintersect, heading1=heading1, heading2=heading2, heading3=heading3, l1delxunit=l1delxunit, l1delyunit=l1delyunit, l2delxunit=l2delxunit, l2delyunit=l2delyunit)
    return ret
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for right, for non-extended
  def calculate_DOtA_points_right(struct1, listleans, chamferover):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l1delxunit * wd2
      y = y + l1delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * wd3
      y = pointintersect[1] + l2delyunit * wd3
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_5 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
  
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for left, for non-extended
  def calculate_DOtA_points_left(struct1, listleans, chamferover):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # vertical weld distance
      welddistance2 = 6 # first path second leg
      welddistance3 = 8 # second path second leg
      zup = .375
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = zup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l2delxunit * wd2
      y = y + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * wd3
      y = pointintersect[1] + l1delyunit * wd3
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_5 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
      #point 3 will not have the correct rxryrz though because now the gun needs to be face up.
      rxryrz = convert_heading_to_axang_ccw(heading2)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_3 = p[point_3[0], point_3[1], point_3[2], rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for right, for extended
  def calculate_DOtA_points_right_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      # welddistance1 = 8 # vertical weld distance
      welddistance2 = 5 # first path second leg
      welddistance3 = 5 # second path second leg
  
      # inches
      # wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = chamferup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      wd1 = tcp_pose_top[2] - pointintersect[2] - zup
  
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l1delxunit * wd2
      y = y + l1delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * chamferovermm
      y = pointintersect[1] + l1delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * wd3
      y = pointintersect[1] + l2delyunit * wd3
      point_5 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      atret5 = atret[5]
      point_3 = p[atret5[0], atret5[1], z, atret5[3], atret5[4], atret5[5]]
  
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # given a struct from analyze_touchpoints_only(), calculate the points
  # for left, for extended
  def calculate_DOtA_points_left_extended(struct1, listleans, chamferover, chamferup, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      # welddistance1 = 8 # vertical weld distance
      welddistance2 = 5 # first path second leg
      welddistance3 = 5 # second path second leg
  
      # inches
      # wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      zup = chamferup * 25.4 / 1000
      chamferovermm =  chamferover * 25.4 / 1000
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      wd1 = tcp_pose_top[2] - pointintersect[2] - zup
  
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      z = pointintersect[2] + zup
  
      #apply actual rxryrz to points
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_preheatdown(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz]
      point2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      point4 = p[x, y, z, rx, ry, rz]
      x = x + l2delxunit * wd2
      y = y + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # FIND THE POINTS ON THE LINES OF THE SECOND AROUND PATH
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l2delxunit * chamferovermm
      y = pointintersect[1] + l2delyunit * chamferovermm
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_1 = p[x, y, z, rx, ry, rz]
  
      x = pointintersect[0] + l2delxunit * rod
      y = pointintersect[1] + l2delyunit * rod
      point_2 = p[x, y, z, rx, ry, rz]
  
      # convert the headings to rxryrz and insert those values into the relevant points
      rxryrz = convert_heading_to_axang_ccw(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      x = pointintersect[0] + l1delxunit * rod
      y = pointintersect[1] + l1delyunit * rod
      point_4 = p[x, y, z, rx, ry, rz]
  
      # now we have the unit vector. extend the weld distance from the intersection
      x = pointintersect[0] + l1delxunit * wd3
      y = pointintersect[1] + l1delyunit * wd3
      point_5 = p[x, y, z, rx, ry, rz]
  
      #FIND POINT 3
      # by calling analyze_touchpoints()
      atret = analyze_touchpoints(point_2, point_1, point_4, point_5, pointintersect)
      point_3 = atret[5]
      #point 3 will not have the correct rxryrz though because now the gun needs to be face up
      rxryrz = convert_heading_to_axang_ccw(heading2)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point_3 = p[point_3[0], point_3[1], z, rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point_1, point_2=point_2, point_3=point_3, point_4=point_4, point_5=point_5)
      return struct2
  end
  
  # this function analyzes the vertical points
  # calculates the slope of the edge in question
  # specifically, for each inch up in the z direction, what is the change in x and change in y direction
  # returns a list of [nx, ny]
  def analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3):
      # first, find the equations of the planes from the 6 points
      plane1 = findplane(p11, p12, p13)
      plane2 = findplane(p21, p22, p23)
      # Find the Direction Vector of the Line: The direction vector d of the line of intersection can be found by taking the cross product of the normal vectors of each plane (a, b, and c)
      nx = plane1[1]*plane2[2] - plane1[2]*plane2[1]
      ny = plane1[2]*plane2[0] - plane1[0]*plane2[2]
      nz = plane1[0]*plane2[1] - plane1[1]*plane2[0]
      # normalize the vector so the z length is 1
      multiplier = 1 / nz
      nx = nx * multiplier
      ny = ny * multiplier
      nz = nz * multiplier # should become equal to 1
      ret = [nx, ny]
      return ret
  end
  
  # given 3 points, this finds the plane and its equation
  # rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
  def findplane(p11, p12, p13):
      # extract coordinates
      x1 = p11[0]
      y1 = p11[1]
      z1 = p11[2]
      x2 = p12[0]
      y2 = p12[1]
      z2 = p12[2]
      x3 = p13[0]
      y3 = p13[1]
      z3 = p13[2]
      # create vectors from the points
      v1x = x2-x1
      v1y = y2-y1
      v1z = z2-z1
      v2x = x3-x1
      v2y = y3-y1
      v2z = z3-z1
      #calculate the normal vector using the cross product
      nx = v1y*v2z - v1z*v2y # i component
      ny = v1z*v2x - v1x*v2z # j component
      nz = v1x*v2y - v1y*v2x # k component
      # calculate d in the plane equation
      d = -1 * (nx*x1 + ny*y1 + nz*z1)
      ret = [nx, ny, nz, d]
      return ret
  end
  
  # given a heading, (ccw from +x axis), find the mx+b slope
  # fails if exactly vertical
  def get_slope_from_heading(heading):
      return tan(heading)
  end
  
  
  
  # this function finds the points (and rxryrz) of the 2 points (start and end) of vertical weld section
  def find_vertical_points(pointintersect, l1delxunit, l1delyunit, l2delxunit, l2delyunit, offset, wd, heading1, heading3):
  
    # find right side stuff
    # find the point in 3d space that is .375 up and .375 over
    x = pointintersect[0] + l1delxunit * offset
    y = pointintersect[1] + l1delyunit * offset
    z = pointintersect[2] + offset
    # find rxryrz
    rxryrz = convert_heading_to_axang_preheatup(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    path2r1 = p[x, y, z, rx, ry, rz]
    path2r2 = p[x, y, z + wd, rx, ry, rz]
  
    # find left side
    # find the point in 3d space that is .375 up and .375 over
    x = pointintersect[0] + l2delxunit * offset
    y = pointintersect[1] + l2delyunit * offset
    z = pointintersect[2] + offset
    # find rxryrz
    rxryrz = convert_heading_to_axang_preheatup(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    path2l1 = p[x, y, z, rx, ry, rz]
    path2l2 = p[x, y, z + wd, rx, ry, rz]
  
    ret = struct(path2r1=path2r1, path2r2=path2r2, path2l1=path2l1, path2l2=path2l2)
    return ret
  end
  
  # this function converts a unit vector to its heading angle ccw from x+ axis
  # takes uvx and uvy
  # returns heading in radians
  def convert_uv_to_heading(uvx, uvy):
    baseang = atan(uvy/uvx)
    if uvx < 0:
      ang = baseang + pi
    elif uvy < 0:
      ang = baseang + pi * 2
    else:
      ang = baseang
    end
    return ang
  end
  
  # this function finds the equation of a line, perpendicular to a given line, and going through a given point
  # takes 3 arguments: m (the original line's slope), x (point's x coord), y (point's y coord). the b of the original line is not needed
  # returns a list of [m,b] (the slope and intercept of the new line)
  def find_perpendicular_line(origm, x, y):
    m = (1/origm) * -1
    b = y - m*x
    ret = [m, b]
    return ret
  end
  
  # this function finds the intersection point between two lines in the xy plane
  # takes 4 arguments: m1, b1, m2, b2
  # returns a list of [x,y] (the point of intersection)
  def find_intersection(m1, b1, m2, b2):
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    x = (b2-b1) / (m1-m2)
    y = m1 * x + b1
    ret = [x, y]
    return ret
  end
  
  # this function finds the distance between 2 points in 3d space
  # it takes 6 arguments: x1, y1, z1, x2, y2, z2
  # it returns a distance
  def distance_between(x1, y1, z1, x2, y2, z2):
    distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
    dist = sqrt(distsquared)
    return dist
  end
  
  # this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
  # it returns a point as a list of coordinates
  def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
    xf = xi + uvx * delta
    yf = yi + uvy * delta
    zf = zi + uvz * delta
    ret = [xf, yf, zf]
    return ret
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the bottom side of the gun facing up.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang(heading):
   axisxraw = -1 * sin(heading)
   axisyraw = cos(heading) + 1
   axiszraw = sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatup(heading):
   axisxraw = -sin(heading) + 1
   axisyraw = cos(heading)
   axiszraw = cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatdown(heading):
   axisxraw = -sin(heading) - 1
   axisyraw = cos(heading)
   axiszraw = -cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_ccw(heading):
   axisxraw = -sin(heading)
   axisyraw = cos(heading) - 1
   axiszraw = -sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function is for getting the points along the path of the corner homing 45
  # point0 is the point where they touched
  def get_corner_homing_45_pathpoints(point0, pointtop = p[0,0,0,0,0,0]):
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    p0rx = point0[3]
    p0ry = point0[4]
    p0rz = point0[5]
  
    #constants
    #distances of how far away from point the touchpoints are
    d0 = 0.10 # how far from the box to retreat and approach
    d1 = 0.06 # first distance from init point
    d2 = 0.15 # second distance from init point
    d3 = 0.125 #vertical distance from first point
    sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
    ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
    ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z+d1, 1.446, -0.8, -0.733]
    ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z+d1, 1.446, -0.8, -0.733]
    ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z+d1, 0.626, -1.993, -1.813]
    ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z+d1, 0.626, -1.993, -1.813]
  
    # go back to ph1
    ph6 = p[p0x + d0, p0y, p0z -0.05, 0, 0, pi] # approach point for under turn
    # moveL from ph1 to ph6
    ph7 = p[p0x-d1, p0y, p0z-0.05, 0, 0, pi]
  
    # add the vertical touch points
    if pointtop[2] == 0:
      ph2up = p[ph2[0], ph2[1], ph2[2]+d3, ph2[3], ph2[4], ph2[5]]
      ph4up = p[ph4[0], ph4[1], ph4[2]+d3, ph4[3], ph4[4], ph4[5]]
    elif pointtop[2] > p0z + 0.914: # 0.914m = 36 inches
      ph2up = p[ph2[0], ph2[1], p0z + 0.914, ph2[3], ph2[4], ph2[5]]
      ph4up = p[ph4[0], ph4[1], p0z + 0.914, ph4[3], ph4[4], ph4[5]]
    else:
      ph2up = p[ph2[0], ph2[1], pointtop[2], ph2[3], ph2[4], ph2[5]]
      ph4up = p[ph4[0], ph4[1], pointtop[2], ph4[3], ph4[4], ph4[5]]
    end
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph5, ph6=ph6, ph7=ph7, ph2up=ph2up, ph4up=ph4up)
    is_robot_at_reachable_spot(point0, ret)
    return ret
  end
  
  def get_corner_homing_45_pathpoints_cover(point0):
      p0x = point0[0]
      p0y = point0[1]
      p0z = point0[2]
      p0rx = point0[3]
      p0ry = point0[4]
      p0rz = point0[5]
  
      #constants
      #distances of how far away from point the touchpoints are
      d0 = 0.10 # how far from the box to retreat and approach
      d1 = 0.04 # first distance from init point
      d2 = 0.15 # second distance from init point
      d4 = 0.06 # top distance from init point - larger to avoid large chamfers
      sqrt2 = 0.707106781 # 1/sqrt(2) , the inverse of the sqrt(2)
  
      ph1 = p[p0x + d0, p0y, p0z + d1, p0rx, p0ry, p0rz] #approach point for turn
  
      ph2 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y+d0*0.5+sqrt2*d1, p0z-d1, 1.446, -0.8, -0.733]
      ph3 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y+d0*0.5+sqrt2*d2, p0z-d1, 1.446, -0.8, -0.733]
      ph4 = p[p0x+d0-d0*0.5-sqrt2*d1, p0y-d0*0.5-sqrt2*d1, p0z-d1, 0.626, -1.993, -1.813]
      #ph5 = p[p0x+d0-d0*0.5-sqrt2*d2, p0y-d0*0.5-sqrt2*d2, p0z-d1, 0.626, -1.993, -1.813]
  
      # approach point for top
      ph6 = p[p0x + d0 * 2, p0y, p0z+0.05, 0.138, 3.104, -0.072] # double the d0 in the x direction because it was getting VERY close to smacking the corner.
  
      # top point
      ph7 = p[p0x - d4, p0y, p0z+0.05, 0.138, 3.104, -0.072]
  
      ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4, ph5=ph4, ph6=ph6, ph7=ph7)
      is_robot_at_reachable_spot(point0, ret)
      return ret
  end
  
  # this function determines the starting touchpoints for homing in on cover straight geometry
  # includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
  def get_straight_homing_pathpoints_cover(leftpoint, rightpoint):
      # get the teach position points
      lpx = leftpoint[0]
      lpy = leftpoint[1]
      lpz = leftpoint[2]
      rpx = rightpoint[0]
      rpy = rightpoint[1]
      rpz = rightpoint[2]
  
      # specify the distances from
      d0 = 0.05 # how far from the planes to approach from
      d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
      d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
  
      # calculate the points (the rxryrz are given in pretend_welder_top coordinates. they match pure rotations of 90 degrees)
      ph1 = p[lpx + d0, lpy, lpz - d1, 1.209, -1.209, -1.209] # left side approach
      ph2 = p[rpx + d0, rpy, rpz - d1, 1.209, -1.209, -1.209] # right side approach
      ph3 = p[lpx - d2, lpy, lpz + d0, 2.221, -2.221, 0] # left top approach
      ph4 = p[rpx - d2, rpy, rpz + d0, 2.221, -2.221, 0] # right top approach
  
      ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
      is_robot_at_reachable_spot(leftpoint, ret)
      return ret
  end
  
  # this function determines the starting touchpoints for homing in on cover straight geometry
  # includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
  def get_straight_homing_pathpoints_floor(leftpoint, rightpoint):
      # get the teach position points
      lpx = leftpoint[0]
      lpy = leftpoint[1]
      lpz = leftpoint[2]
      rpx = rightpoint[0]
      rpy = rightpoint[1]
      rpz = rightpoint[2]
  
      # specify the distances from
      d0 = 0.05 # how far from the planes to approach from
      d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
      d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
  
      # calculate the points
      ph1 = p[lpx + d0, lpy, lpz + d1, 1.209, -1.209, -1.209] # left side approach
      ph2 = p[rpx + d0, rpy, rpz + d1, 1.209, -1.209, -1.209] # right side approach
      ph3 = p[lpx - d1, lpy, lpz - d0, 0, 0, 0] # left bottom approach
      ph4 = p[rpx - d1, rpy, rpz - d0, 0, 0, 0] # right bottom approach
  
      ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
      is_robot_at_reachable_spot(leftpoint, ret, 4)
      return ret
  end
  
  # this function checks whether the touchpoints are reachable AKA is the robot positioned in the right spot
  # if everything looks good, it continues.
  # if it detects a problem, it infinite loops a popup
  def is_robot_at_reachable_spot(point0, struct_touchpoints, structlength = 9):
    # first, check whether the corner is too low to the ground that the bottom homing will hit the ground (z < -400)
    lc_height = get_lift_column_height_condensed()
    # total height = zeroed lift column height (41.25 inches) (1.04775 m) plus lift column height plus robot relative height
    totalheight = 1.04775 + lc_height + point0[2]
    if totalheight < 1.04775 - 0.400:
      # bad
      popuptext = "Tank Corner is too low to the ground. Collisions will occur. Stop Program and raise tank. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
  
  
    # next, check whether the touchpoints are reachable
    allvalid = check_structofpoints_validity(struct_touchpoints)
    if not allvalid:
  
      # then unreachable
      # generate message
      listproblems = ""
      listnames = ["ph1", "ph2", "ph3", "ph4", "ph5", "ph6", "ph7", "ph2up", "ph4up"]
      i = 0
      # structlength = 9 # used to be a declare statement here. now it is a parameter. floor corner has 9. other features have less
      while i < structlength:
        curr = struct_touchpoints[i]
        valid = get_inverse_kin_has_solution(curr)
        if not valid:
          listproblems = listproblems + listnames[i]
        end
        i = i + 1
      end
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
  end
  
  # this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
  # this function does NOT check for weird twists or joint limits
  # inputstruct must contain only points
  # it returns true if all points are valid. it returns false if any points are valid
  # a list of length 0 indicates that all points are valid
  def check_structofpoints_validity(inputstruct):
    # next, check whether the touchpoints are reachable
    structlength = length(inputstruct)
    i = 0
    allvalid = True
    while i < structlength:
      curr = inputstruct[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        return False
      end
      i = i + 1
    end
    return True
  end
  
  # checks the validity of all points during a left weld
  # takes 2 arguments: struct1 (struct1[0] has to contain pointintersect) and struct2 (contains all the points (9) of the weld path)
  def check_validity_left(struct1, struct2):
    #first, check whether robot is too close
    pointintersect = struct1[0]
    # next, check if the corner is too close to the robot to do a left around weld (complex but approximately X > -1300)
    # if y < 0, then x < -1300. if y < 480, then y > (1300+x)*8. if y > 480, then y > (1235+x)*4 + 500
    toocloseleftweld = False
    if pointintersect[1] < 0:
      if pointintersect[0] > -1.300:
        toocloseleftweld = True
      end
    elif pointintersect[1] < 0.480:
      if pointintersect[1] < (1.300 + pointintersect[0])*8:
        toocloseleftweld = True
      end
    else:
      if pointintersect[1] < (1.235 + pointintersect[0])*4 + 0.500:
        toocloseleftweld = True
      end
    end
    if toocloseleftweld:
      # bad
      popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and move robot farther. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    #next, check whether all the points in the weldpath are valid
    structlength = 9
    i = 0
    allvalid = True
    listproblems = ""
    listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
    while i < structlength:
      curr = struct2[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        if i > 0:
          allvalid = False
          listproblems = listproblems + listnames[i]
        end
      end
      i = i + 1
    end
  
    if not allvalid:
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    # check whether the path involves weird turns or joint limits. currently just checks the first position
    p_prev = [-0.021118, -1.26292, 2.43578, 5.07088, -2.29912, 1.53362] #last point of left weld prerotate
    joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180
      difference = joint_curr - p_prev[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
  
    if not allGood:
      # call lift column extend function
      struct2 = floor_corner_lift_column_extend_left(struct2)
  
    end
  
    # return struct2 back
    return struct2
  end
  
  # checks the validity of all points during a right weld
  def check_validity_right(struct1, struct2):
    # first, check whether the right pivot will bonk itself
    pointintersect = struct1[0]
    heading1 = struct1[1] # this is the direction that the welder will face when doing the right side of the box
  
    #first, check whether the heading is just too far offset
    # more than 15 degrees off of 45 is too much
    # normal heading is 216 degrees
    #201 degrees to 231 degrees
    heading1degrees = heading1 * 180 / pi
    if heading1degrees < 201 or heading1degrees > 231 :
      # then out of range
      popuptext = "Robot is not aligned at a 45 degree angle of corner (15 degree leeway). Collisions may occur. Stop Program and align robot. heading1degrees=" + str_cat("",heading1degrees)
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    #TODO: add the checks for whether x is too close, given the heading
    # add checks for whether x is too close, given the heading
    # different equations for whether heading offset > 5 degrees or less (inc. negative)
    headingoffset = heading1degrees - 216
    if headingoffset < 5:
      # then calculate a and b
      a = 0.4584 + -0.02369 * headingoffset
      b = (-1151.4 + 13.83 * headingoffset) / 1000
      # check whether x > a*y+b
      if pointintersect[0] > a * pointintersect[1] + b:
        # bad
        popuptext = "Robot is too close to tank corner or not at the right angle. Collisions may occur. Stop Program and align robot. "
        # infinite loop
        while 1==1:
          popup(popuptext, title="Robot Positioning Warning",blocking=True)
        end
      end
    else:
      # headingoffset > 5 degrees
      if pointintersect[1] < 0:
        if pointintersect[0] > -1150.0 / 1000.0:
          #bad
          popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. "
          # infinite loop
          while 1==1:
            popup(popuptext, title="Robot Positioning Warning",blocking=True)
          end
        end
      else:
        # if x > .7736 y - 1101.9 then bad
        if pointintersect[0] > 0.7736 * pointintersect[1] - 1101.9 / 1000:
          popuptext = "Robot is too close to tank corner. Collisions may occur. Stop Program and align robot. "
          # infinite loop
          while 1==1:
            popup(popuptext, title="Robot Positioning Warning",blocking=True)
          end
        end
      end
    end
  
    #next, check whether all the points in the weldpath are valid
    structlength = 9
    i = 0
    allvalid = True
    listproblems = ""
    listnames = ["point1", "point2", "point4", "point5", "point_1", "point_2", "point_3", "point_4", "point_5"]
    while i < structlength:
      curr = struct2[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        if i > 0:
          allvalid = False
          listproblems = listproblems + listnames[i]
        end
      end
      i = i + 1
    end
  
    if not allvalid:
      # display
      popuptext = "Robot is too far from tank corner. Cannot reach some necessary positions. Stop Program and move robot closer. " + listproblems
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    end
  
    # check whether the path involves weird turns or joint limits. first position
    p_prev = [-1.13307, -1.48911, 2.84785, 4.92357, -4.89059, 1.57184] #last point of right weld prerotate
    joints_1 = get_inverse_kin(struct2[0], p_prev) # struct2[0] is point1
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180
      difference = joint_curr - p_prev[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
  
    if not allGood:
      struct2 = floor_corner_lift_column_extend_right(struct2)
    end
  
    # check whether the path involves weird turns or joint limits. final position (end of leg 3)
    joints_raa4 = [-0.8909156958209437, -1.3431089532426377, 2.273750130330221, 0.7266384798237304, 1.5611975193023682, 1.8127720355987549]
    joints_p_3 = get_inverse_kin(struct2[6], joints_raa4) # struct2[6] is p_3
    joints_p_4 = get_inverse_kin(struct2[7], joints_p_3) # struct2[7] is p_4
    joints_p_5 = get_inverse_kin(struct2[8], joints_p_4) # struct2[8] is p_5
    joints_1 = joints_p_5
    p_prev = joints_p_4
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180
      difference = joint_curr - p_prev[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
  
    if not allGood:
      struct2 = floor_corner_right_p_3_reduce(struct2)
    end
  
    # return struct2 back
    return struct2
  end
  
  def floor_corner_lift_column_extend_right(struct2):
    # we know that p1 cannot be accessed without a twist
    # calculate the height needed to get to p1
    liftcolumnincrement = 2.0 # mm
    enoughHeightAdded = False
    liftColumnHeightTest = 0
    while not enoughHeightAdded:
      liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
      # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
      # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
      orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
      # get the modified point:
      origp1 = struct2[0]
      testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000.0, origp1[3], origp1[4], origp1[5]]
      testpa1 = p[origp1[0]+0.05, origp1[1]+0.05, origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
      enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints) and can_pose_be_reached_without_twist(testpa1, orig_joints)
    end
  
    origp2 = struct2[1]
    testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000.0, origp2[3], origp2[4], origp2[5]]
    origp4 = struct2[2]
    testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
    origp5 = struct2[3]
    testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
  
  
  
    liftcolumnzneeded = liftColumnHeightTest
    ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
    return ret
  
  end
  
  # this function gets called if you are doing a left floor corner extended, and the top is too high to reach (twists, etc.)
  # this function takes the struct2 of weld points and modifies them (by subtracting from z) until the first weld point is reachable.
  # it determines the height that the lift column needs to raise to make the first point reachable
  # it then checks whether that height will allow the other points to be reachable
  # if its all good, it sets the global variable liftcolumnzneeded, modifies struct2's points, and returns struct2
  # if its not all good, then it displays an error message popup.
  def floor_corner_lift_column_extend_left(struct2):
    # we know that p1 cannot be accessed without a twist
    # calculate the height needed to get to p1
    liftcolumnincrement = 2 # mm
    enoughHeightAdded = False
    liftColumnHeightTest = 0
    while not enoughHeightAdded:
      liftColumnHeightTest = liftColumnHeightTest + liftcolumnincrement
      # set the orig_joints for p1. p1 demo was joint angles of [-0.45, -31.79, 56.47, 333.06, -130.98, 87.87] (degrees)
      # which equals [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
      orig_joints = [-0.007853981633974475, -0.5548401692089968, 0.985587428601197, 5.812993606692308, -2.28603225426217, 1.5336208137274159]
      # get the modified point:
      origp1 = struct2[0]
      testp1 = p[origp1[0], origp1[1], origp1[2] - liftColumnHeightTest / 1000, origp1[3], origp1[4], origp1[5]]
      enoughHeightAdded = can_pose_be_reached_without_twist(testp1, orig_joints)
    end
  
  
    # check whether the other 3 points are valid
    valid = True
    # get the modified point
    origp2 = struct2[1]
    testp2 = p[origp2[0], origp2[1], origp2[2] - liftColumnHeightTest / 1000, origp2[3], origp2[4], origp2[5]]
    # p2 demo was joint angles of [-0.45, -21.2, 56.98, 321.95, -130.97, 87.85] (degrees)
    # which equals [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
    orig_joints = [-0.007853981633974475, -0.3700098014227975, 0.9944886077863679, 5.619087526795738, -2.285857721336971, 1.5332717478770168]
    valid = valid and can_pose_be_reached_without_twist(testp2, orig_joints)
    # get the modified point
    origp4 = struct2[2]
    testp4 = p[origp4[0], origp4[1], origp4[2] - liftColumnHeightTest / 1000, origp4[3], origp4[4], origp4[5]]
    # p4 demo was joint angles of [-8.62, -43.23, 99.53, 213.86, -89.19, 40.78] (degrees)
    # which equals [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
    orig_joints = [-0.15044738152191103, -0.7545058356371478, 1.7371262045099545, 3.7325611383150696, -1.556659159853741, 0.7117452689632868]
    valid = valid and can_pose_be_reached_without_twist(testp4, orig_joints)
    # get the modified point
    origp5 = struct2[3]
    testp5 = p[origp5[0], origp5[1], origp5[2] - liftColumnHeightTest / 1000, origp5[3], origp5[4], origp5[5]]
    # p5 demo was joint angles of [-0.59, -34.36, 77.71, 226.7, -89.18, 48.81] (degrees)
    # which equals [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
    orig_joints = [-0.010297442586766533, -0.5996951309852511, 1.356295361724792, 3.9566614142711405, -1.5564846269285415, 0.8518952078984314]
    valid = valid and can_pose_be_reached_without_twist(testp5, orig_joints)
  
    if not valid:
      # display
      popuptext = "Top of Weld is too high above robot. Cannot reach some necessary positions. Stop Program and try again with a lower top point. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Robot Positioning Warning",blocking=True)
      end
    else:
      liftcolumnzneeded = liftColumnHeightTest
      ret = struct(point1=testp1,point2=testp2,point4=testp4,point5=testp5,point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=struct2[8])
      return ret
    end
  end
  
  # this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
  # arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
  # returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
  def can_pose_be_reached_without_twist(pose, orig_joints):
    # first, determine if the pose is valid
    valid = get_inverse_kin_has_solution(pose)
    if not valid:
      return False
    end
    valid = get_inverse_kin_has_solution(pose, orig_joints)
    if not valid:
      return False
    else:
      joints_1 = get_inverse_kin(pose, orig_joints)
      #iterate through the 6 joints
      allGood = True
      i = 0
      structlength = 6
      while i < structlength:
        joint_curr = joints_1[i]
        # check for anything that exceeds joint limits
        degreesmax = 360 * pi / 180
        if joint_curr > degreesmax or joint_curr < degreesmax * -1:
          allGood = False
        end
        # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
        maxdifference = 150 * pi / 180
        difference = joint_curr - orig_joints[i]
        if difference > maxdifference or difference * -1 > maxdifference:
          allGood = False
        end
        i = i + 1
      end
      return allGood
    end
  
  end
  
  def floor_corner_right_p_3_reduce(struct2, orig_joints):
    # we know that p_5 cannot be accessed without a twist
    # calculate the distance p_5 needs to be changed (in the direction of p_4)
  
    #calculate unit vector from p_5 towards p_4
    point_4 = struct2[7]
    point_5 = struct2[8]
    vecx = point_4[0] - point_5[0]
    vecy = point_4[1] - point_5[1]
    vecz = point_4[2] - point_5[2]
    mag = sqrt(vecx*vecx + vecy*vecy + vecz*vecz)
    uvx = vecx / mag
    uvy = vecy / mag
    uvz = vecz / mag
  
    moveincrement = 2.0 # mm
    enoughMoveAdded = False
    movement = 0
  
    while not enoughMoveAdded:
      movement = movement + moveincrement
      # set the orig_joints for p_4. p1 was calculated and passed into this function
      # get the modified point:
      testp_5 = p[point_5[0] + uvx*movement, point_5[1] + uvy*movement, point_5[2] + uvz*movement, point_5[3], point_5[4], point_5[5]]
      enoughMoveAdded = can_pose_be_reached_without_twist(testp_5, orig_joints)
    end
  
    ret = struct(point1=struct2[0],point2=struct2[1],point4=struct2[2],point5=struct2[3],point_1=struct2[4],point_2=struct2[5],point_3=struct2[6],point_4=struct2[7],point_5=testp_5)
    return ret
  end
  
  # this function sends a signal to turn extrusion on
  def turn_extrusion_on():
    # flush the channel
    resp0 = send_serial_signal(["u", "r", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "R", "1"])
    # if resp <> "uR1"
    if resp1 != [252,82,49]:
      # turn off extrusion and heating. inform calvin
      resp2 = send_serial_signal(["u", "R", "0"])
      resp3 = send_serial_signal(["u", "H", "0"])
      popuptext = "Error code encountered while trying to start extrusion. Find Calvin. "
      while 1==1:
        popup(popuptext, title="Extrusion Error Code",blocking=True)
        popup(resp1, blocking=True)
      end
    end
  end
  
  # this function sends a signal and receives a response
  # signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
  def send_serial_signal(signal):
    signal2char = signal[1]
    signal3char = signal[2]
    listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
    resp1 = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", listsignal, True)
    return resp1
  end
  
  # this function converts a letter into its ascii number
  def get_corr_number(letter):
    if letter == "A":
      return 65
    elif letter == "H":
      return 72
    elif letter == "R":
      return 82
    elif letter == "M":
      return 77
    elif letter == "E":
      return 69
    elif letter == "a":
      return 97
    elif letter == "b":
      return 98
    elif letter == "h":
      return 104
    elif letter == "r":
      return 114
    elif letter == "s":
      return 115
    elif letter == "m":
      return 109
    elif letter == "0":
      return 48
    elif letter == "1":
      return 49
    elif letter == "2":
      return 50
    elif letter == "3":
      return 51
    elif letter == "4":
      return 52
    elif letter == "5":
      return 53
    elif letter == "6":
      return 54
    elif letter == "7":
      return 55
    elif letter == "8":
      return 56
    elif letter == "9":
      return 57
    elif letter == "?":
      return 63
    end
  end
  
  # this function checks whether the welder is in the ready state.
  # to be called at the beginning of Main Program
  def welder_state_ready():
    # flush the channel
    resp0 = send_serial_signal(["u", "s", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "s", "?"])
    # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
    if resp1 != [252,115,49]:
      popuptext = "Welder is not ready for extrusion. Follow the instructions to start heating welder. "
      while 1==1:
        popup(popuptext, title="Welder Not Ready",blocking=True)
      end
    end
  
  end
  
  def get_lift_column_height():
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    #$ 5 "MachineLogic Get Position"
    while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
        if temp_estop_var_vention=="estop/status true":
          sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
        end
        socket_send_string("estop/status;", "MachineMotion1")
        temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
        if temp_estop_var_vention=="estop/status true":
          popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
        end
      end
    else:
      popup("resource is being used already: MachineMotion1")
      halt
    end
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    global var_1 = temp_drive[1]
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
  end
  
  def get_lift_column_height_condensed():
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    ret = temp_drive[1]
    return ret
  end
  
  # this function takes two rotation matrices, and multiplies them together, returning one matrix.
  # all matrices are in the form of a list.
  # all matrix values have constant values (no variables)
  def multiply_matrix(matrix1, matrix2):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
      b11 = matrix2[0]
      b12 = matrix2[1]
      b13 = matrix2[2]
      b21 = matrix2[3]
      b22 = matrix2[4]
      b23 = matrix2[5]
      b31 = matrix2[6]
      b32 = matrix2[7]
      b33 = matrix2[8]
      #calculate c values
      c11 = a11*b11 + a12*b21 + a13*b31
      c12 = a11*b12 + a12*b22 + a13*b32
      c13 = a11*b13 + a12*b23 + a13*b33
      c21 = a21*b11 + a22*b21 + a23*b31
      c22 = a21*b12 + a22*b22 + a23*b32
      c23 = a21*b13 + a22*b23 + a23*b33
      c31 = a31*b11 + a32*b21 + a33*b31
      c32 = a31*b12 + a32*b22 + a33*b32
      c33 = a31*b13 + a32*b23 + a33*b33
      # return resulting matrix
      ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
      return ret
  end
  
  # this function converts a matrix to axis angle representations
  # this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
  # returns a list of [rx,ry,rz]
  def convert_matrix_to_axang(matrix1):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
  
      # First Half: find the angle
      # find the trace
      # using the formula: trace = a11 + a22 + a33
      trace = a11 + a22 + a33
      # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
      angle = acos((trace - 1.0)/2.0)
  
      # Second Half: calculate the rotation axis
      axisxraw = a32 - a23
      axisyraw = a13 - a31
      axiszraw = a21 - a12
      # normalize axis
      magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
      axisxunit = axisxraw / magnitude
      axisyunit = axisyraw / magnitude
      axiszunit = axiszraw / magnitude
  
      # combine axis and angle into rxryrz representation
      rxout = axisxunit * angle
      ryout = axisyunit * angle
      rzout = axiszunit * angle
      return [rxout, ryout, rzout]
  end
  
  # this function takes a rotation and calculates the corresponding rotation matrix
  # input is (axis, direction, angle in radians)
  # example is ("x", 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
  # returns a matrix (a list of 9 values)
  def get_rotation_matrix_from_description(axis, direction, angle):
      # get the angle
      a = angle * direction
      # get the axis
      if axis == "x" or axis == "X":
          matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
          return matrix
      end
      if axis == "y" or axis == "Y":
          matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
          return matrix
      end
      if axis == "z" or axis == "Z":
          matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
          return matrix
      end
      # bad
      popuptext = "Error in get_rotation_matrix_from_description. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Code Error",blocking=True)
      end
  end
  
  # this function takes in a struct of only points. it checks those points for validity.
  # if one of them is not valid, it throws a popup loop
  def check_validity_only(struct2):
      validity = check_structofpoints_validity(struct2)
      if not validity:
      # bad
      popuptext = "Not all weldpoints are valid. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Position Error",blocking=True)
      end
      end
  end
  
  def main_calculate_step(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top, leftseam, leftobstacle):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      if leftseam:
          if leftobstacle:
              struct2 = calculate_LtUA_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
              heading1deg = struct1[1] * 180/pi
              if heading1deg < 210:
                  popup("Robot is not aligned 45 degree angle from corner. Wrist pinch may bonk, Align robot 45 degrees from corner and try again. ", title="Alignment Error",blocking=True)
              end
          else:
              struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
          end
      else:
          if leftobstacle:
              # error: this geometry is impossible for the robot to weld
              popup("Cannot weld a right seam, left obstacle step corner with robot. please weld by hand. ", title="Geometry Error",blocking=True)
          else:
              struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
          end
      end
      validity = check_validity_only(struct2)
      return struct2
  end
  
  def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
      struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
      list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
      #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
      #validity = check_validity_right(struct1, struct2)
      struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
      validity = check_validity_only(struct2)
      return struct2
  end
  
  # analyze_touchpoints_only()
  # it takes 5 arguments as points
  # it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
  #   FIND HEADINGS
  #for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
  # so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box.
  # we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
  def step_right_demo(struct1):
      pointintersect = struct1[0]
      x = pointintersect[0]
      y = pointintersect[1]
      z = pointintersect[2]
      heading1 = struct1[1]
      heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
      heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
      # heading1 == heading1adj2. ok
      m1 = get_rotation_matrix_from_description("z", 1, heading1)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
      popup(point_demo)
      movej(point_demo, a=1.4, v=0.1)
      popup(point_demo)
      ret = struct(point_demo = point_demo)
      return ret
  end
  
  # for a left seam step corner, calculate the toolpath points for a L (under) then Up and Around weld. for left obstacle step.
  def calculate_LtUA_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 3 # first path first leg
      welddistance2 = 3 # first path second leg
      welddistance3 = 8 # vertical weld distance
  
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = tcp_pose_top[2] - pointintersect[2] # the z distance from the corner to the top of the weld
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
  
      # point bottom (point of intersection of the two chamfers on the bottom)
      xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
      ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
      z = pointintersect[2]
  
      # point 1
      x = xbottom + l1delxunit * wd1
      y = ybottom + l1delyunit * wd1
  
      # get rxryrz for facing along towards the intersection. heading1 +90 deg - 90 deg
      m1 = get_rotation_matrix_from_description("z", 1, heading1)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point1 = p[x, y, z, rx, ry, rz]
  
      # point 2
      point2 = p[xbottom, ybottom, z, rx, ry, rz]
  
      # point 4
      # get rxryrz for facing along the second edge pointed toward the left. heading 3 + 90 - 90
      m1 = get_rotation_matrix_from_description("z", 1, heading3)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point4 = p[xbottom, ybottom, z, rx, ry, rz]
  
      # point 5
      x = xbottom + l2delxunit * wd2
      y = ybottom + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
      # now calculate the points of the Up Around
      # don't use heading3 at all.
      #point201 is at the chamfer intersection
      p201x = xbottom
      p201y = ybottom
      p201z = z
  
      # rxryrz is the same
      m1 = get_rotation_matrix_from_description("z", 1, heading1)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point201 = p[p201x, p201y, p201z, rx, ry, rz]
  
      # find side point (point on the side. where point 203 would be if roundoverdistance was 0)
      sidex = pointintersect[0] + l2delxunit * rightwallthickmm
      sidey = pointintersect[1] + l2delyunit * rightwallthickmm
      sidez = z
  
      # p202
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
      p202x = sidex + rod * l1delxunit
      p202y = sidey + rod * l1delyunit
      p202z = sidez
      point202 = p[p202x, p202y, p202z, rx, ry, rz]
  
      # p204 end of circle move
      p204x = sidex
      p204y = sidey
      p204z = sidez + rod
  
      # calculate rxryrz
      # first rotation: 90 degrees about x axis. positive direction. preheat is now facing up, and gun tip is pointed towards y- direction
      m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
      # second rotation: rotate about z until you are facing into the front face. but only use heading 1
      # heading 1 is about 225 degrees. i need to go about 225 degrees. starting from y- instead of x+ cancels out the extra 90 degrees needed to go into face1 instead of parallel to face1
      m2 = get_rotation_matrix_from_description("z", 1, heading1)
      m3 = multiply_matrix(m2, m1)
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point204 = p[p204x, p204y, p204z, rx, ry, rz]
  
      #p205 (end of straight after cirlce move, before listleans
      straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
      sld = straightlength * 25.4 / 1000
      point205 = p[p204x, p204y, sidez + sld, rx, ry, rz]
  
      #p206 (top of weld)
      p206x = sidex + wd3 * listleans[0]
      p206y = sidey + wd3 * listleans[1]
      p206z = sidez + wd3
      point206 = p[p206x, p206y, p206z, rx, ry, rz]
  
      # p203 (middle of turn)
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p203z = sidez + delta
      p203x = sidex + delta * l1delxunit
      p203y = sidey + delta * l1delyunit
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("x", 1, 45 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1)
      m3 = multiply_matrix(m2, m1)
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point203 = p[p203x, p203y, p203z, rx, ry, rz]
  
      # form struct
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point201=point201, point202=point202, point203=point203, point204=point204, point205=point205, point206=point206)
      return struct2
  end
  
  # for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld.
  def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 3 # first path first leg
      welddistance2 = 3 # first path second leg
      welddistance3 = 8 # vertical weld distance
  
      # inches
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
  
      # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
      #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
  
      # point bottom (point of intersection of the two chamfers on the bottom)
      xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
      ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
      z = pointintersect[2]
  
      # point 1
      x = xbottom + l1delxunit * wd1
      y = ybottom + l1delyunit * wd1
  
      m1 = get_rotation_matrix_from_description("z", 1, heading1)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point1 = p[x, y, z, rx, ry, rz]
  
      # point 2
      point2 = p[xbottom, ybottom, z, rx, ry, rz]
  
      # point 4
      m1 = get_rotation_matrix_from_description("z", 1, heading3)
      # at this point we would multiply matrices, but there is only one matrix
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point4 = p[xbottom, ybottom, z, rx, ry, rz]
  
      # point 5
      x = xbottom + l2delxunit * wd2
      y = ybottom + l2delyunit * wd2
      point5 = p[x, y, z, rx, ry, rz]
  
  
      # form struct
      struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
      return struct2
  end
  
  # step corner with two seams on bottom face
  # vertical seam on left side of corner
  # Down Around and Under weld path, then Back Away
  # the first path uses backofhole TCP, the second path uses pretend_welder TCP
  def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # first path first leg (down)
      welddistance2 = 3 # first path second leg (under) # inches
      welddistance3 = 3 # second path (back away) # inches
  
      wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
      # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren't any circle motion
      x = pointintersect[0] + l2delxunit * rightwallthickmm
      y = pointintersect[1] + l2delyunit * rightwallthickmm
      z = pointintersect[2]
      pointbottomvcham = p[x, y, z, 0, 0, 0]
  
      # calculate the rxryrz for facing the vertical chamfer, with the preheat down
      rxryrz = convert_heading_to_axang_preheatdown(heading3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # next, calculate point1 using the listleans
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
  
      # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1
      # only use the right side taps for circle move related things
      heading3basedh1 = heading1 - pi/2 # heading1 based on heading3
      rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
      point2 = p[x, y, z + rod, rx, ry, rz]
  
      # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
      straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
      sld = straightlength * 25.4 / 1000
      point2a = p[x, y, z + sld, rx, ry, rz]
  
      # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
      # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
      heading1descr = heading1 - pi
      m1 = get_rotation_matrix_from_description("z", 1, heading1descr)
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate point4
      p4x = x + l1delxunit * rod
      p4y = y + l1delyunit * rod
      point4 = p[p4x, p4y, z, rx, ry, rz]
  
      # calculate point5
      p5x = x + l1delxunit * wd2
      p5y = y + l1delyunit * wd2
      point5 = p[p5x, p5y, z, rx, ry, rz]
  
      # calculate point3
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p3z = z + delta
      p3x = x + delta * l1delxunit
      p3y = y + delta * l1delyunit
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("x", -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1descr) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      #todo: calculate trail out point
  
      # calculate back-away (points 201 and 202)
      pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
      p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
      p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("z", 1, heading3)
      # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point201 = p[p201x, p201y, z, rx, ry, rz]
  
      # calculate point 202
      p202x = p201x + wd3 * l2delxunit
      p202y = p201y + wd3 * l2delyunit
      point202 = p[p202x, p202y, z, rx, ry, rz]
  
      struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
      return struct2
  end
  
  # step corner with two seams on bottom face
  # vertical seam on right side of corner
  # Down Around and Under weld path, then Back Away
  # the first path uses backofhole TCP, the second path uses pretend_welder TCP
  def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 8 # first path first leg (down)
      welddistance2 = 3 # first path second leg (under) # inches
      welddistance3 = 3 # second path (back away) # inches
  
      wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
      # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren't any circle motion
      x = pointintersect[0] + l1delxunit * leftwallthickmm
      y = pointintersect[1] + l1delyunit * leftwallthickmm
      z = pointintersect[2]
      pointbottomvcham = p[x, y, z, 0, 0, 0]
  
      # calculate the rxryrz for facing the vertical chamfer, with the preheat down
      rxryrz = convert_heading_to_axang_preheatdown(heading1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # next, calculate point1 using the listleans
      point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
  
      # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1
      # only use the left side taps for circle move related things
      heading1basedh3 = heading3 + pi/2 # heading1 based on heading3
      rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
      point2 = p[x, y, z + rod, rx, ry, rz]
  
      # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
      straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
      sld = straightlength * 25.4 / 1000
      point2a = p[x, y, z + sld, rx, ry, rz]
  
  
      # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
      m1 = get_rotation_matrix_from_description("z", 1, heading3)
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate point4
      p4x = x + l2delxunit * rod
      p4y = y + l2delyunit * rod
      point4 = p[p4x, p4y, z, rx, ry, rz]
  
      # calculate point5
      p5x = x + l2delxunit * wd2
      p5y = y + l2delyunit * wd2
      point5 = p[p5x, p5y, z, rx, ry, rz]
  
      # calculate point3
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p3z = z + delta
      p3x = x + delta * l2delxunit
      p3y = y + delta * l2delyunit
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("x", -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      #todo: calculate trail out point
  
      # calculate back-away (points 201 and 202)
      pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
      p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
      p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("z", 1, heading1 - pi)
      # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
      rxryrz = convert_matrix_to_axang(m1)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point201 = p[p201x, p201y, z, rx, ry, rz]
  
      # calculate point 202
      p202x = p201x + wd3 * l1delxunit
      p202y = p201y + wd3 * l1delyunit
      point202 = p[p202x, p202y, z, rx, ry, rz]
  
      struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
      return struct2
  end
  
  # given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
  # returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
  def calc_rod_midpoint_90deg(rod):
      # the factor is (1- 1/sqrt(2))
      factor = 0.292893
      ret = rod * factor
      return ret
  end
  
  # this is the main entry point for calculations, for Cover Corner.
  # it takes in the 4 touchpoints, analyzes the shape of the box.
  # returns the pathpoints
  # specifically for Around and Down then Straight (AtS)
  # specifically for left-sided boxes (vertical weld on left side of edge)
  # leftchoice is a boolean and deepcovercham is a boolean but leftwallthick, rightwallthick are decimals in inches.
  def main_calculate_cover(p11, p12, p21, p3, leftwallthick, rightwallthick, leftchoice, deepcovercham):
      struct1 = analyze_touchpoints_only_cover(p11, p12, p21, p3)
      if leftchoice:
          struct2 = calculate_LtAD_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham)
      else:
          struct2 = calculate_LtAD_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham)
      end
      #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      #struct3 = check_validity_left(struct1, struct2)
      return struct2
  end
  
  def calculate_AtS_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 6 # first path first leg (down)
      welddistance2 = 3 # first path second leg (under) # inches
      welddistance3 = 6 # second path (back away) # inches
  
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
      if deepcovercham:
          deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches.
      else:
          deepchambumpmm = 0.0
      end
  
      # first, check if we need a lift column raise
      # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
      zpi = pointintersect[2]
      if zpi > 0:
          liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
          z = 0
      else:
          z = zpi
      end
  
      # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren't any circle motion)
      x = pointintersect[0] + l2delxunit * rightwallthickmm
      y = pointintersect[1] + l2delyunit * rightwallthickmm
      #z = pointintersect[2] # replaced by z of lift column (directly above)
      pointtopvcham = p[x, y, z, 0, 0, 0]
  
      # calculate the rxryrz for the gun when it's at point1
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # next, calculate point1 (start point on top of cover welding towards corner)
      p1x = x + l1delxunit * wd1 + deepchambumpmm * l2delxunit
      p1y = y + l1delyunit * wd1 + deepchambumpmm * l2delyunit
      point1 = p[p1x, p1y, z, rx, ry, rz]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
      p2x = x + l1delxunit * rod
      p2y = y + l1delyunit * rod
      point2 = p[p2x, p2y, z, rx, ry, rz]
  
      # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
      shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2.
      if deepcovercham:
          speed = 6 # mm/s
          wtod = shutofftime * speed / 1000 #weldturnoffdistance
      else:
          speed = 10 # mm/s
          wtod = shutofftime * speed / 1000
      end
      p2ax = x + l1delxunit * wtod
      p2ay = y + l1delyunit * wtod
      point2a = p[p2ax, p2ay, z, rx, ry, rz]
  
      # calculate the rxryrz for facing the down the left side of the box
      # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate point4
      point4 = p[x, y, z - rod, rx, ry, rz]
  
      # calculate point5
      point5 = p[x, y, z - wd2, rx, ry, rz]
  
      # calculate point3
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p3z = z - delta
      p3x = x + delta * l1delxunit
      p3y = y + delta * l1delyunit
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("x", -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx3 = rxryrz[0]
      ry3 = rxryrz[1]
      rz3 = rxryrz[2]
      point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
  
      #todo: calculate trail out points
      botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
      tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
      # calculate point5a (point101) (start of tilt back) (start of unflatten)
      dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
      p101x = x
      p101y = y
      p101z = z - wd2 + dist
      point101 = p[p101x, p101y, p101z, rx, ry, rz]
  
      # calculate point5b (point 102) (end of unflatten)
      dist = 0.5 * 25.4 / 1000
      tiltraise = 0.006
      p102x = x + l1delxunit * tiltraise * -1
      p102y = y + l1delyunit * tiltraise * -1
      p102z = z - wd2 + dist
  
      # calculate rxryrz
      tiltangledeg = 10 # ten degree angle of tilt
      m1 = get_rotation_matrix_from_description("x", -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point102 = p[p102x, p102y, p102z, rx, ry, rz]
  
      # calculate point 5c (point 103) (end of smear)
      dist = -2 * 25.4/1000
      point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
  
      # calculate back-away (points 201 and 202)
      pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
      p201x = x + l1delxunit * (leftwallthickmm + deepchambumpmm) + l2delxunit * pushtipforward
      p201y = y + l1delyunit * (leftwallthickmm + deepchambumpmm) + l2delyunit * pushtipforward
  
      # calculate rxryrz
      # rotate 180 degrees about x. then rotate (90 deg + heading3 degrees) about z ccw
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading3 + pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point201 = p[p201x, p201y, z, rx, ry, rz]
  
      # calculate point 201's preheat
      pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
      preheatdistance = 0.010 # 10 mm . above what it would be pushed down
      point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
      p201bx = p201x + l2delxunit * pushtipforward2
      p201by = p201y + l2delyunit * pushtipforward2
      point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
      point201c = p[p201bx, p201by, z, rx, ry, rz]
  
      # calculate point 202
      p202x = p201x + wd3 * l2delxunit
      p202y = p201y + wd3 * l2delyunit
      point202 = p[p202x, p202y, z, rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
      return struct2
  end
  
  def calculate_AtS_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham):
      # get the stuff from the struct
      pointintersect = struct1[0]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
      # find locations 8 inches away from  intersect point
      # CONST
      welddistance1 = 6 # first path first leg (down)
      welddistance2 = 3 # first path second leg (under) # inches
      welddistance3 = 6 # second path (back away) # inches
  
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
      if deepcovercham:
          deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches.
      else:
          deepchambumpmm = 0.0
      end
  
      # first, check if we need a lift column raise
      # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
      zpi = pointintersect[2]
      if zpi > 0:
          liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
          z = 0
      else:
          z = zpi
      end
  
      # first, calculate the location of the top of the vertical chamfer (where point2 would be if there weren't any circle motion)
      x = pointintersect[0] + l1delxunit * leftwallthickmm
      y = pointintersect[1] + l1delyunit * leftwallthickmm
      #z = pointintersect[2] # replaced by z of lift column (directly above)
      pointtopvcham = p[x, y, z, 0, 0, 0]
  
      # calculate the rxryrz for the gun when it's at point1
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # next, calculate point1 (start point on top of cover welding towards corner)
      p1x = x + l2delxunit * wd1 + deepchambumpmm * l1delxunit
      p1y = y + l2delyunit * wd1 + deepchambumpmm * l1delyunit
      point1 = p[p1x, p1y, z, rx, ry, rz]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
      p2x = x + l2delxunit * rod
      p2y = y + l2delyunit * rod
      point2 = p[p2x, p2y, z, rx, ry, rz]
  
      # make point2a, colinear between p1 and p2, which will be the place the welder shuts off during motion
      shutofftime = 1.5 # seconds. this is how soon to shut off extrusion before we hit point 2.
      if deepcovercham:
          speed = 6 # mm/s
          wtod = shutofftime * speed / 1000 #weldturnoffdistance
      else:
          speed = 10 # mm/s
          wtod = shutofftime * speed / 1000
      end
      p2ax = x + l2delxunit * wtod
      p2ay = y + l2delyunit * wtod
      point2a = p[p2ax, p2ay, z, rx, ry, rz]
  
      # calculate the rxryrz for facing the down the right side of the box
      # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate point4
      point4 = p[x, y, z - rod, rx, ry, rz]
  
      # calculate point5
      point5 = p[x, y, z - wd2, rx, ry, rz]
  
      # calculate point3
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p3z = z - delta
      p3x = x + delta * l2delxunit
      p3y = y + delta * l2delyunit
  
      # calculate rxryrz
      m1 = get_rotation_matrix_from_description("x", -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx3 = rxryrz[0]
      ry3 = rxryrz[1]
      rz3 = rxryrz[2]
      point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
  
      #todo: calculate trail out point
      botvcham = wd2 # where is the bottom of the v chamfer (z distance from top corner)
      tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
      # calculate point5a (point101) (start of tilt back) (start of unflatten)
      dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
      p101x = x
      p101y = y
      p101z = z - wd2 + dist
      point101 = p[p101x, p101y, p101z, rx, ry, rz]
  
      # calculate point5b (point 102) (end of unflatten)
      dist = 0.5 * 25.4 / 1000
      tiltraise = 0.006
      p102x = x + l2delxunit * tiltraise * -1
      p102y = y + l2delyunit * tiltraise * -1
      p102z = z - wd2 + dist
  
      # calculate rxryrz
      tiltangledeg = 10 # ten degree angle of tilt
      m1 = get_rotation_matrix_from_description("x", -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point102 = p[p102x, p102y, p102z, rx, ry, rz]
  
      # calculate point 5c (point 103) (end of smear)
      dist = -2 * 25.4/1000
      point103 = p[p102x, p102y, z - wd2 + dist, rx, ry, rz]
  
      # calculate back-away (points 201 and 202)
      pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
      p201x = x + l2delxunit * (rightwallthickmm + deepchambumpmm) + l1delxunit * pushtipforward
      p201y = y + l2delyunit * (rightwallthickmm + deepchambumpmm) + l1delyunit * pushtipforward
  
      # calculate rxryrz
      # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1 + pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point201 = p[p201x, p201y, z, rx, ry, rz]
  
      # calculate point 201's preheat
      pushtipforward2 = 0.012 - pushtipforward + deepchambumpmm # 12 mm forward to clear the existing extrudant (but still have the extrudant from this extrusion join the existing). subtract from previous to make it constant even if you change pushtipforward1
      preheatdistance = 0.010 # 10 mm . above what it would be pushed down
      point201a = p[p201x, p201y, z + preheatdistance, rx, ry, rz]
      p201bx = p201x + l1delxunit * pushtipforward2
      p201by = p201y + l1delyunit * pushtipforward2
      point201b = p[p201bx, p201by, z + preheatdistance, rx, ry, rz]
      point201c = p[p201bx, p201by, z, rx, ry, rz]
  
      # calculate point 202
      p202x = p201x + wd3 * l1delxunit
      p202y = p201y + wd3 * l1delyunit
      point202 = p[p202x, p202y, z, rx, ry, rz]
  
      struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202, point201a=point201a, point201b=point201b, point201c=point201c, point2a=point2a, point101=point101, point102=point102, point103=point103)
      return struct2
  end
  
  def calculate_LtAD_points_cover_left(struct1, leftwallthick, rightwallthick, deepcovercham):
      # get the stuff from the struct
      pointintersect = struct1[0]
      x0 = pointintersect[0]
      y0 = pointintersect[1]
      z0 = pointintersect[2]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # CONST
      welddistance1 = 6 # first path first leg (left side of L)
      welddistance2 = 6 # first path second leg (Right Side of L) # inches
      welddistance3 = 3 # second path (down sidewall) # inches
  
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
      if deepcovercham:
          deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches.
      else:
          deepchambumpmm = 0.0
      end
  
      # first, check if we need a lift column raise
      # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
      zpi = pointintersect[2]
      if zpi > 0:
          liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
          z0 = 0
      else:
          z0 = zpi
      end
  
      # first and second path
  
      # calculate rxryrz1 (facing down, preheat rightish)
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis)
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz1 = convert_matrix_to_axang(m3)
      rx1 = rxryrz1[0]
      ry1 = rxryrz1[1]
      rz1 = rxryrz1[2]
  
      # calculate rxryrz2 (gun facing down, preheat facing right and back)
      # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1 + pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz2 = convert_matrix_to_axang(m3)
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      # calculate point centerchamfers (where the center of the two chamfers intersect
      pcx = x0 + (leftwallthickmm + deepchambumpmm) * l1delxunit + (rightwallthickmm + deepchambumpmm) * l2delxunit
      pcy = y0 + (leftwallthickmm + deepchambumpmm) * l1delyunit + (rightwallthickmm + deepchambumpmm) * l2delyunit
      pcz = z0
  
      # calculate point1 (start of weld)
      p1x = pcx + l2delxunit * wd1
      p1y = pcy + l2delyunit * wd1
      p1z = pcz
      point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
  
      # calculate point2 (end of segment 1)
      p2x = pcx
      p2y = pcy
      p2z = pcz
      point2 = p[p2x, p2y, p2z, rx1, ry1, rz1]
  
      # calculate point3 (point at end of turn)
      slide = 0.00 # slide distance : the distance the tip slides forward as it turns
      p3x = pcx + slide * l1delxunit
      p3y = pcy + slide * l1delyunit
      p3z = pcz
      point3 = p[p3x, p3y, p3z, rx2, ry2, rz2]
  
      # calculate point4 (end of segment 2)
      p4x = pcx + wd2 * l1delxunit
      p4y = pcy + wd2 * l1delyunit
      p4z = pcz
      point4 = p[p4x, p4y, p4z, rx2, ry2, rz2]
  
      # third path
  
      # calculate rxryrz3 (gun pointing down, preheat pointing toward corner. for left seam, pointing left)
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 45 degrees ccw about z axis. x+ to heading1 is about 135 degrees. so our angle is heading1 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz3 = convert_matrix_to_axang(m3)
      rx3 = rxryrz3[0]
      ry3 = rxryrz3[1]
      rz3 = rxryrz3[2]
  
      # calculate rxryrz4 (gun at 45 around corner)
      m1 = get_rotation_matrix_from_description("x", -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz4 = convert_matrix_to_axang(m3)
      rx4 = rxryrz4[0]
      ry4 = rxryrz4[1]
      rz4 = rxryrz4[2]
  
      # calculate rxryrz5 (gun straight into left seam side chamfer, preheat down)
      # rotate about x 90 (forward). then rotate about z ~ 45 (ccw)
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz5 = convert_matrix_to_axang(m3)
      rx5 = rxryrz5[0]
      ry5 = rxryrz5[1]
      rz5 = rxryrz5[2]
  
      # calculate pointtopcham (the point at the top of the endwall chamfer) ( WHERE POINT3 WOULD BE IF RADIUS WAS 0)
      ptcx = x0 + rightwallthickmm * l2delxunit
      ptcy = y0 + rightwallthickmm * l2delyunit
      ptcz = z0
  
      # calculate point201 (weld start)
      # if deepchamfer, just ignore that. because if its deep chamfer then it filled more as well. so the hot extrudant should be to the same spot (same distance from the pointtopcham) whether it's big weld or small weld
      adjust = 0.0 # if you want to move the start point further away from corner (positive, mm) or closer to corner
      p201x = x0 + rightwallthickmm * l2delxunit + leftwallthickmm * l1delxunit + adjust * l1delxunit
      p201y = y0 + rightwallthickmm * l2delyunit + leftwallthickmm * l1delyunit + adjust * l1delyunit
      p201z = z0
      point201 = p[p201x, p201y, p201z, rx3, ry3, rz3]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # calculate point202 (start of roundover)
      p202x = ptcx + rod * l1delxunit
      p202y = ptcy + rod * l1delyunit
      p202z = z0
      point202 = p[p202x, p202y, p202z, rx3, ry3, rz3]
  
      # calculate point203 (middle of roundover)
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p203z = ptcz - delta
      p203x = ptcx + delta * l1delxunit
      p203y = ptcy + delta * l1delyunit
      point203 = p[p203x, p203y, p203z, rx4, ry4, rz4]
  
      # calculate point204 (end of roundover)
      point204 = p[ptcx, ptcy, ptcz - rod, rx5, ry5, rz5]
  
      # calculate trail out points (tilt back and ride)
      botvcham = wd3 # where is the bottom of the v chamfer (z distance from top corner)
      tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
      # point101 will still use backofhole, but points 102 and 103 will use normal weld tip tcp
      # calculate point5a (point101) (start of tilt back) (start of unflatten)
      dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
      p101x = ptcx
      p101y = ptcy
      p101z = ptcz - wd3 + dist
      point101 = p[p101x, p101y, p101z, rx5, ry5, rz5]
  
      # calculate point5b (point 102) (end of unflatten)
      dist = 0.5 * 25.4 / 1000
      tiltraise = 0.006
      p102x = ptcx + l1delxunit * tiltraise * -1
      p102y = ptcy + l1delyunit * tiltraise * -1
      p102z = ptcz - wd3 + dist
  
      # calculate rxryrz
      tiltangledeg = 10 # ten degree angle of tilt
      m1 = get_rotation_matrix_from_description("x", -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz = convert_matrix_to_axang(m3)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      point102 = p[p102x, p102y, p102z, rx, ry, rz]
  
      # calculate point 5c (point 103) (end of smear)
      dist = -2 * 25.4/1000
      point103 = p[p102x, p102y, ptcz - wd3 + dist, rx, ry, rz]
  
      # return
      struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point201=point201, point202=point202, point203=point203, point204=point204, point101=point101, point102=point102, point103=point103)
      return struct2
  
  
  end
  
  def calculate_LtAD_points_cover_right(struct1, leftwallthick, rightwallthick, deepcovercham):
      # get the stuff from the struct
      pointintersect = struct1[0]
      x0 = pointintersect[0]
      y0 = pointintersect[1]
      z0 = pointintersect[2]
      heading1 = struct1[1]
      heading2 = struct1[2]
      heading3 = struct1[3]
      l1delxunit = struct1[4]
      l1delyunit = struct1[5]
      l2delxunit = struct1[6]
      l2delyunit = struct1[7]
  
      # CONST
      welddistance1 = 6 # first path first leg (left side of L)
      welddistance2 = 6 # first path second leg (Right Side of L) # inches
      welddistance3 = 3 # second path (down sidewall) # inches
  
      wd1 = welddistance1 * 25.4 / 1000
      wd2 = welddistance2 * 25.4 / 1000
      wd3 = welddistance3 * 25.4 / 1000
      leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
      rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
  
      if deepcovercham:
          deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches.
      else:
          deepchambumpmm = 0.0
      end
  
      # first, check if we need a lift column raise
      # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
      zpi = pointintersect[2]
      if zpi > 0:
          liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
          z0 = 0
      else:
          z0 = zpi
      end
  
      # first and second path
  
      # calculate rxryrz1 (facing down, preheat rightish)
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis)
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz1 = convert_matrix_to_axang(m3)
      rx1 = rxryrz1[0]
      ry1 = rxryrz1[1]
      rz1 = rxryrz1[2]
  
      # calculate rxryrz2 (gun facing down, preheat facing right and back)
      # rotate 180 degrees about x. then rotate (90 deg + heading1 degrees) about z ccw
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading1 + pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz2 = convert_matrix_to_axang(m3)
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      # calculate point centerchamfers (where the center of the two chamfers intersect
      pcx = x0 + (leftwallthickmm + deepchambumpmm) * l1delxunit + (rightwallthickmm + deepchambumpmm) * l2delxunit
      pcy = y0 + (leftwallthickmm + deepchambumpmm) * l1delyunit + (rightwallthickmm + deepchambumpmm) * l2delyunit
      pcz = z0
  
      # calculate point1 (start of weld)
      p1x = pcx + l2delxunit * wd1
      p1y = pcy + l2delyunit * wd1
      p1z = pcz
      point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
  
      # calculate point2 (end of segment 1)
      p2x = pcx
      p2y = pcy
      p2z = pcz
      point2 = p[p2x, p2y, p2z, rx1, ry1, rz1]
  
      # calculate point3 (point at end of turn)
      slide = 0.00 # slide distance : the distance the tip slides forward as it turns
      p3x = pcx + slide * l1delxunit
      p3y = pcy + slide * l1delyunit
      p3z = pcz
      point3 = p[p3x, p3y, p3z, rx2, ry2, rz2]
  
      # calculate point4 (end of segment 2)
      p4x = pcx + wd2 * l1delxunit
      p4y = pcy + wd2 * l1delyunit
      p4z = pcz
      point4 = p[p4x, p4y, p4z, rx2, ry2, rz2]
  
      # third path
  
      # calculate rxryrz3 (gun pointing down, preheat pointing toward corner. for right seam, pointing right)
      # start with rxryrz = 0,0,0 (gun facing up, preheat facing y+ axis.
      # rotate it 180 degrees about x axis. gun facing down, preheat facing y- axis
      # rotate it about 135 degrees ccw about z axis. x+ to heading3 is about 225 degrees. so our angle is heading3 - 90 degrees
      m1 = get_rotation_matrix_from_description("x", -1, 180 * pi / 180) # rotation 1: 180 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2) # rotation 2
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz3 = convert_matrix_to_axang(m3)
      rx3 = rxryrz3[0]
      ry3 = rxryrz3[1]
      rz3 = rxryrz3[2]
  
      # calculate rxryrz4 (gun at 45 around corner)
      m1 = get_rotation_matrix_from_description("x", -1, 135 * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz4 = convert_matrix_to_axang(m3)
      rx4 = rxryrz4[0]
      ry4 = rxryrz4[1]
      rz4 = rxryrz4[2]
  
      # calculate rxryrz5 (gun straight into right seam side chamfer, preheat down)
      # rotate about x 90 (forward). then rotate about z ~ 135 (ccw)
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz5 = convert_matrix_to_axang(m3)
      rx5 = rxryrz5[0]
      ry5 = rxryrz5[1]
      rz5 = rxryrz5[2]
  
      # calculate rxryrz6 (gun straight into right seam side chamfer, preheat down, 10 degrees tiltback)
      tiltangledeg = 10 # ten degree angle of tilt
      m1 = get_rotation_matrix_from_description("x", -1, (90 + tiltangledeg) * pi / 180) # rotation 1: 135 degrees forward about x axis
      m2 = get_rotation_matrix_from_description("z", 1, heading3 - pi/2)
      m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
      rxryrz6 = convert_matrix_to_axang(m3)
      rx6 = rxryrz6[0]
      ry6 = rxryrz6[1]
      rz6 = rxryrz6[2]
  
      # calculate pointtopcham (the point at the top of the endwall chamfer) ( WHERE POINT3 WOULD BE IF RADIUS WAS 0)
      ptcx = x0 + leftwallthickmm * l1delxunit
      ptcy = y0 + leftwallthickmm * l1delyunit
      ptcz = z0
  
      # calculate point201 (weld start)
      # if deepchamfer, just ignore that. because if its deep chamfer then it filled more as well. so the hot extrudant should be to the same spot (same distance from the pointtopcham) whether it's big weld or small weld
      adjust = 0.0 # if you want to move the start point further away from corner (positive, mm) or closer to corner
      p201x = x0 + rightwallthickmm * l2delxunit + leftwallthickmm * l1delxunit + adjust * l2delxunit
      p201y = y0 + rightwallthickmm * l2delyunit + leftwallthickmm * l1delyunit + adjust * l2delyunit
      p201z = z0
      point201 = p[p201x, p201y, p201z, rx3, ry3, rz3]
  
      # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
      roundoverdistance = 0.05
      rod = roundoverdistance * 25.4 / 1000
  
      # calculate point202 (start of roundover)
      p202x = ptcx + rod * l2delxunit
      p202y = ptcy + rod * l2delyunit
      p202z = z0
      point202 = p[p202x, p202y, p202z, rx3, ry3, rz3]
  
      # calculate point203 (middle of roundover)
      # we know that the angle is exactly 90 degrees
      delta = calc_rod_midpoint_90deg(rod)
      p203z = ptcz - delta
      p203x = ptcx + delta * l2delxunit
      p203y = ptcy + delta * l2delyunit
      point203 = p[p203x, p203y, p203z, rx4, ry4, rz4]
  
      # calculate point204 (end of roundover)
      point204 = p[ptcx, ptcy, ptcz - rod, rx5, ry5, rz5]
  
      # calculate trail out points (tilt back and ride)
      botvcham = wd3 # where is the bottom of the v chamfer (z distance from top corner)
      tcpdiff = 14 # mm. the difference between backofhole tcp and welder tcp (tip)
      # point101 will still use backofhole, but points 102 and 103 will use normal weld tip tcp
      # calculate point5a (point101) (start of tilt back) (start of unflatten)
      dist = 1.5 * 25.4/1000 + tcpdiff/1000 # distance from botvcham
      p101x = ptcx
      p101y = ptcy
      p101z = ptcz - wd3 + dist
      point101 = p[p101x, p101y, p101z, rx5, ry5, rz5]
  
      # calculate point5b (point 102) (end of unflatten)
      dist = 0.5 * 25.4 / 1000
      tiltraise = 0.006
      p102x = ptcx + l2delxunit * tiltraise * -1
      p102y = ptcy + l2delyunit * tiltraise * -1
      p102z = ptcz - wd3 + dist
      point102 = p[p102x, p102y, p102z, rx6, ry6, rz6]
  
      # calculate point 5c (point 103) (end of smear)
      dist = -2 * 25.4/1000
      point103 = p[p102x, p102y, ptcz - wd3 + dist, rx6, ry6, rz6]
  
      # return
      struct2 = struct(point1=point1, point2=point2, point3=point3, point4=point4, point201=point201, point202=point202, point203=point203, point204=point204, point101=point101, point102=point102, point103=point103)
      return struct2
  
  end
  
  
  def main_calculate_cover_straight(p11, p12, p21, p22, sidewallthick, leftpoint, rightpoint, deepcovercham):
      struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
      struct2 = calculate_straight_points_cover(struct1, sidewallthick, leftpoint, rightpoint, deepcovercham)
      #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      #struct3 = check_validity_left(struct1, struct2)
      return struct2
  
  end
  
  # calculates the line of intersection of the sidewall plane (assumed vertical) and the cover plane (assumed perpendicular to sidewall plane)
  # returns a struct containing point0 (point on the intersection line, same y as leftpoint) and 3 components of the unit vector left to right and 2 components of the other direction in 2d
  def analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint):
      # calculate slope of sidewall in x-y plane
      # get the raw points from the first line
      l1p1x=p11[0]
      l1p1y=p11[1]
      l1p2x=p12[0]
      l1p2y=p12[1]
  
      # equate the first line in 2d space
      ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
      # b = y - mx
      bl1 = l1p1y - ml1 * l1p1x
  
      # calculate the cover plane
      # if two planes are perpendicular, then their normal vectors must be perpendicular.
      # the first planes normal vector is n1, which is taken from the equation of the plane ax + by + cz = d -> <a, b, c>
      # the second plane's normal vector is perpendicular to all vectors contained in the plane
      # p21 to p22 is a vector v contained within plane 2.
      # n2 is normal to both n1 AND v. to achieve a vector that is normal to both, take the cross product
  
      # plane 1 (y = mx + b) -> (b = -mx +1y +0z)
      n1 = [-1 * ml1, 1, 0]
  
      # v=P2−P1=(x2−x1,y2−y1,z2−z1)
      v = [p21[0]-p22[0], p21[1]-p22[1], p21[2]-p22[2]]
  
      #v n2 = cross product of n1 and v
      n2x = n1[1]*v[2] - n1[2]*v[1]
      n2y = n1[2]*v[0] - n1[0]*v[2]
      n2z = n1[0]*v[1] - n1[1]*v[0]
      n2 = [n2x, n2y, n2z]
  
      # find the d of the second plane
      # n2x * x + n2y * y + n2z * z = d0
      d = n2x * p21[0] + n2y * p21[1] + n2z * p21[2]
  
      # find the intersection line of the two planes
      # find the direction vector of that line by taking the cross product of the normal vector of those two planes
      v3x = n1[1]*n2[2] - n1[2]*n2[1]
      v3y = n1[2]*n2[0] - n1[0]*n2[2]
      v3z = n1[0]*n2[1] - n1[1]*n2[0]
      v3 = [v3x, v3y, v3z]
  
      # normalize the vector so the magnitude is 1
      magnitude2 = v3x * v3x + v3y * v3y + v3z * v3z
      magnitude = sqrt(magnitude2)
      v3xunit = v3x/magnitude
      v3yunit = v3y/magnitude
      v3zunit = v3z/magnitude
  
      # make sure it is going the right way (from left to right). make sure the v3yunit is positive
      if v3yunit < 0:
          v3xunit = v3xunit * -1
          v3yunit = v3yunit * -1
          v3zunit = v3zunit * -1
      end
  
      # next we have to find a point on the line by setting one of the dimensions and solving the system of equations
      # i will pick the y value of the left teach point
      y = leftpoint[1]
      # plane 1: -ml1 * x + 1 * y + 0 * z = bl1
      # -ml1 * x = bl1 - y
      x = (bl1 - y)/ (-1 * ml1)
      # plane 2: d = n2x * x + n2y * y + n2z * z
      # (d - n2x * x - n2y * y) = n2z * z
      z = (d - n2x * x - n2y * y) / n2z
  
      # make point0 into a pose
      point0 = p[x, y, z, 0, 0, 0]
  
      # find heading of main line
      heading1 = convert_uv_to_heading(v3xunit, v3yunit)
  
      # make a unit vector perpendicular to this one in the xy plane pointing x -. will be used to move over the chamfer distance
      ml2 = -1 / ml1
      # y = ml2 * x + unknownB
      # vector = [1, ml2]
      mag2 = 1 + ml2 * ml2
      mag = sqrt(mag2)
      v4xunit = 1 / mag
      v4yunit = ml2 / mag
      # switch is to the x direction is negative
      v4xunit = -1 * v4xunit
      v4yunit = -1 * v4yunit
  
      ret = struct(point0=point0, v3xunit=v3xunit, v3yunit=v3yunit, v3zunit=v3zunit, heading1=heading1, v4xunit=v4xunit, v4yunit=v4yunit)
      return ret
  end
  
  def calculate_straight_points_cover(struct1, sidewallthick, leftpointteach, rightpointteach, deepcovercham):
      # get the stuff
      point0 = struct1[0]
      p0x = point0[0]
      p0y = point0[1]
      p0z = point0[2]
      v3xunit = struct1[1]
      v3yunit = struct1[2]
      v3zunit = struct1[3]
      heading1 = struct1[4]
      v4xunit = struct1[5]
      v4yunit = struct1[6]
      sidewallthick = sidewallthick
      lpy = leftpointteach[1]
      rpy = rightpointteach[1]
  
      # first, check if we need a lift column raise
      # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
      zpi = p0z
      if zpi > 0:
          liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
          coverz = 0
      else:
          coverz = zpi
      end
  
      if deepcovercham:
          deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches.
      else:
          deepchambumpmm = 0.0
      end
  
      # calculate pointtopvcham
      chamferover = sidewallthick * 25.4 / 1000.0 + deepchambumpmm
      tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
      x = p0x + v4xunit * chamferover
      y = p0y + v4yunit * chamferover
      z = coverz + tiltraise
  
      # calculate rxryrz for tilted back
      # 3 rotations to make this happen.
      # start point is straight up with the preheat pointed in the +y direction.
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # second rotation is a 10 degree turn about the x axis (negative direction)
      m2 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      # combine them by multiplying m3 * m2 * m1
      # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
      m4 = multiply_matrix(m2, m1)
      m5 = multiply_matrix(m3, m4)
      rxryrzt = convert_matrix_to_axang(m5)
      rxt = rxryrzt[0]
      ryt = rxryrzt[1]
      rzt = rxryrzt[2]
      pointtopvcham = p[x, y, z, rxt, ryt, rzt]
  
      # calculate point1 (preheat)
      dist = -1 * 25.4 / 1000.0 # move back 1 inch from
      p1x = x + dist * v3xunit
      p1y = y + dist * v3yunit
      p1z = z + dist * v3zunit
      point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
  
      # calculate point2 (start of flatten)
      dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
      p2x = x + dist * v3xunit
      p2y = y + dist * v3yunit
      p2z = z + dist * v3zunit
      point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
  
      # calculate rxryrz for nontilted
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      m5 = multiply_matrix(m3, m1)
      rxryrz = convert_matrix_to_axang(m5)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate point3 (end of flatten)
      dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
      p3x = x + dist * v3xunit
      p3y = y + dist * v3yunit
      p3z = coverz + dist * v3zunit
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      # calculate distance between leftpoint and rightpoint
      # we have the y distance. we need to find the total distance.
      # the unit vector (v3) should have a magnitude of 1. that's what analyze_touchpoints_only_cover_straight() calculated.
      # so the total distance is y distance * 1 / v3yunit
      ydist = rpy - lpy
      totdist = ydist / v3yunit
  
      # calculate pointtopvcham2
      x2 = x + v3xunit * totdist
      y2 = y + v3yunit * totdist
      z2 = z + v3zunit * totdist
  
      # calculate point4 (start of unflatten)
      dist = -1.5 * 25.4 / 1000.0
      p4x = x2 + v3xunit * dist
      p4y = y2 + v3yunit * dist
      p4z = z2 + v3zunit * dist - tiltraise
      point4 = p[p4x, p4y, p4z, rx, ry, rz]
  
      # calculate point5 (end of unflatten)
      dist = -0.5 * 25.4 / 1000.0
      p5x = x2 + v3xunit * dist
      p5y = y2 + v3yunit * dist
      p5z = z2 + v3zunit * dist
      point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
  
      # calculate point6 (end of smear)
      dist = 2 * 25.4 / 1000.0
      p6x = x2 + v3xunit * dist
      p6y = y2 + v3yunit * dist
      p6z = z2 + v3zunit * dist
      point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
  
  
      # return struct
      ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
      return ret
  
  
  end
  
  def main_calculate_floor_straight(p11, p12, p21, p22, floorthick, leftpoint, rightpoint):
      struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
      struct2 = calculate_straight_points_floor(struct1, floorthick, leftpoint, rightpoint)
      #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      #struct3 = check_validity_left(struct1, struct2)
      return struct2
  
  end
  
  # the path for welding a floor straight weld with v chisels on both sides.
  # start at the right side and move left.
  def calculate_straight_points_floor(struct1, floorthick, leftpointteach, rightpointteach):
      # get the stuff
      point0 = struct1[0]
      p0x = point0[0]
      p0y = point0[1]
      p0z = point0[2]
      v3xunit = struct1[1]
      v3yunit = struct1[2]
      v3zunit = struct1[3]
      heading1 = struct1[4]
      v4xunit = struct1[5]
      v4yunit = struct1[6]
      lpy = leftpointteach[1]
      rpy = rightpointteach[1]
  
      # first, check if we need a lift column raise
      # (we do not, because the floors are low)
      zpi = p0z
      floorz = zpi
  
      # calculate pointtopvcham (left point) (tilted and tiltraised)
      chamferup = floorthick * 25.4 / 1000.0
      tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
      # on this one, move the tiltraise distance sideways (towards robot) and the chamferover distance up
      x = p0x + v4xunit * tiltraise * -1
      y = p0y + v4yunit * tiltraise * -1
      z = floorz + chamferup
  
      # calculate rxryrz for tilted back
      # 3 rotations to make this happen.
      # start point is straight up with the preheat pointed in the +y direction.
      # first rotation is 90 degrees about y axis. positive direction. gun is now pointing in the x+ direction with preheat facing +y direction
      m1 = get_rotation_matrix_from_description("y", 1, 90 * pi / 180)
      # second rotation is about 180 degrees about the z axis. heading1 plus 90 degrees. gun is now pointing directly into the sidewall
      m2 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      # third rotation is 10 degrees about the z axis. gun is now tilted back 10 degrees from the sidewall
      m3 = get_rotation_matrix_from_description("z", 1, 10 * pi / 180)
      # combine them by multiplying m3 * m2 * m1
      # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
      m4 = multiply_matrix(m2, m1)
      m5 = multiply_matrix(m3, m4)
      rxryrzt = convert_matrix_to_axang(m5)
      rxt = rxryrzt[0]
      ryt = rxryrzt[1]
      rzt = rxryrzt[2]
      # the non tilted angle is just m4
      rxryrz = convert_matrix_to_axang(m4)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
      pointtopvcham = p[x, y, z, rxt, ryt, rzt]
  
      # calculate distance between leftpoint and rightpoint
      # we have the y distance. we need to find the total distance.
      # the unit vector (v3) should have a magnitude of 1. that's what analyze_touchpoints_only_cover_straight() calculated.
      # so the total distance is y distance * 1 / v3yunit
      ydist = rpy - lpy
      totdist = ydist / v3yunit
  
      # calculate pointtopvcham2 (right point) (tilted and tiltraised)
      x2 = x + v3xunit * totdist
      y2 = y + v3yunit * totdist
      z2 = z + v3zunit * totdist
      pointtopvcham2 = p[x2, y2, z2, rxt, ryt, rzt]
  
      # calculate point1 (preheat)
      dist = 1 * 25.4 / 1000.0 # move back 1 inch from ptvc2 (in this case back means positive)
      p1x = x2 + dist * v3xunit
      p1y = y2 + dist * v3yunit
      p1z = z2 + dist * v3zunit
      point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
  
      # calculate point2 (start of flatten)
      dist = -0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
      p2x = x2 + dist * v3xunit
      p2y = y2 + dist * v3yunit
      p2z = z2 + dist * v3zunit
      point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
  
      # calculate point3 (end of flatten)
      dist = -1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
      p3x = x2 + dist * v3xunit + tiltraise * v4xunit
      p3y = y2 + dist * v3yunit + tiltraise * v4yunit
      p3z = z2 + dist * v3zunit
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      # calculate point4 (start of unflatten)
      dist = 1.5 * 25.4 / 1000.0
      p4x = x + v3xunit * dist + tiltraise * v4xunit
      p4y = y + v3yunit * dist + tiltraise * v4yunit
      p4z = z + v3zunit * dist
      point4 = p[p4x, p4y, p4z, rx, ry, rz]
  
      # calculate point5 (end of unflatten)
      dist = 0.5 * 25.4 / 1000.0
      p5x = x + v3xunit * dist
      p5y = y + v3yunit * dist
      p5z = z + v3zunit * dist
      point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
  
      # calculate point6 (end of smear)
      dist = -2 * 25.4 / 1000.0
      p6x = x + v3xunit * dist
      p6y = y + v3yunit * dist
      p6z = z + v3zunit * dist
      point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
  
      # return struct
      ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
      return ret
  
  end
  
  # this function determines the starting touchpoints for homing in on cover lt geometry
  # includes two points above the cover lt, closer to the robot than the lt, facing down
  def get_coverlt_homing_pathpoints(leftpoint, rightpoint):
      # get the teach position points
      lpx = leftpoint[0]
      lpy = leftpoint[1]
      lpz = leftpoint[2]
      rpx = rightpoint[0]
      rpy = rightpoint[1]
      rpz = rightpoint[2]
  
      # specify the distances from (in meters)
      d0 = 0.05 # how far from the cover to approach from
      d1 = 0.03 # how far the touchpints are pushed closer to the robot
      d2 = 0.00 # how far inwards the touchpoints are pushed
  
      # rxryrz
      rxryrz = [0.334, 3.124, 0]
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate the points
      ph1 = p[lpx + d1, lpy + d2, lpz + d0, rx, ry, rz] # left side approach
      ph2 = p[rpx + d1, rpy - d2, rpz + d0, rx, ry, rz] # right side approach
  
      ret = struct(ph1=ph1, ph2=ph2)
      is_robot_at_reachable_spot(leftpoint, ret)
      return ret
  end
  
  def main_calculate_cover_lt(p11, p12, leftpoint, rightpoint):
      struct1 = analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint)
      struct2 = calculate_points_cover_lt(struct1)
      #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      #struct3 = check_validity_left(struct1, struct2)
      return struct2
  
  end
  
  def analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint):
      # calculate the slope of the groove in xy plane
      l1p1x = leftpoint[0]
      l1p1y = leftpoint[1]
      l1p2x = rightpoint[0]
      l1p2y = rightpoint[1]
  
      # equate the first line in 2d space
      ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
      # b = y - mx
      bl1 = l1p1y - ml1 * l1p1x
  
      # zraise (how much the z value changes from left point to right point
      zraise = p12[2] - p11[2]
  
      #get the calcpoints
      leftcalcpoint = [leftpoint[0], leftpoint[1], p11[2]]
      rightcalcpoint = [rightpoint[0], rightpoint[1], p12[2]]
      # get the vector from a to b
      vec = [rightcalcpoint[0] - leftcalcpoint[0], rightcalcpoint[1] - leftcalcpoint[1], rightcalcpoint[2] - leftcalcpoint[2]]
      # get the unit vector in 3d
      mag3d = sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])
      vec3dunit = [vec[0]/mag3d, vec[1]/mag3d, vec[2]/mag3d]
      # get the unit vector in 2d
      mag2d = sqrt(vec[0]*vec[0]+vec[1]*vec[1])
      vec2dunit = [vec[0]/mag2d, vec[1]/mag2d]
      # get the heading
      heading1 = convert_uv_to_heading(vec2dunit[0], vec2dunit[1])
  
      ret = struct(leftcalcpoint=leftcalcpoint, rightcalcpoint=rightcalcpoint, vxunit=vec3dunit[0], vyunit=vec3dunit[1], vzunit=vec3dunit[2], heading1=heading1)
      return ret
  end
  
  def calculate_points_cover_lt(struct1):
      # get the stuff from struct
      leftcalcpoint = struct1[0]
      x = leftcalcpoint[0]
      y = leftcalcpoint[1]
      z = leftcalcpoint[2]
      rightcalcpoint = struct1[1]
      x2 = rightcalcpoint[0]
      y2 = rightcalcpoint[1]
      z2 = rightcalcpoint[2]
      v3xunit = struct1[2]
      v3yunit = struct1[3]
      v3zunit = struct1[4]
      heading1 = struct1[5]
  
      # first calculate rxryrz f normal and tiltback
      # calculate rxryrz for tilted back
      # 3 rotations to make this happen.
      # start point is straight up with the preheat pointed in the +y direction.
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # second rotation is a 10 degree turn about the x axis (negative direction)
      m2 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      # combine them by multiplying m3 * m2 * m1
      # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
      m4 = multiply_matrix(m2, m1)
      m5 = multiply_matrix(m3, m4)
      rxryrzt = convert_matrix_to_axang(m5)
      rxt = rxryrzt[0]
      ryt = rxryrzt[1]
      rzt = rxryrzt[2]
  
      # calculate rxryrz for nontilted
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      m5 = multiply_matrix(m3, m1)
      rxryrz = convert_matrix_to_axang(m5)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
  
      # calculate points 1-3
      # calculate point1 (preheat)
      dist = -1 * 25.4 / 1000.0 # move back 1 inch from
      p1x = x + dist * v3xunit
      p1y = y + dist * v3yunit
      p1z = z + dist * v3zunit + tiltraise
      point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
  
      # calculate point2 (start of flatten)
      dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
      p2x = x + dist * v3xunit
      p2y = y + dist * v3yunit
      p2z = z + dist * v3zunit + tiltraise
      point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
  
      # calculate point3 (end of flatten)
      dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
      p3x = x + dist * v3xunit
      p3y = y + dist * v3yunit
      p3z = z + dist * v3zunit
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      # calculate points 4-6
      # calculate point4 (start of unflatten)
      dist = -1.5 * 25.4 / 1000.0
      p4x = x2 + v3xunit * dist
      p4y = y2 + v3yunit * dist
      p4z = z2 + v3zunit * dist
      point4 = p[p4x, p4y, p4z, rx, ry, rz]
  
      # calculate point5 (end of unflatten)
      dist = -0.5 * 25.4 / 1000.0
      p5x = x2 + v3xunit * dist
      p5y = y2 + v3yunit * dist
      p5z = z2 + v3zunit * dist + tiltraise
      point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
  
      # calculate point6 (end of smear)
      dist = 2 * 25.4 / 1000.0
      p6x = x2 + v3xunit * dist
      p6y = y2 + v3yunit * dist
      p6z = z2 + v3zunit * dist + tiltraise
      point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
  
      # return struct
      ret = struct(pointtopvcham=leftcalcpoint, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
      return ret
  
  end
  
  def main_calculate_sleeve_fillet(p1, p2, p3):
      struct1 = analyze_touchpoints_only_sleeve_fillet(p1, p2, p3)
      struct2 = calculate_points_sleeve_fillet(struct1)
      return struct2
  end
  
  # given 3 points at the intersection of the sleeve and the sidewall, this calculates and returns 3 things:
  # the centerpoint of the circle on the plane, the normal vector of the plane, and the radius of the circle
  # then it returns 4 more things after converting to a vertical circle/plane: heading1 (into the plane), vecn, vecr, vecu
  def analyze_touchpoints_only_sleeve_fillet(p1, p2, p3):
      x1 = p1[0]
      y1 = p1[1]
      z1 = p1[2]
      x2 = p2[0]
      y2 = p2[1]
      z2 = p2[2]
      x3 = p3[0]
      y3 = p3[1]
      z3 = p3[2]
  
      # calculate plane
      # calculate ab (1->2) vector
      abvec = [x2-x1, y2-y1, z2-z1]
      # calculate ac (1->3) vector
      acvec = [x3-x1, y3-y1, z3-z1]
      #calculate the plane's normal vector = ab x ac
  
      n = crossproduct(abvec, acvec)
      mag = sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2])
      n = [n[0]/mag, n[1]/mag, n[2]/mag]
      d = n[0] * x1 + n[1] * y1 + n[2] * z1
  
      # find the circle
      # Midpoint of AB:
      mab = [(x1 + x2)/2, (y1 + y2)/2, (z1 + z2)/2]
      # midpoint of ac
      mac = [(x3 + x1)/2, (y3 + y1)/2, (z3 + z1)/2]
      # Get Normal Vectors to AB and AC in the Plane
      # nab (normal to ab) = abvec x n
      nab = crossproduct(abvec, n)
      # nac (normal to ac) = acvec x n
      nac = crossproduct(acvec, n)
      # Define Perpendicular Bisector Lines
      # Each line goes through a midpoint and extends in the direction of the na_
      # we already have the equations of those lines in point vector form with l1 = mab + s * nab, and l2 = mac + t * nac
      # define all the terms so the math is simpler when i have to do math
      mabx = mab[0]
      maby = mab[1]
      mabz = mab[2]
      nabx = nab[0]
      naby = nab[1]
      nabz = nab[2]
      macx = mac[0]
      macy = mac[1]
      macz = mac[2]
      nacx = nac[0]
      nacy = nac[1]
      nacz = nac[2]
      # find the intersection point using the y and z equations
      # maby + s * naby = macy + t * nacy
      # mabz + s * nabz = macz + t * nacz
      # first solve for s and take
      # t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
      t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
      # s = (t*nacz + macz - mabz) / nabz
      s = (t*nacz + macz - mabz) / nabz
      # find the point
      # pcenter = mac + t * nac
      pcenterx = macx + t * nacx
      pcentery = macy + t * nacy
      pcenterz = macz + t * nacz
      rxryrz = [0.528, 4.631, 0.258] # demo point of the welder pointing forward into a sleeve
      pcenter = p[pcenterx, pcentery, pcenterz, rxryrz[0], rxryrz[1], rxryrz[2]]
      radius = distance_between(pcenterx, pcentery, pcenterz, x1, y1, z1)
  
      # ------ start calculation of vertical assumption -----
      # assume the plane close to vertical
      # fix it to make it actually vertical
      # calculate the unit vector of up, and the unit vector of right.
      # calculate the heading from the +x axis to pointing straight into the wall.
      # the unit vector of up is [0, 0, 1] (because the plane is verticalized) (for easier calculations)
      # first calculate the normal vector INTO the sidewall (make sure x is negative) and make it a unit vector
      vecn = [n[0], n[1], 0] # vector normal
      if vecn[0] > 0:
          vecn = [-n[0], -n[1], 0]
      end
      mag = sqrt(vecn[0]*vecn[0]+vecn[1]*vecn[1])
      vecn = [vecn[0]/mag, vecn[1]/mag, 0]
      # next calculate the right normal vector (the vector IN the plane that goes to the right)
      vecr = [vecn[1], -1*vecn[0], 0]
      vecu = [0, 0, 1] # vector up
      heading1 = convert_uv_to_heading(vecn[0], vecn[1])
  
  
      ret = struct(pcenter=pcenter, planenormalvec=n, radius=radius, heading1=heading1, vecn=vecn, vecr=vecr, vecu=vecu)
      return ret
  end
  
  def crossproduct(vec1, vec2):
      nx = vec1[1]*vec2[2] - vec1[2]*vec2[1]
      ny = vec1[2]*vec2[0] - vec1[0]*vec2[2]
      nz = vec1[0]*vec2[1] - vec1[1]*vec2[0]
      ret = [nx, ny, nz]
      return ret
  end
  
  # this function calculates only the four points of the quadrants, for the not real program.
  # these calculations are easier so that's why i'm starting with them first.
  # this assumes a vertical plane
  def calculate_points_sleeve_fillet_quadonly(struct1):
      # get the stuff from the struct
      pcenter = struct1[0]
      pcx = pcenter[0]
      pcy = pcenter[1]
      pcz = pcenter[2]
      planenormalvec = struct1[1]
      radius = struct1[2]
      heading1 = struct1[3]
      vecn = struct1[4]
      vecnx = vecn[0]
      vecny = vecn[1]
      vecr = struct1[5]
      vecrx = vecr[0]
      vecry = vecr[1]
      vecu = struct1[6]
      vecuz = vecu[2]
  
      # define cushions (the backofhole can't actually touch the intersection of pipe and wall, it travels a certain distance around it
      cushout = 0.006 # 5mm # the cushion out from the wall
      cusharound = 0.006 # 5mm # the cushion around the sleeve.
  
      # get the top point (point1)
      # take the center point and move up the radius plus the cushions
      p1x = pcx + vecnx * -1 * cushout
      p1y = pcy + vecny * -1 * cushout
      p1z = pcz + vecuz * radius + vecuz * cusharound
  
      # find rxryrz1
      # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
      m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
      # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz1 = convert_matrix_to_axang(m3)
      rx1 = rxryrz1[0]
      ry1 = rxryrz1[1]
      rz1 = rxryrz1[2]
  
      point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
  
      # get second point (right) (point2)
      # take the center point and move right the radius plus the cushions
      p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * -1 * cushout
      p2y = pcy + vecry * radius + vecry * cusharound + vecny * -1 * cushout
      p2z = pcz
  
      # find rxryrz2
      # first rotation is 90 degrees about the x- axis
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      # second rotation is About 135 degrees about the z+ axis. This calculation is heading1 – 45 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - 45 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz2 = convert_matrix_to_axang(m3)
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
  
      # get the third point (bottom) (point3)
      p3x = pcx + vecnx * -1 * cushout
      p3y = pcy + vecny * -1 * cushout
      p3z = pcz - vecuz * radius - vecuz * cusharound
  
      # find rxryrz3
      # first rotation is 45 degrees about the y+ axis
      m1 = get_rotation_matrix_from_description("y", 1, 45 * pi / 180)
      # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz3 = convert_matrix_to_axang(m3)
      rx3 = rxryrz3[0]
      ry3 = rxryrz3[1]
      rz3 = rxryrz3[2]
  
      point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
  
      # get the fourth point (left) (point4)
      p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * -1 * cushout
      p4y = pcy - vecry * radius - vecry * cusharound + vecny * -1 * cushout
      p4z = pcz
  
      # find rxryrz4
      # first rotation is 90 degrees about the x+ axis
      m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
      # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
      m2 = get_rotation_matrix_from_description("z", 1, heading1 + 45 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz4 = convert_matrix_to_axang(m3)
      rx4 = rxryrz4[0]
      ry4 = rxryrz4[1]
      rz4 = rxryrz4[2]
  
      point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
  
      # return the points
      ret = struct(point1=point1, point2=point2, point3=point3, point4=point4)
      return ret
  
  end
  
  # this function calculates the points necessary for the fillet sleeve weld path.
  # this assumes a vertical plane
  def calculate_points_sleeve_fillet(struct1):
      # get the stuff from the struct
      pcenter = struct1[0]
      pcx = pcenter[0]
      pcy = pcenter[1]
      pcz = pcenter[2]
      planenormalvec = struct1[1]
      radius = struct1[2]
      heading1 = struct1[3]
      vecn = struct1[4]
      vecnx = vecn[0]
      vecny = vecn[1]
      vecr = struct1[5]
      vecrx = vecr[0]
      vecry = vecr[1]
      vecu = struct1[6]
      vecuz = vecu[2]
  
      # define cushions (the backofhole can't actually touch the intersection of pipe and wall, it travels a certain distance around it
      cushout = 0.006 # 5mm # the cushion out from the wall
      cusharound = 0.004 # 5mm # the cushion around the sleeve.
  
      # get the top point (point1)
      # take the center point and move up the radius plus the cushions
      p1x = pcx + vecnx * -1 * cushout
      p1y = pcy + vecny * -1 * cushout
      p1z = pcz + vecuz * radius + vecuz * cusharound
  
      # find rxryrz1
      # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
      m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
      # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz1 = convert_matrix_to_axang(m3)
      rx1 = rxryrz1[0]
      ry1 = rxryrz1[1]
      rz1 = rxryrz1[2]
  
      point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
  
      # get second point (right) (point2)
      # take the center point and move right the radius plus the cushions
      p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * -1 * cushout
      p2y = pcy + vecry * radius + vecry * cusharound + vecny * -1 * cushout
      p2z = pcz
  
      # find rxryrz2
      # first rotation is 90 degrees about the x- axis
      m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
      # second rotation is About 135 degrees about the z+ axis. This calculation is heading1 – 45 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - 45 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz2 = convert_matrix_to_axang(m3)
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
  
      # get the third point (bottom) (point3)
      p3x = pcx + vecnx * -1 * cushout
      p3y = pcy + vecny * -1 * cushout
      p3z = pcz - vecuz * radius - vecuz * cusharound
  
      # find rxryrz3
      # first rotation is 45 degrees about the y+ axis
      m1 = get_rotation_matrix_from_description("y", 1, 45 * pi / 180)
      # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz3 = convert_matrix_to_axang(m3)
      rx3 = rxryrz3[0]
      ry3 = rxryrz3[1]
      rz3 = rxryrz3[2]
  
      point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
  
      # get the fourth point (left) (point4)
      p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * -1 * cushout
      p4y = pcy - vecry * radius - vecry * cusharound + vecny * -1 * cushout
      p4z = pcz
  
      # find rxryrz4
      # first rotation is 90 degrees about the x+ axis
      m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
      # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
      m2 = get_rotation_matrix_from_description("z", 1, heading1 + 45 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      rxryrz4 = convert_matrix_to_axang(m3)
      rx4 = rxryrz4[0]
      ry4 = rxryrz4[1]
      rz4 = rxryrz4[2]
  
      point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
  
      # get the angle for the tilt-back at the top (p1)
      m0 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
      m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
      # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
      m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
      # combine them by multiplying
      m3 = multiply_matrix(m2, m1)
      m4 = multiply_matrix(m3, m0)
      rxryrz1tilt = convert_matrix_to_axang(m4)
      rx1t = rxryrz1tilt[0]
      ry1t = rxryrz1tilt[1]
      rz1t = rxryrz1tilt[2]
  
      # point 1, but with the tilt back angle
      point1t = p[p1x, p1y, p1z, rx1t, ry1t, rz1t]
  
      # point45 (the point 45 degrees along the path) (has no rxryrz data) (because if we do fixed angle circle move it wont use that anyways, it'l just use the angle from p1t)
      distup = cos(45 * pi/180) * (radius + cusharound)
      distover = sin(45 * pi/180) * (radius + cusharound)
      p45x = pcx + vecrx * distover + vecnx * -1 * cushout
      p45y = pcy + vecry * distover + vecny * -1 * cushout
      p45z = pcz + vecuz * distup
      point45 = p[p45x, p45y, p45z, 0,0,0]
  
      # point22 (22.5 degrees of angle)
      distup = cos(22.5 * pi/180) * (radius + cusharound)
      distover = sin(22.5 * pi/180) * (radius + cusharound)
      p22x = pcx + vecrx * distover + vecnx * -1 * cushout
      p22y = pcy + vecry * distover + vecny * -1 * cushout
      p22z = pcz + vecuz * distup
      point22 = p[p22x, p22y, p22z, 0,0,0]
  
      # return the points
      ret = struct(point1=point1, point2=point2, point3=point3, point4=point4, point1t=point1t, point45=point45, point22=point22)
      return ret
  
  end
  
  def make_pose_list(length):
      if length < 1:
          ret = []
          return ret
      end
      if length == 1:
          pose_list = [p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 2:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 3:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 4:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 5:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 6:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 7:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 8:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length == 9:
          pose_list = [p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
          return pose_list
      end
      if length > 9:
          popuptext = "Program is only capable of storing 9 pegs at once. You selected more than 9. "
          # infinite loop
          while 1==1:
              popup(popuptext, title="Too Many Pegs",blocking=True)
          end
      end
  end
  
  # this function calculates the poses required on the weldpath for a specific teach pose for peg center.
  # call this function for every peg you want to weld.
  def main_calculate_peg(pose1):
      # constants
      peg_width = 2.05 # inches
      fixture_height = 1.5 # inches
      cushout = 0.006 # 5mm # the cushion out from the wall
      cusharound = 0.004 # 5mm # the cushion around the sleeve.
      delz = fixture_height *25.4/1000 - cushout
      rad = peg_width *1/2 * 25.4/1000 + cusharound
  
      # calculate angles
      # rxryrz1 (for point 1 (back side of peg)
      # start with gun facing up, shield tip pointing in x+ direction
      # rotate about y axis (y-) 135 degrees.
      # thats it. (for the other ones, then rotate 90 degrees about z axis from this spot
      m0 = get_rotation_matrix_from_description("y", -1, 225 * pi / 180)
      rxryrz1 = convert_matrix_to_axang(m0)
      rx1 = rxryrz1[0]
      ry1 = rxryrz1[1]
      rz1 = rxryrz1[2]
  
      # rxryrz2
      # second rotation is 90 degrees about z- axis
      m1 = get_rotation_matrix_from_description("z", -1, 90 * pi / 180)
      m2 = multiply_matrix(m1, m0)
      rxryrz2 = convert_matrix_to_axang(m2)
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      # rxryrz3
      # second rotation is 180 degrees about z- axis
      m1 = get_rotation_matrix_from_description("z", -1, 180 * pi / 180)
      m2 = multiply_matrix(m1, m0)
      rxryrz3 = convert_matrix_to_axang(m2)
      rx3 = rxryrz3[0]
      ry3 = rxryrz3[1]
      rz3 = rxryrz3[2]
  
      # rxryrz4
      # second rotation is 270 degrees about z- axis
      m1 = get_rotation_matrix_from_description("z", -1, 270 * pi / 180)
      m2 = multiply_matrix(m1, m0)
      rxryrz4 = convert_matrix_to_axang(m2)
      rx4 = rxryrz4[0]
      ry4 = rxryrz4[1]
      rz4 = rxryrz4[2]
  
      # get points
      # get lift column height based on z value
      # if z is between +1 feet and -1 feet then go to 750
      # if z is greater than +1 feet but less than +4 feet, then go to 880
      # if z is greater than +4 feet, then error
      # if z is less than -1 feet, then go to 750 mm above z.
  
      # scrap that. new rules
      # go to 750 mm above z.
      # if that result is above 880, then go to 880.
      # that will work until we get problems
  
      z0 = pose1[2] # the teach point's z value (taken when lift column = 0)
      lczn = z0 + .750 # lift column z needed
      if lczn > .880:
          lczn = .880
      end
      liftcolumnzneeded = lczn * 1000 # set the z position
      zposerel = z0 - lczn # z pose relative = the teach point's z value at the new lift column position.
  
      pcenterx = pose1[0]
      pcentery = pose1[1]
  
      #points
      p1x = pcenterx - rad
      p1y = pcentery
      p1z = zposerel - delz
  
      p2x = pcenterx
      p2y = pcentery + rad
      p2z = zposerel - delz
  
      p3x = pcenterx + rad
      p3y = pcentery
      p3z = zposerel - delz
  
      p4x = pcenterx
      p4y = pcentery - rad
      p4z = zposerel - delz
  
      point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
      point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
      point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
      point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
  
      ret = struct(point1=point1, point2=point2, point3=point3, point4=point4, liftcolumnzneeded=liftcolumnzneeded)
      return ret
  
  
  
  end
  $ 96 "leftchoice≔'Select Yes for a Left side weld, or select No for a Right Side weld.'"
  global leftchoice=request_boolean_from_primary_client("Select Yes for a Left side weld, or select No for a Right Side weld.")
  $ 97 "sidewallchoice≔'Is the sidewall 3/4 inch?'"
  global sidewallchoice=request_boolean_from_primary_client("Is the sidewall 3/4 inch?")
  $ 98 "If sidewallchoice"
  if (sidewallchoice):
    $ 99 "sidewall≔0.628"
    global sidewall=0.628
  else:
    $ 100 "Else" "noBreak"
    $ 101 "sidewall≔0.375"
    global sidewall=0.375
  end
  $ 102 "floorchoice≔'Is the floor 3/4 inch?'"
  global floorchoice=request_boolean_from_primary_client("Is the floor 3/4 inch?")
  $ 103 "If floorchoice"
  if (floorchoice):
    $ 104 "floorthick≔0.628"
    global floorthick=0.628
  else:
    $ 105 "Else" "noBreak"
    $ 106 "floorthick≔0.375"
    global floorthick=0.375
  end
  $ 107 "Set"
  set_tcp(p[-0.0095,-0.328,0.105,1.2092,-1.2092,1.2092])
  $ 108 "MoveJ"
  $ 109 "Waypoint_46" "breakAfter"
  movej(get_inverse_kin(Waypoint_46_p, qnear=Waypoint_46_q), a=1.3962634015954636, v=1.0471975511965976)
  $ 110 "Set"
  set_tcp(p[-9.8E-4,-0.015880000000000002,0.284,0.0,0.0,0.0])
  $ 111 "Test_Teach_Position()"
  Test_Teach_Position()
  $ 112 "Set"
  set_tcp(p[-9.8E-4,-0.015880000000000002,0.284,0.0,0.0,0.0])
  $ 113 "kill threadId_Thread_1"
  kill threadId_Thread_1
  $ 114 "Corner_Homing_45()"
  Corner_Homing_45()
  $ 115 "Set"
  set_tcp(p[-0.006900000000000001,-0.329,0.10490000000000001,1.2220414998940743,-1.2008968373596993,1.2220414998940738])
  $ 120 "If leftchoice≟ True "
  if (leftchoice ==   True  ):
    $ 121 "pathturn≔main_calculate_left_extended(p11,p12,p21,p22,p3,p13,p23,sidewall,floorthick,tcp_pose_top)"
    global pathturn=main_calculate_left_extended(p11,p12,p21,p22,p3,p13,p23,sidewall,floorthick,tcp_pose_top)
    $ 122 "extrude_knife3()"
    extrude_knife3()
    $ 124 "move_path_3left()"
    move_path_3left()
  else:
    $ 125 "Else" "noBreak"
    $ 126 "pathturn≔main_calculate_right_extended(p11,p12,p21,p22,p3,p13,p23,sidewall,floorthick,tcp_pose_top)"
    global pathturn=main_calculate_right_extended(p11,p12,p21,p22,p3,p13,p23,sidewall,floorthick,tcp_pose_top)
    $ 127 "extrude_knife3()"
    extrude_knife3()
    $ 128 "move_path_3right()"
    move_path_3right()
  end
  $ 130 "MoveJ"
  $ 132 "Waypoint_20" "breakAfter"
  movej(get_inverse_kin(Waypoint_20_p, qnear=Waypoint_20_q), a=1.3962634015954636, v=1.0471975511965976)
  $ 133 "Home"
  movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
end
