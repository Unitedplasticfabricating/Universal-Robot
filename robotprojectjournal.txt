Robot project journal
Started: Monday 6/10/2024
By: Calvin

Monday I worked on assembling everything except the robot itself. I physically mounted the UR controller box, the MachineMotionV2, the robot safety module, and the emergency stop. To do this I had to take all the boxes apart and find the screws, allen wrenches, 
No instructions. No wiring diagram
Had to wire all the shit together. Screwdriver
Found weights to counterbalance
Got the robot mounted on with a forklift
Needed to know that my ip address wasn’t going to be in the pool of florida ip addresses
Robot safety module was preventing the lift column from operating so I removed that
Installed the urcap software via the usb drive onto the ur
Linked machinemotion and ur via static ip addresses and ethernet cable. 
I learned that program files are saved as program files on the pendant.
I learned that installation setups are saves as installation files on the pendant. If you plug in a usb into the pendant, I think you can transfer files into or out of the ur.
I think you don’t need the vention usb inserted into the pendant to access urcap functionality. It installs the program on the pendant itself and connects via the ethernet cable and staticip.
I got the robot oriented correctly in virtual 3D space, saved it as default.installation, backed it up onto flash drive, and saved it to github. 
I calibrated the TCP and payload for a robot with no end effector. 
Reminder: On page 125 of the manual, it talks about Manual Mode vs automatic mode. Manual Reduced Speed is the default. I need to figure out how to switch to Manual High Speed and have it set to do that as the default. 
Reminder: Installation -> Safety -> Tool Position has a warning symbol. I need to read section 1.24 in the manual Software Safety Configuration to figure out what the warning is. 
Reminder: set the Home position
Software Safety Settings. Password is plastic
Discovered joint limits for every axis is 363 degrees to -363. So, almost two full rotations around. The maximum speed for each joint in “Normal” or “Reduced” mode is 131 degrees per second, or 221 degrees per second for the wrist joints. 161 for elbow. So far, the robot has not come close to that speed. 
I was able to do a full backup of the robot. I went to the pendant’s hamburger menu -> settings -> backup restore or whatever. I gave a huge .urb file, which I think included the entire operating system of the robot, not just programs, installations, and variables. I was able to push this file into fork on the local branch, but I couldn’t push it to github because the file size was too large. So, I “Reset main to here” in fork to remove that commit. The file is one folder up in the “C:\Users\cbaumgartner\Documents\UPF source code”. 
I successfully made a square motion program!
I tried to make a peg welding program but received an error. Joint acceleration failed to pass sanity check. I think it’s because I tried to do a MoveL directly over the base. Anyways it errored and locked me out. When I try to restart the robot (safety system), (the 5 step process), when it releases the brakes it keeps erroring. It says “Fault: Robot cannot maintain its current position. Check if payload is correct”. Weird. 
The urp files are all gibberish, the ones I made myself. It looks like the original ones like the one that came preinstalled on the robot contain xml like structures, but the ones I made are compressed. 
I installed python to make a script to decompress those files. 

Big breakthrough
I talked to Luca from vention. For the robot stopping and faulting, we figured that out. I set the payload to 0.o kg (down from 1.3). That was what was breaking the program, that it was off by 1 kg. Sometimes the payload wizard in UR is not very accurate. So he recommends weighing the payload and getting that exact by hand and entering it in. For the payload center of gravity and the tcp position, you can use the wizard. 
He agrees with me that the initial breakage was caused by using a moveL in a large movement over the base. moveL should only be for smaller movements or movements that you know aren’t going to be too close to singularities. After changing the payload to 0, I ran the same program (with the moveL). The program stopped because it said “cannot achieve the requested position” or something like that. However, it did not power off the robot. I just hit enable and had to angular move the joints manually (fourth tab) to get myself out of the knot. 
Next, I set up the urcap. My computer was not connecting to the machinemotion at 192.168.7.2. Luca emailed me directions (6/26/24) for how to set up the urcap connection to allow the robot to control the lift column. I called justin to get the connection working. 
Computer was not connecting to 192.168.7.2 in chrome. What I had to do was unplug my ethernet cable from both sides. Turn off machinemotion. Unplug machinemotin’s power cqable. Hold down its power button for 20 seconds to release any stored energy in capacitors. Then turn it back on. After this, my Ethernet – Network 3 icon in control panel -> network and internet -> network connections changed from no connection to ethernet. And going to the chrome ip worked. 
Next, I wanted to get it so the robot could control the lift column. I went to http://192.168.7.2/networkConfig. Under ethernet settings, I clicked LAN1 which is where the cord is plugged into. I set that to 192.168.3.52. Justin had to look in dhcp to find one in our network that wasn’t being used, because I don’t have that permission anymore. He then said he reserved that ip for me. 
Then I went into UR settings on the pendant and changed the robot’s ipaddress to 192.168.3.53, which was also available. Justin also reserved this for me. I then went into installation->urcaps and configured it to be 192.168.3.52. and saved the configuration. 
I then created a new program to test whether the urcap works. It does! When I played my program in automatic mode, it did raise thelift column by 10mm (which I specified). 
Also, when I clicked the UR+ button and jogged it, it did raise the lift column as well. 
The UR+ button only works when in automatic mode, or it does work in manual mode but only when you have the 3pe button pressed. If youre in automatic mode and jog the column, then switch to manual mode, the column will continue its jog but then will not take any more inputs unless the 3pe is pressed. You can hold the 3pe, press the jog button, wait for the column to start moving, and then let go of the button. It will finish its move. 
Reminder: you should figure out a way to change the settings so that you don’t have to hold the 3pe even in manual mode because that’s annoying. OR find out how to enable everything from automatic mode

I switched my journal to a txt document so i could copy into repo easier and see the changes. If i want to make it pretty i can always copy the text into a word doc. 

I completed copyfilesintorepo.py which is sweet. i plug in the flash drive, run that program, and commit fork. super easy to source control all my changes on the UR. 

Programs can be saved as files and run as a subprogram. To do this, start editing the main toplevel program. Click robot program. Click SubProg. Under subprogram file, select your file. This will open the file as a subprogram. 
By default, making changes to this subprogram will not affect the parent file. 
By default, making changes to the parent subprogram will not affect the loaded subprogram. 
If you want to change a subprogram, you can change the parent subprogram and save. then go into the parent program, loaded subprogram, and reload to pull the changes. 

How to enter freedrive mode mid program:
You can look at using the “freedrive_mode” script call to set the robot into freedrive mode and the corresponding “end_freedrive_mode” call to stop it. You can look at the URScript manual for understanding both of these functions.
In your case you could possible set up a thread that watches the digital input for enable/disabling the freedrive mode.
https://forum.universal-robots.com/t/open-and-close-the-freedrive-switch-while-the-program-is-running/18046/2

save tcp pose as a variable: https://forum.universal-robots.com/t/creating-a-variable-waypoint/19366

the types of variables are: bool, int, float, string, pose, list (page 163). 

I need to learn about rotation vectors in UR. i want to align my tcp perpendicular to a cardinal plane. But i have no idea how rx, ry, and rz work or what they mean. 
Apparently (according to the internet), UR uses axis-angle representation of rotation vector (opposed to RPY roll-pitch-yaw. I don't know what that is either). 

Coordinates/directions:

Feature: view. this is when i aligned the robot with the direction i wanted it to face
Rx=0, RY=0, Rz=0 is with the tcp pointing straight up
The x direction is straight out in front of the robot. specifically, -x.
the y direction is to the right. positive y is right. negative y is left

Feature: Base. this is the preset orientation of the robot. in this view, pushing the forward button makes the robot come back towards me at an angle
Rx=0, RY=0, Rz=0 is with the tcp pointing straight up


I watched some good courses on virtual reality and representation of 3d space by this guy from University of Illinois at some IIT school. I learned different representations of orientation in 3d space. 
1. Euler's yaw, pitch, roll with respect to airplanes (commutative, respect to horizon, not uniform especially when approaching vertical)
2. Euler's yaw, pitch, roll with respect to fixed cartesian axes. (not commutative)
Axis angle representations: length of v is 1 (unit vector). 
3. axis-angle representation in Exponential syntax 
	[(v1, v2, v3), theta] -> (v1*theta, v2*theta, v3*theta)
4. axis-angle representation in Quaternion syntax
	[(v1, v2, v3), theta] -> (cos(th/2), v1*sin(th/2), v2*sin(th/2), v2*sin(th/2))
	
Based on that info i came back and ran the robot in Base mode. Here the buttons are labelled. 

zeroing out all the Rx, ry, rz made the robot point straight up. 
pressing each button worked the same as rx:
	i press rx and the tool moves. Imagine an axis through the tcp parallel to the fixed cartesian x axis. The tool rotates around that axis. I then send the tool back home.
	while i am going, ry and rz values remain at 0. 
	rx value increases consistently, hitting .785 when the robot has rotated 45 degrees, 1.57 when the robot has rotated 90 degrees. 
going back to 0,0,0 rotation and using the other buttons worked the same way. they rotated the tcp about their axis. 
entering a value of 7 resulted in a value of .717 (7 - 2 pi)
crossing the 6.28 barrier manually moving results in the angle dropping back down to 0.01

next experiment:
i set the tool orientation to 0,0,0
i rotated rx to +.785 using the rx+ button. 
i then pressed the ry+ button. it rotated the tcp with respect to the y axis. not only did the ry value change as i went, the rx value changed as well. so did the z value. 
rx decreased to -.741, ry went from 0 to .760, rz went from 0 to -.318

Based on this, I hypothesize that the rx, ry, and rz values in the upper right corner (orientation coordinates) are defined using axis-angle representations in Exponential syntax. 

I also hypothesize that pressing the rx+, ry+, etc. buttons do not simply increase the rx coordinate and calculate the resulting position. 
	They send a small increment of a transform about the x axis (something like a (0.1, 0, 0) transform vector and calculate the resulting exponential syntax of that transform. 
	This is why the other values sometimes change when you give a simple ry+ command. 
	so, holding down the ry+ button will make the robot perform a rotation about the y axis. But a rotation about the y axis most likely will change all 3 values in exponential syntax. 
	
You can set the rotation vectors to (90deg, 90, 0) or (.785, .785, 0). It looks like it's pretty close to a 45 degree rotation in both the x and y axis but i'm not sure. 
An example of this is that I set rx = 90deg (1.57), ry = 90deg (1.57), rz=0. it found the position. 
	the robot was pointed slightly down and at an angle. it was not orthogonal to any of the major axes. 
	however, projecting onto the x-y plane, the robot was at a 45 angle to the major axes. 
	this only makes sense if you understand axis-angle representaion with Exponential syntax. 
	
I need to make a list of the common orthogonal positions and common 45 (45 degrees with respect to one plane, ortho/parrallel with respect to the final axis) positions and their Exponential representation
	so that i can quickly position my robot in that orientation at a given position. 


I need to learn how to combine the position coordinates of a stored position (x,y,z) with manually setting the orientation coordinates. Maybe could be pose_add(), pose_sub(), or pose_trans(). 
update: they are hard to understand
look up how to manually enter poses
they used pose_trans() with a p[0,height,0,0,0,0] to manually tell it to go up height meters. 
https://www.universal-robots.com/articles/ur/programming/moving-to-a-position-calculated-from-user-input/
ill look up how to create my own function . cant

coordinate system:
i found out that the X+ direction is out away from the base. forward

for homing, use a tcp on the side of the gun. if the gun is attached sideways, then have a "rubber tip" "through" the gun (parrallel to robot arm). 
set this as a separate tcp in installation, and call the homing commands using that tcp.

the homing program wasnt working because of how the test box was mountd on the table. when it was homing on the bottom face, it was hitting into the table and faulting. 
i looked at the station in the express cell line and this isn't going to be a problem out there.
we are going to change the attachment of the test box to the table. in the mean time, i will adjust my program to avoid the table. 

i made a Main Method, and put test teach position into it. the thread that was part of test teach position did not come. running the program did not put the robot into freedrive mode at the correct time. 
copying over the variables setup and the thread into Test Main Program did make the program work. 

god damn it. 
it doesnt like nested subprograms.
i have some programs for aligning the tcp with a cardinal direction. 
my program corner homing brb contains calls to those alignment subprograms
i tried to put corner homing brb into my main program as a subprogram. robot didnt like that. 
it said 'the subprogram contains one or more calls to other subprograms. open corner homing brb and remove any contained subprograms, save, and then try again to add it.'
https://forum.universal-robots.com/t/subroutine-within-subprogram/12634 says you can do it as a subroutine, as a subprogram within a script block, or as a user-defined function

i added the plate to the robot end and added a tcp and payload into the system. 
when i set those as the active payload, the robot does some weird stuff when running the program. it bonks into itself when trying to align left

work on one corner. perfect that. and move the robot roll wheels to each corner on the tank.

want to reorientate the robot on the stand. everything is opposite
right now the cord is pointing left (when looking WITH the robot). we want the cord pointing right
robot reoriented with forklift

i learned you can use breakpoints in the software.
i learned that a subroutine is just a call to a subprogram.
script commands can be done using a single line or via a file
i need to try out this file script editor. 

i got the robot to follow the path on both sides, but when it goes around the corner, the angle dips. it does not maintain level orientation. 

maybe i need to do a "circle move" as part of a moveP command while welding and going across the corner. 

i try making a test circle move program out in space. it does not work very well. 
when the orientation switches from left to forward, the arm does a weird swivel to orient itself. it seems like an unnecessary swivel. when i use those points in the program of a moveP, the robot faults out. 
it is trying to maintain its speed (a pretty slow speed), but it needs to rearrange its joint angles to move just the slightest in tcp. 
i believe this is called approaching a singularity

i set a position by manually rotating the joints (instead of using the Move screen's rz+) and that did result in the robot not doing its weird dip. 
but it faulted because it needed to move at a constant speed and the distance was super small and the direction change was a lot.

motherfucker i dropped the speed down from 250 to 20 on the entire path.
it went so slow on the straight part, "sped up" a little on the curved part and then partway through the curved section stopped. 
warning: sanity check
protective stop: path sanity check failed: sudden stop
i will try ensuring that the three points on the path for a smooth curved
6.35 mm = .25 inches

rx,ry,rz patterns:
i go to align_left, then spin the head manually with Move Rz+ to a 45 degree angle. During this time, the ry and rz values go from 0 and go up. they are always equal.
i need to figure out what the angle is for align forward/left 45 degrees

it looks like th script feature in the robot does python but doesnt do tuples. damn. 

i need to calculate the midpoint of the arc turning around the corner
https://math.stackexchange.com/questions/4694976/calculate-length-between-intersection-of-circle-and-2-tangent-lines-relative-to

i got a program going. it goes smoothly through p2. but it stops at p2 (i put a breakpoint) and the center of the tcp is still 1.25" short of the end of the box
super weird. could my intersection calculations be off?

i added popups to the program so i can see what the coordinates are for all the points its calculating
i plotted the points and the points look fine
lucas took a video for me while i was performing the circle move. the tcp (end of robot) is in contact with the box and thats why it stops. 
BUT its supposed to be in contact with it. in the video, you can see the robot performing the desired motion. 
It is not "trying to go through" the box as much as it is just sliding around the corner of the box
so, the contact here is good. I don't need to change the motion, I need to tell the robot to not Fault out when it feels contact
I think i can achieve this by adding a force effect
additionally, after faulting out, i clicked Enable and continued the motion and it worked as intended, went to its desired position point 3

I made a test program to test whether the Force command actually worked
i set two waypoints a few mm off the side of the box, and moveP'd the robot from one point to the other. the robot did not touch the box
I then put that move command inside a Force command of 5N. It now touched the box and i couldnt fit a piece of paper or plastic in between the toolhead and the box while it was running

adding the force command to the main program still results in a protective stop while rounding the corner. i wll try specifying the tcp and also trying a larger newton value.
another thing to consider if this doesnt work is temporarily turning down the protective stop sensitivity, hopefully just while performing that force move

found a video on protective stops: https://video.universal-robots.com/tech-talk-understanding-protective
faults, violations, and protective stops are the three ways the robot can stop due to itself observing that something is wrong
a protective stop is issued when the robot can no longer perform the intended motion
a violation is when a safety system observes that a safety limit is exceeded
a fault is when the safety system detects a fault in the hardware or software
a torque window is the amount of current the robot expects to use in order to accomplish the necessary motion. if it needs more than that (outside the window), this is an indcator that the robot is blocked by someone or something.
"scaling" is lowering the acceleration for normal payloads or heavier payloads. 

i will try changing the variable in the program to .03 inches (a 32nd of an inch) down from 0.25 inches, so that it doesn't try to go into the box
I got rid of the radius and changed the rotation command from a moveP to a speedl() in script. 
when i do it in the main program, it sometimes gets singularity errors
it sometimes gets protective stops because point2 is stopping too early and turning into the box. but when i look at the intersection point, it is accurate
i figured out one of the problems. i switched the moveP from p1 to p2 into a moveL, and now it stops at the correct point. 
I believe it was stopping early before it got to point 2, because of a blend radius (25 mm = 1 inch). that would explain why it was stopping one inch too short. 
the singularity thing is still there when i do the speedl() command

I figured out why the singularity is happening. 
when all 4 axes are aligned, this is an example of a singularity. when it spins from the first edge to the second edge, it passes through a position where all 4 robot axes are aligned. 
i think the robot can make it through this position if it is part of a move command, but stops if it is part of a speedl() command or a manual move (fourth tab on pendant).
i have a video from july 30 where the robot is performing the "around the corner" motion in space, and it hits the singularity, drops its wrist below (which interrupts the motion), but then continues on. 

I figured out that i needed to mount the welder sideways on the cobot (the ryan orientation) in order to avoid the singularity
I batched, cut, and welded a demo welder the same dimensions as the mak-rob.
now i need to figure out how to atach it : both the model and the actual welder
talked to lucas and ed because ryaN WAS WFH. considered brass inserts, mounting plate, etc. the problem is you need clearance in order to tighten the bolt head, and most of the designs they came up with do not have clearance to tighten the bolt heads. 
considered threaded rod
talked to rick about clearance. plan is to make a demo mounting plate out of 1.5" plastic. if it works, get it made out of 1.5" steel
countersink bolt heads on both sides. bolt the plate onto the weld gun first. (because there will be no clearance for this after plate is attached to robot). 
then bolt plate onto robot. there will be clearance for this on either side of the mak-rob's metal plate. 
if there is not enough clearance for this using the holes on the tool flange adapter (4 small holes), then switch to mounting it straight onto the 6 main holes (slightly wider spaced). 
i need to add that metal block chunk to my model of the welder (in plastic). i will use real brass insert though. 
i need to find which bolts fit into the welder block, which bolts fit into the tool flange adapter, and which brass inserts i need to replicate the holes in the welder block. 
then i need to cut a batch out of 1.5" that includes the model of the block and the mounting plate with holes and counterbores. 
then weld the block onto the model welder

Determined that the pretend gun, screws, and a pretend block are 3 lbs 11 oz. the pretend block was 7 oz of that 3 lbs. the real block is almost twice as much. guess = 4 lbs exactly if we replace the pretend block with the real block. 
add the 0.31 kg of the plate and plate screws to that and we get a total of 2.124 kg for the pretend gun setup. 
begin installation for that. 

tcp orientation
i want to have one tcp for probing. that will be the topside of the gun and will have the same orientation as normal. 
the second tcp will be the weld tip. its orientation must change so that i can use the convert_heading_to_axang() function and have it be correct
to do this i have to set up the orientation at 0 so that a 90 degree rotation cw about the +y axis will result in a heading of 0 (respect to the +x axis).
the position that accomplishes that is the robot end facing backwards and the tip of the gun facing up
to get there from the natural rxryrz orientation, we need to first rotate clockwise, then rotate backwards. 
ill first ask openai to calculate that for me and see what it gets. i have it in position but it's not exact. if openai gives me something thats close to what i have (few decimals off), then ill know its right
it kept giving me (0,1,0,π), which i know isnt right. its supposed to be around (2.28, -2.54, 2.52). 
the first rotation is (0, 0, -pi/2) (in exponential) (rz- by 90 deg)
then we rotate in the ry+ direction. (0, pi/2, 0) in exponential. 
apparently (rx,ry,rz)=(vx⋅a,vy⋅a,vz⋅a), is referred to as the rotation vector or Rodrigues vector, not exponential coordinates. 
ill rotation matrix this out.
-y becomes positive z. positive y becomes - z. 
positive z becomes positive x. negative z becomes negative x
positive x becomes - y. -x becomes positive y. 

the appropriate rxryrz is (-2pi/(3sqrt(3)), 2pi/(3sqrt(3)), -2pi/(3sqrt(3))) = (-1.20919958, 1.20919958, -1.20919958)
i type this into the move screen and the robot barely moves, indicating it is correct. It immediately converts that rxryrz into: (2.419, -2.419, 2.419). 
it must like that better. i know in axis angle representation there are always two equivalent rotations to get the result. 
if you flip the axis and negate the angle you will get the exact same rotation. to avoid duplicates the robot program must have some rule where it chooses which one. this is fine. time to test. 

testing worked golden for that part. now i need to adjust my programs so that it works with this new setup. 
when it gets to the align_left() command in main program, it does not work well. it does align leftwards, but it also moves the tcp so that it misses the corner. 
i tried changing the moveJ command inside align_left() and align_forward() from "Use active tcp" to "pretend_w_top". but that didnt work it still moved the tcp. 
i paused the program mid program with a breakpoint. I went to the move screen and i saw that the active feature is Base and the active tcp is tcp_plate_1. this is a problem
i need to figure out how to change the active tcp. the default tcp is already pretend_w_top. but how to change the active. apparently they are different. 
use the set command

running align_left() as a standalone program works perfectly. tcp stays the same and the gun rotates around the tcp. 
but running align_left() within the Main Program does not. it moves the tcp when it aligns. 
even after re-adding the align_left() subprogram to Main Program, it still rotates about the end of robot (old tcp) when performing align_left. 
i went back to the move screen and now it says that the active tcp is tcp_1_plate. wtf.
i step through and debug to figure out how this happened. i set a breakpoint after Set and after Test_Teach_Position(). at the start, tcp is plate1. after Set, tcp is w_top. after Test_TP(), tcp is plate1. 
it could be that the sync() to the thread is causing the tcp to get switched back. 
nope. there is a command in test_teach_position (moveJ) that sets the tcp to plate_1. stupid me. 

GOT IT!
fuck yeah
it completes the entire weld, pretty smoothly (tiny jerk at the start of the corner, i could reduce the acceleration value there), goes back to home and is ready for the next iteration. 

How to attach welder (fake):
attach tcp plate to welder. 
screw on mounting plate to tcp plate. (extension the same direction as the black dot on wrist 3)
screw on welder to mounting plate (weld tip pointing same direction as black dot on wrist 3)

corner homing 45 - want to make the corner homing more robust. for the normal corner homing, if the robot is too close to the tank, it hits itself when homing, going around the corner or under
if the tank is too far away, when it tries to home on the left side, sometimes it maxes out the reach of the robot arm.
there is a pretty small window for where the robot can be in relation to the tank and have it still work.
in order to increase that window, we want to switch to a corner homing that's 45 degrees from both faces of the tank. that way we dont have any crazy reaches. 

during corner homing 45, the first side works very well. when it goes over to the second side, it has a clamping error. 
if i rotate the wrists differently, (and slightly move shoulder elbow up) i can achieve the same position and orientation without the clamping. 
there are multiple joint angle combinations that result in the same position-orientation of tcp. 
i want to prep the robot to use the joint angle combo that does not have clamping. I set a fixed waypoint (waypoint 5) that is close to the base and in the orientation that i want to use for ph4. if i go to this before moving to ph4, the robot will use the preferred joint angle combo at ph4.
unfortunately, the preferred jointanglecombo at ph4 results in wrist3 rotation exceeds limit, with a wrist3 rotation of over 360 degrees. i need to do a 360 spin of wrist3 on the way to the preferred position. 

when doing my complicated spin \ rearrange motion, i need to make sure there are no variables involved so it does the exact same thing every time. 
i need to make sure i go from fixed waypoint to fixed waypoint before going to the variable waypoints again.
i can do this as a combo just with waypoints, or i can also include a speedl of wrist3 in there to do the 360 spin

ok cool so that worked, setting intermediate waypoints to do the turns, flips, and bottoms and all that stuff. 
we even attached some weld wire to the pretend welder and also attached it to the robot arm above wrist1. worked pretty good. didnt get tangled. we only needed like 10 inches of slack. it did get caught on the L bracket when coming back to home. 
need to have it come back to home from above or something. idk. not really that important now until we get the actual welder mounted. 

next i want to work on the R/L second pass of making the weld go up after it comes around the turn. 

calculate the rotations needed to weld vertically starting from the bottom and going up, with the right side of the welder (preheat tip) leading
i put the welder into 0 orientation. at this point, the tip of the welder is facing straight up and the bottom of the welder is facing x- axis. 
i need to figure out a rotation that will put the welder within a yaw of correct, no matter what angle the box is at. 
i need to put the welder with the tip facing the x+ axis, with the preheat (right side) facing up. 
a rx of 90 degrees (from 0,0,0) puts the welder tip facing the y- axis with preheat up. 

I also want to to a full heating pass before I start welding. I will use a separate TCP (welder_preheat) that is like a centimeter out farther than the actual tip of the welder, and make it follow the same points the weld is going to go. 


I got the full program working for how I thought the weld path shouldve went. clockwise from right to left along the bottom edge, then moving back and welding up from bottom to top. 
It works pretty smooth and doesnt tangle itself. 

However, Andrew wants a different weld path procedure. 
Ron sent a video of what they are doing in florida. first you come down from the top, then fork right (if its a right side weld). then you go back to the weld path intersection, and turning clockwise, go around the corner and continue onto the left side. 
This path involves two turns instead of just one. One L turn, and then a wraparound turn. 
Personally I think this way of doing it is going to be less good. More turns means more places for potential error or leaks, plus its harder to code. But its not my company. 
Before I can connect the points I need to find more equations for heading_to_axang: the orientation of the vertical weld going straight down, and the orientation of the weld moving to the right (ccw). 

for the vertical weld moving downwards, the first turn is about the x axis the other direction. and then -pi/2 not +pi/2 for the heading angle. 

for the ccw weld around, rotate about the y axis 90 degrees, opposite of the first equation. then for final result add pi to heading. 

full weld path is working
is it robust? can the robot be positioned a little closer, a little farther, or at a different angle and have the program still work?
no
the problem is going to be the bottom part of the L (for right side). in the current path, it works. but i paused it at the bottom of the L, after it has turned. 
if i move (speedL screen) 17 mm back wards (x+), the gun butt hits the robot forearm. 
if i move 55 mm left (y-) then the butt hits the forearm. 
if i move 126 mm down, the gun butt hits the forearm
these are pretty small changes. meaning we are pretty close to the edge of viability. the range of viability for this setup is how i had it and even further out. anything with the robot closer to the box will not work. 
this second turn really sucks

one solution we thought of was to raise the tank up, like on a lift table
another solution we thought of was to move the welder forward on the mounting plate. this would require a new mounting plate to be fabricated. 
in order to do that and test the new plates i cut out of plastic, i want to unattach the welder and try out the demo welder. 
the amount of slack we are using on the cords is perfect. how much is it?
it is 44 inches of cord slack, measured from the white base of preheat to the tape on the robot arm. the three cords are zipties together at a couple locations along that path. 
it is attached 5 inches up the arm, measured from the tape to the black line opposite the wrist 1 joint. 
it is attached on the top. this means at home position, the cord attachment is on the x+ side of the forearm. 

i batched a mounting plate with the attachment extended 2 inches past standard. 
I attached the pretend welder, and made a new home and tcp for it.
ran the program and it worked great. ran it again to see how much leeway we have:

if i move 207 mm back (x+), the gun butt hits the robot forearm. 
at x-1171 (normal position), i can move the arm left (y-) as much as i want and the gun butt will not hit. 
at normal position, i can move the arm all the way down with no interference

the rockets used in station 3 are 27-36 inches tall. including all the beams and stuff the tank floor would sit 36 inches off the ground. 
our test box is 42 inches tall. luckily, going from 42 to 36 inches doesnt change the forearm angle very much at all. 

ill put tape marks on the floor under the base's back two levers and see and see if moving the base causes any collisions
a folding arm on the front of the tower. go/nogo for robot base alignment
have an arm attached to the front of the tower. telescoping. it fold out straight away from the tower. on the end it has a "Y". the crook of the y is about a 110 degree angle. 
tell them to use the arm checker the first ten times they use it, and the first time every day. 

actual welder mounted on 2 inch plastic mounting block and calibrated.

how to hook up the welder. the power box came with a euro 230v plug. that needs to be changed to an americas 230v plug. 
also, there is no 230v outlet in the back corner. we will need to do electrician work to provide one. 
after that gets hooked up, the control box on the welder, and the robot welder operating instructions, should provide an easy way to turn the gun on manually. (not extrude). 
the robot welder Heat Control Serial manual says that the 9 pin connector into the control box, some of the functions of HeatControl can be controlled via a RS232 serial interface remotely
bing copilot says A 9-pin connector, often referred to as a DB9 or DE-9 connector, is commonly used in serial communication applications

i asked vention for advice on how to convert UR output into DB9. we will see what they say. 

ok i think i got it. i need to send a signal through the digital output into pin 3 (RX). 
and that signal needs to be üR1
no. digital output can't send ascii signals. according to vention, it is only able to send digital dc voltage signals or pulses. 
i need to send the signal via the usb port (Universal Serial Bus), and using a USB to DB9 converting cord, with URCap to properly send USB to RS232 signal. 
i found a URcap that has that functionality, including a special mode to send special characters (needed for the start of signal sequence). 

Dude, the electrical guy STILL hasnt given me an outlet. I need a 230v outlet to run the gun. I would like to do the testing back in my robot corner. 
Linking multiple extension cords can decrease the voltage and cause power drop, affecting the gun. dont really want to do that. 
its been 3 days though and im kind of just waiting for that. the motion is good. just waiting to add the extrusion aspect of it. 

slack vacuum hose exp:
~44 inches of slack. attached at the right side of welder cage, pointing backwards/down. other side attached ~8 inches up forearm attached on downward side (when in home position).
this seems to work pretty good. 

dude the gun is all fucked up. 
we turned on the gun the normal way (using the buttons) and almost immediately it gave an oeair error. 
the temperature for the material and the preheat was set correctly. the live reading for the temperature was looking good, but the live reading for the preheat kept saying 43 degrees. 
we think there might be a problem with the air pressure. we are using shop air, with a pressure regulator (and pressure sensor after the regulator). 
it also could be a bad wiring connection into the preheat region. we replaced the clunky wiring connection box with a soldered twist on connection. could be a bad solder or a crossed wire. 
wade is colorblind so that doesnt help. 

the password to get into the munsch menu is 8980 (down down check down check down down check check)

welp. using the usb to serial cord with my computer and putty did not work. putty was kind of clunky to work with and i could not get any response from the gun. no commands registered. 

i installed the urcap for wiretank serial
bingo!
we have success. 
i successfully sent a bytearray command to the welder to start heating. i also sent a command to the welder to stop heating. both worked. 
i have so far been unable to receive any commands back, whether from a uR1 command or from a uR? command. 
i think it may have to do with the installation-term characters. 
before i mess with it i want to save it those

the text i receive from a query always says "Operation timed out!"
i think maybe it has to do with the term chars. 
i first tried CR for both. then i tried None for both. neither worked. 

we got the gun to extrude. that is successful. we had to buy a 5V DC power supply and solder it onto the end of the 5 prong cable they gave us. 
Definitely weird that they required us to solder wires together in order to get the gun to run. Feels like munsch didn't send us a finished product. 

We compared speeds to the extrusion speed of a normal MAK 18. We decided that a speed setting of 4 was equal to the normal speed of a MAK 18. 

Wade is replacing the wiretaps of the thermocouple with some extra wires and soldering that in place so that the robot isnt motionally constrained. Next will be a straight weld test. 

straight weld test was a HUGE success. the welder welded amazing welds every single time. 

corner weld was mixed results

there is something weird where twice now the program said uR1 and sent the command but the welder did not start extruding. Im thinking maybe the signal didnt get heard for some reason. 
We ran the exact same program again and the extrusion happened (both times). something to keep an eye on. 

we have been adjusting the extrusion times of when to start and stop extruding along the path. 

one problem i need to fix is the Around portion the extrusion hole is kicking out around the corner in open space leaving a really poor weld there. 

Also, the straight welds of the corner isnt as good of quality as the straight welds of the actual straight. 
Could be that the box is missing a chamfer on one side. 
Could be that the welder is too far from the box. 
I want to adjust the tcp to push the welder closer to the box. 
Adjusting the tcp to push the welder farther into the box would be a y- move in tcp. (no, a y+)
adjusting the tcp to move the tcp back from the tip towards the hole would be a x+ move in tcp. (unsure)
adjusting the tcp to tilt the angle farther onto the back of the shoe would be a rz- move in tcp orientation, performed after the currentorientation moves. this would require rotation matrix calculations. 

when we switched to the double chamfer box, the welder in the Down weld was not in the right position. 
the tip was not far enough in the chamfer, and it was resting on the left side. 

i recalibrated my tcps according to what i needed. measured the adjustments that i needed to make and made them. 
the path it follows is perfecteverywhere except for the very top of the first weld. 
this is because the box is not level. the vertical face is not vertical. so that makes sense. it still makes a good weld. 

performing this weld yields pretty good results. the first two welds - straight section - are pretty clean. 
the first corner looks idk. kind of goopy. hard to tell though because the second pass changes it. 
the second pass needs adjustment. the triangle tip drags/pushes through the weld goop, and the tail end swings out, welding into airspace. 
because of the triangle tip pushing through, there is goop in front of the triangle for most of the third weld, resulting in an unclean weld. 

my solution is to add a third tcp (weldhole) that is pushed back from the tip to the hole. this third TCP will be just like pretend_welder, but have an adjustment in the x direction

it looks like the first turn does go faster now that i sped it up. im not sure how much faster. 
tomorrow i need to edit the script to control the weld distance separately of all the different welds. for example, i want to decrease the second weld distance. 

we welded three boxes. 
box 2: corner1: original
corner2: added rod straightener. removed trigger halfway through first rotation. it was funky and didnt extrude enough stuff out. could be that rod straightener was too tight or an air gap. 
corner3: reduced wd3 to 3 inches
corner4: same as corner 3? i think. 

box 3: corner1: same as box2 corner 4, but with the rod straightener slightly loosened. 
corner2: same as corner 1
corner3:changed the preheat pullback so it didnt pull back as far. it hit the weld
corner4: changed the preheat pullback so it wouldnt hit the weld. it just brushed the corner. 

box4: corner1: same as box3 corner4
corner3: dry ran because weld rod broke. also bad signal send. 

finished the right corner program except for the extrude knife subprog and the connectivity issue. 
now i need to take my changes from the right corner and apply them to the left corner. 
ill start with the script function


im looking at the home position and how to get from home to the welding positions. it involves a weird turn. 
with the new sleeve around the cords, the path i had before pinches the cords on the way from home to weld approach. 
i have two options: 
1. fix the path waypoints so it doesnt pinches
2. change home position so that i dont have to swivel joints to get into position. 

there is a home position that's nearly the same position, but it is very close to joint limits. 
if i were to change the home position, i would have to change my approach to everything, not just approach to welding. 

when i changed the home position, then tried to go through and edit the program, i couldnt edit waypoint2 in test teach position. 
when i tried to set that point, before i could reaach the position, my wrist2 exceeded joint limits. 
so, i cannot use the new home as i had planned. 
i could use normal home fro the start and then go to newhome in between the tap and the weld (during extrude_knife). 
but i dont think i want to. if i have to switch between oldhome and newhome ( and do that wrist-around) at least once during the operation, it might as well be as-needed (right before welding). 

ryan wants the home position to be deeper inside the cup. 
i tried keeping the home position just above the cup so i could get there easier if i needed to go home from a weird spot, 
and then adding a separate starting point for the program. but ran into another problem. 
the initial waypoint is tcp-specific point in 3d space, not joint angles. so if a different tcp is active, the position will be jacked up. collisions probable.

i need to set the home position to be inside the cup. set the above cup as a waypoint in the program. 
i also should look into safe home. 
correction: dont use safe home in installation, use Add Before Start Sequence
https://www.universal-robots.com/articles/ur/programming/creating-a-safe-home-routine/

i began starting that safe home program. should probably be a subroutine. maybe that works maybe it wont. 
maybe i have to leave it as a folder. should be able to copy and paste a folder anyways. 
i need to figure out where in the process of the weld it was stopped in, and based on that, provide the safe rotations back to home. 
figure it out based on current tcp pose. some characteristic about it. or joint angles. 
i need to collect data on the twelve variables at different spots and formulate some patterns. 
tomorrow.
first, send üR0 to turn off extrusion

(if x > 200)
if it is close to the home position, then make it go to the above point, then go home

(if wrist 2 > -50). this differentiates corner homing right/bottom vs left. (if wrist1 < 0
if it is test teach position or corner homing right side, then go to waypoint 4. (waypoint 4 is set for welder_top tcp. translate this to welder tp). 
then go to oldhome, above home, home. 

protective stop - need to stop extrusion

To send a signal to stop an external extrusion process when a protective stop occurs on a Universal Robot (UR), you can use the robot's digital outputs or IO signals to communicate with the external system (like the extrusion machine or control system). Here's how you can achieve this:

Steps to Send a Signal for Extrusion Stop on a Protective Stop Event:
1. Configure the Digital Outputs
UR robots have digital outputs that can be used to send signals to external equipment. You can configure one of these outputs to stop the extrusion process when the robot performs a protective stop.
2. Using URScript or Polyscope (Robot Interface)
You can write a script using URScript (the robot's programming language) or use the Polyscope interface to set up the logic that triggers the signal upon a protective stop.
3. Monitoring the Robot State
Monitor the robot's state using the is_protective_stop() function in URScript. This function can check whether a protective stop has been triggered.
Example of checking the protective stop in URScript:

python
Copy code
if is_protective_stop():
    set_digital_output(0, True)  # This will send a signal to stop the extrusion
else:
    set_digital_output(0, False)  # No protective stop, extrusion can continue
In this example, set_digital_output(0, True) sends a signal to the external equipment when the protective stop is active, signaling it to stop the extrusion process.

I need to attach a colored string to the front of the lift column. red areas and a green area of the string that matches the acceptable distance from the corner
go/no go


move leftweldcheck to after calculate_DOtA_points_left. 
add a check for all points after calculate_DOtA_points_left and calculate_DOtA_points_right
the right weld check also checks heading 1 (to see if collision during pivot) and distance checker (to see if it is too close)

i checked and yes i can send serial commands from code. functions within analyze touchpoints.script

i completed turn_extrusion_on() function and put it into main program.
i checked it by running it with heating off. main program got all the way to extrude_knife_3() and then errored (as designed)
it said "error code encountered. find calvin" 
"[252,82,48,252,72,49,252,72,48,252,82,48,252..."
weird. it looks like it has recorded all the heating and extrusion start and stop commands.

after trying a fix where i set resp0 to [] and then resp0 = WTSerialBridge.send_command(), i get a runtime error: resizing of list is not supported. 

ohhhhhhh. i bet i know what it is. 
every command that is not a query leaves the response sitting there in the RS232 converter. 
then when you have one that is a query, all the stuff that was in the line gets read. 
i need to flush the channel BEFORE sending the extrusion instructions
and i need to undo those changes that i made that broke it
flushing it worked. only the most recent signal appeared. fuck yeah im a genius. 

i tested the new setup on an actual weld. it worked pretty good.
one thing that changed was the time delay. 
it used to be where the signal being sent took a long time to reach the welder, and took a long time to start welding.
so i added a wait command after sending the signal. after telling the welder to start extruding, wait a second before telling the wire motor to go and telling the robot to start moving.
now, with query, the send_serial_signal() function takes longer to finish. the 1000ms query time is included AFTER the extrude signal has been sent. 
Then, after the query has executed, the Wait command executes. I need to decrease the wait command by 1 second. 
extrusion is happening before the wire motor starts going. it didnt pull out but it possibly could. 
also some gunk got in front of the tip and was blocking the preheat. starting moving faster after extrusion should fix that. 

i removed the wait() command. the wire motor now starts at the same time as the welder. 
the left around weld still leaves a little residue in front of the tip. 
it seems like maybe it takes more than 1 second to execute that command. 
before 2way communication, with the 1second wait, the wire motor used to start before the extruder. 
i decreased wait from 1s to 0s. i cant decrease it any more. 

maybe i can speed up the move from p_1 to p_2
right now it takes 0.8255s to move that distance, at 10mm/s
if i double the speed to 20 mm/s, i would reduce the weld tie by 0.4 seconds. 
that could reduce the "bubble" of weld enough to prevent weld from blocking the preheat. 

i doubled that little short section. its better but its not perfect. 
it still has a big bubble in front of the tip the entirety of the third leg. 
however, it is small enough that the bubble reduces and by the end of the weld, the bubble is super small and no residue sticks to the front of the tip when the welder leaves the tank. 

now i am doubling the speen of the circle move. from 0.5 mm/s to 1.0 mm/s
wow that worked really great. 
i think it might be too fast. 
I reduced it from 1.0 to 0.8
Now it is as slow as i can get it, without the bubble getting too big, moving in front of the tip and blocking the preheat

update 12/19: i have spent two days on the line in station 4, welding corners.
i have been able to get most of the corners, except ones under low steps and those that station 3 forgot to leave space. 
the first tank we did just hit test. 
one corner did leak. the leak was a hole on the side of the seam, right at the corner. 
three variables: shaky tank. 3/4 inch sidewall. new program.
i believe it is most likely the new program. after the two way communication i switched the speeds and wait times on everything. 
and it was the day before go live so i didnt test for leaks. 
our plan is to go back to the program before i changed it all. remove 2 way communication. slow down speed. 

a lot has happened since i last journaled. 
we got the robot working and in production. 
we have been welding a bunch of tanks (skipping the ones that arent feasible)
we extended the first and third legs of the welds. 
on the last tank, it came around the corner on the Around, and the chamfer wasnt tapered. It kind of bumped the weld shoe out. Or maybe bumped the tank over. Or maybe moved the robot. 
Idk. Anyways, the leg was a little off. It was welding too far from the material. Left a gap. 
Also, it went until the elbow was fully extended. Then it crashed out. 
This seems to be happening on right side welds. 
Even after I've already reduced it to the third highest valid point. 
Maybe, on the right side, there are valid points from a weird orientation. 

There are. 
In the normal orientation for a right side around weld, the elbow extends, and wrist 1 sticks out.
Wrist two comes back toward the base, before wrist 3 sends the gun out past wrist1. 
It pivots and goes along the sidewall.
It extends until the elbow is straight. this is at (-1580, -152).
I can go past that to (-1589, -158), but that requires a turn rerotate. 
The first one it went to was the elbow down (like a double jointed elbow) 
The second one i went to was the elbow up in the air. Wrist 1 forwards. And wrist 2 forwards to down. (wrist 3 must be facing down)
This is better than the joint positioning that it currently does for right side around. 
It also rotates (rz) very well. 

In the future, we should switch the right side around weld to use this joint positioning. That way it will be able to go farther. 
For now, just switch the right side extended weld to not extend the around weld. keep it at 8 inches. 
Ryan said don't focus on working on this. We should be working on the step weld for now. Work on this once we get the second robot. 

When starting the vertical weld on a left side, it frequently errors when going to p1. 
When the tip enters the chamfer, it protective stops. 
That happened twice on the same weld. It was not scraped.
That happened twice on a different weld. This one was scraped. 
The next time I did it a little lower, and it didn't protective stop. However, it did shake. Like it was trying to stay at a position

When i set the height to ~ 1 inch below the top, it no longer errors out and protective stops. 
All 4 welds today were this way. 

After trimming two robot welds on the same tank (222506) (1 right and 1 left), there was an air bubble in each weld in the same place. 
The air bubble was on the rear face. ~3mm from the corner. So, lateral to the Down weld. 
We speculate that we might need to dwell (Wait: 0.25) a quarter second after üR1 of the around, before beginning the motion. 

I made a change to double-tap sending the üR1 command every time extrusion starts.
This is implemented. Hopefully, it won't fail to extrude any more due to unknown internal error. 

Lift column was used successfully.
There was a tall tank. I set it to the top. The robot entered protective stop because it was so high.
I restarted the program and raised the lift column a foot and it went great!
I had to raise the lift column manually and remove the waste extrusion manually. 
In future state, we should have both of those things automatically built in. 

trial explore of set_runstate_standard_digital_output_to_value(outputId,state) 
i put set_runstate_standard_digital_output_to_value(2,2) as a script in a program to try out the air temp sensor.
i need the air temp sensor to be off (low) when a program is running, and on (high) when a program is not running
state = 2 is "Set signal High when program is not running"
the value started off as low. 
i ran the program. after the program finished, the signal went to high. 
Going to the IO screen and manually changing the signal to low resulted in the signal immediately being automatically set back to high.
i suspect that in order to regain manual control of that digital output, i would need to call 0: : Preserve signal state
lets try that. 
yes that worked. after running state = 0, i can now control it manually, whether the program is running or not.
lets see if this state persists over a shut down of the robot (not pendant)
shutting down the robot does not affect the digital outputs. 
after running (2,2), shutting down the robot itself does NOT give me manual control of the DO2. 
it still is automatically on. 
lets try a shutoff of the pendant.
shutting off the pendant does shut off all digital outputs
pendant power comes back on and DO2 is still off. 
i can manually change it. booting the robot itself doesnt change that
neither the voltage nor the state persists across pendant shutdown. 
but it DOES persist across loading a new program.
also, having a program PAUSED (due to hitting the pause button or manual release of 3PE) counts as "not running"
whatever states i set up, i will need to call them before any extrusion is performed. 
i will do that in Start Heating Welder

for having the lift column automatically extend, i first wanted to see if bad things would happen.
for a right side weld or a left side weld, it goes down, then over, in one fluid motion. 
if the lift column is raised, i can't have any part of that motion collide with itself.
I found that doing that normal motion (in the proper string range), but sending it way lower (subtract z) worked alright. 
you could go a couple feet lower before you ran into problems. 
the problems are that the elbow fully extends, indicating the end of range. 
this happens before any collision. 
it happens during the Over section of weldIt happens on the right before it happens on the left. 
This is good. it indicates that a call to check_structofpoints_validity() will be all that is needed to ensure the validity of points. 

oeAIR error on the welder. Kris said wait for wade to look at it tomorrow. 
the heating element got burned out. 
wade and i switched the heating element to a new one. 
this involved taking the cage off and loosening some screws holding together the body of the welder. 
I hope this didn't change the position of the tcp or the weld tip. 

weld paths are a little suspect on the first tank after replacing the heat element. 
hard to tell if the point locations changed relative to the robot, or if the tank pedestals were shaky (they were). 
revolving around TCP=pretend_welder seemed correct. 
the tcp is a little off rotation when i rotate it around the fixed cup point. a millimeter or two. 

right side extend did not work. im still not sure why. it raised the lift column 14 mm only (right side doesnt need that much)
and it started doing the weld. weld looked good until about 2/3 of the way down (it was a little to the right of chamfer) (too far in) (~2mm)
it stopped about 15mm above the floor chamfer and started turning. when it went to move to p5, it protective stopped. 
im not sure why it stopped above the floor chamfer. it's like as if it failed to modify the points p2, p4, and p5 with the liftcolumnzneeded. 
but that doesn't make sense because the script function IS modifying those points. 
I wish I would have saved the active variables or taken a picture of them from the Run screen. 

for the above instance, somehow the lift column z detector (built in) got screwed up. when i sent the lift column home, the positition meter read -14.3mm. 

reset that. seemed like a one-off. 
now my right side extended is not working. 
when i need a lift on a right side weld, the lift column does raise up to what looks to be about the right spot. 
however, it commits a joint limit exceeded when reaching for pa1. 
so, i added pa1 into the checker function. 
i tried it and it still failed at the same spot. 
so i made a new program in polyscope using the pose coordinates that i saved from p1 and pa1 (which were returned by the function in the main program)
i checked these and these poses are not reachable. 
get_inverse_kin(p1) (and pa1) returns an error. 
get_inverse_kin_has_solution() returns false. can_pose_be_reached_without_twist() returns false. 
so i made a struct around p1 (as struct[0]) and passed it into floor_corner_lift_column_extend_right(). it throws a runtime error i think because it is infinite looping. 
wow super weird. 

mothingfucking god damn.
i had a typo. the number was supposed to be -0.78436, but it was -78436. big difference. 
now when i call get_inverse_kin_has_solution() on var_1 (p1), it returns true. 
when i call get_inverse_kin() on p1 i get a result that has a wrist1 joint of 6.36549 which corresponds to 364 degrees. this is outside the joint limit. 
when i call can_pose_be_reached_without_twist() in p1, i get false. 
and yet when i run floor_corner_lift_column_extend_right() it doesnt change. thats because i was not looking at the return value

after correcting these errors, the code now works. 
var_1 (p1 from the original code) was .97369 as a z, and the newp1 is now .91369 as the z. 
liftcolumnzneeded is 60. 
the inverse kin of newp1 has a wrist1 of 359.7 degrees. 
it seems like this is working correctly. 
but why did it not provide the proper result when called from Floor Corner Extended?
because my check_validity_right() function was not returning the result. bummer. 
after fixing my script file to return out the modified point values, the right side extension works like a charm. 

another concern: on the corner by the wall/garbage, the weld frequently leaves the chamfer during the vertical. 
i am not sure what the cause of that is. but it is a pattern. 
northwest corner = weld slides to the inside of the vert chamfer
update: solved!
when the robot is on multiple concrete slabs (straddling the crack), it is tippy. 
if you look carefully, you can see the robot rocking back and forth when the arm swings out. 
I'm sure that's what making it miss the chamfer. 

aaron from ur called me. he said i could put the rest of the function in an else block. he said i could try calling get_inverse_kin_has_solution(pose, qnear) and that might return false if it can't get to pose from qnear smoothly, but i would have to play with it. 
i did do that

for the camera. 
we ordered a wyze camera v4. 
we ordered an SD card.
we needed a micro SD card. we ordered that. it comes with a microsd card adapter to regular sd card. 
my computer doesnt have an sd card slot (micro or regular). we ordered a usb to sd card adapter. 
the wyze camera is set up on the wifi network upf-guest. 
i set it up to record video continuously to the microusb.
i confirmed that it records video all the time that the camera is on and usb is inserted. 
turning off the camera or removing the microusb stops recording but when its turned back on or inserted back in, recording automatically resumes.
it records videos into 1 minute clips. every time the second hand reaches 60, it starts a new video clip. 
i want to be able to remove the sd card from the camera, plug it into my computer, and run a program that: 
1. copies all the files off the sd card onto my computer in a safe location. 
2. clears the SD card for further recording.
3. merges the video clips into 1 hour long segments that are easily viewable and scrubbable (hi speed searching)
4. while still maintaining date and time metadata
i searched and found a solution using a program called ffmpeg. 
from ffmpeg.org/download.html, i hovered over the windows icon and clicked on windows builds from gyan.dev.
i then went to the "git master builds" section and downloaded ffmpeg-git-full.7z
it downloaded ffmpeg-2025-03-31-git-35c091f4b7-full_build.7z into my downloads folder
from command line, i navigated to my downloads folder and ran this command: certutil -hashfile ffmpeg-2025-03-31-git-35c091f4b7-full_build.7z SHA256
i matched the response to the .sha256 from gyan website to confirm successful download. 
i clicked the link for &zip Utility. 
i clicked download for the windows 64 bit x64
i found 7z2409-x64.exe in my downloads. i double clicked it. 
a setup app appeared. i installed to C\Program Files\7-Zip\. 
i used 7zip to extract the ffmpeg folder. i right clicked the .7z file and chose 7zip->extract here. 
i cut and pasted the folder from Downloads to Program Files. 
i renamed the folder ffmpeg. 
I went to system Properties->Environment variables. under user variables for cbaumgartner, i edited the Path variable. I added a new line for C:\Program Files\ffmpeg\bin
dang it i don't have python on my main computer
i downloaded python 3.13.2 from python.org (windows installer 64 bit). 
i ran that file to the default location including Path and admin. python now works from command line. 
from python, i call a subprocess (ffmpeg) which handles the video conversion
in order to check whether there are corrupted files that i need to delete, 
i fixed my copy and merge video code.
there are green boxes surrounding any motion in the videos. very annoying.
chatgpt said i need to change my xyze settings to disable motion tracking overlays
i clicked cobot cam 1. then clicked settings. i clicked detections. and turned motion tagging to off. 

i need to fix my program for floor corners. the circle move does a weird thing when the floors are 3/4 inch thick.
it's because the point3 calculation doesn't incorporate the floor thickness. 

side note. some weekend guys were looking at the robot after their shift on friday, watching me work. 
they noticed my wrap around weld on step corner from top to bottom. they noticed a large goop of extrudant on the top side of the corner
they said "this will probably be an air bubble".
this caught my interest because we have been getting air bubbles on the floor corner welds. 
the welder welds past that point without causing the goop buildup. but as its spinning around the corner while extruding, it gets almost all the way around, and starts spewing goopbackwards. 
at this point the weld tip is aligned for its second moveL. BUT its still extruding and pushing extrudant into the chamfer. 
3 directions are blocked. the sides are blocked by the chamfer sides. the front is blocked by the weld tip. 
the back direction is normally blocked by previous extrudant. 
but at this point the back is not really blocked by anything substantial. looking back there is a V shaped hole for the extrudant to escape. 
the extrudant forces its way backwards out that V shaped hole, forming a big goop of it on the first side of the corner. 
the weekend people also said that would cause an air bubble on the second side of the corner. 
my air bubbles are consistently happening on the first side, right underneath where that goop is. 
the solution they gave is to lay off the trigger on the second half of the spin. 
that might be hard for me to do. there is kind of a delay between when i send the signal and when the welder responds. 
another thing i could do is change backofhole to be even a little further back, so far back that is doesn't shoot out the back. 
maybe. 
i changed backofhole from 4.5 to 10.5 mm and it changed it SIGNIFICANTLY
there is absolutely no goop on the back side at all (hopefully no air bubble either)
there is a ton of goop on the front side, making a messy weld. 





setting up robot number 2. -------------------
there was an issue with errors when moving the lift column up and down. 
the fix was to disable some buggy code from vention. 
While my laptop was connected to the machine motion, i went to 192.168.7.2:3000
username: debian
password: Plastic1
i then went to the file cloud9/vention-control/mm-config.json
and i set the values hotplug_prevention and stall_detection to false.
i save by clicking crtl-s and retsarted the machine motion. 
weird. but it worked. 
i set the ip address of this lift column to also be 192.168.3.52

setting up ur on the pendant. 
i changed the admin password from easybot to Plastic1
i changed the ip to static, ip address to 192.168.3.53. 
i installed the machinemotion urcap onto the teach pendant. 
on the pendant i went to installation->urcaps->machinelogic for universal robots. in the top section i clicked + and MachineMotion1 appeared.
i couldn't click + on the lower section because the pendant was numb.  

ok so robot number 2 had a pendant with a blind/numb spot on it. 
i contacted vention and they will be sending me a new one. 
I got the new pendant, and removed the old pendant.
I cracked the magnetic ferrite thing on the old one by accident as i was removing the old pendant cord from the box. 
i installed the new pendant cord into the box. turned it on and everything works. 
i ordered a new ferrite thing for emf radiation control.
i attached the key to open the ferrite to the cord with a zip tie. 

i was attaching some stuff underneath the box and i smacked my head on the crossbar. 
i removed the crossbars (x2) and placed them to the side during the time of construction. 

hashir from vention told me that i need to return the old faulty pendant because it was replaced under warranty. 
he sent a link with directions to follow. 

continuing with the urcap setup:
I set the IP address to 192.168.3.52.
I added a Custom Actuator is the below section. I copied the options from the first robot. 
It still will not work. 
When I put a lift column raise in a program, it says "check configuration: can't connect to machinemotion." 
I will try adding the configuration file from the first robot to the second robot. 
i called the default.installation that came with robot 2 robot2.installation. 
i loaded in default.installation from the first robot and got this error message:
Safety configuration is different than the one applied to the controller. either apply safety changes or cancel. 
i chose Apply Safety Changes (apply and restart)
i got an error message: urcap not installed : wiretank serial. 
i plug in the wiretank serial usb drive. i go to settings. i type in the admin password. 
i click +, select the file from the usb, and it loads. i click restart.
next robot, install both URcaps before downloading the installation file. 
when i turned the robot on, there was a fault because the payload was wrong. 
i removed the mounting plate from the new robot. 
i looked through the safety configuration of both settings. there seems to be only 1 minute difference between the safety settings. Under tool position, default.installation has a Tool1, where robot2.installation has DISABLED. 
the only other difference is robot2.installation's icon for safety configuration is CCCC CCCC and default's is 3719 8346
i ran the program from default. can't connect to machinemotion.
it would help if i fucking turned the machinemotion on. 
still does not work. 
i asked for help from vention
I set the default gateway to 192.168.3.1
sheesh i finally figured it out. i needed to plug my cord into LAN1 instead of TO PC. 
now it works. 
works from both installation files, default (from robot 1) and robot2. 

I got the extrusion welder working. 
I configured another air pressure regulator setup from shop air. 
hooked it up and configured a twist lock male power cable onto the end of the power cord. attached powerbox to control box to gun. 
Using buttons I was able to start heating. 

i make work instructions for how to build and connect both the lift column and the munsch welder. 

i am trying to run the wiretank serial commands from the cobot on the new cobot, but i am getting an error. the installation for the wiretank serial says activation is required. 
i have a number from last time. ill try that. 2962794
the robot serial number of my last robot was 20236801216. the robot serial number of this one is 20246801938
I have the wrong version of the wiretank serial urcap anyways. 
i installed 4.8 but its supposed to be version 4.9. i have version 4.9 downloaded in the downloads folder of my laptop. 
new code for second robot is 3087803
after entering that code on the new robot, i can now save the program and run it. but at runtime it says "operation timed out!'
thats because the serial cord was unplugged. after plugging it in it now says: the same thing. great. 
thats because its the wrong type of cord. 
after using the correct cord, i can send it but not receive it. 
thats because i need to install the updated wiretank urcap. 
installed version 4.9

copied all the files from programs\upf from my computer onto flash drive. pasted them onto robot 2
(had to copy paste 1 by 1)
started the Floor Corner Extended program. welder wasnt attached. 
removed that checking line. it gave me an error at the start of the swing out. error was on the line end_freedrive_mode().
i added another variable checker to only call that when needed. must have gotten changed with the new polyscope software version. 
protective stopped while it was swinging out . detected at base joint. reweighing new gun. 10.8 kg. 

yeah for some reason this one keeps protective stopping even when its not hitting snything. 
also the cordage between the wrist and gun was too short. when it was rotating under to touch the left side, it was running out of room and failing. we elongated that section.
also, the knife in this robot is in a different spot. when it goes to slice over knife, it doesnt work, and runs into the frame. 
we also noticed that that movement going from Above Bucket to Home, was a different type of movement than on the first robot. it looks like it is going from the same point A to point B, but the motion is different. even though the points are just waypoints in the copy pastded program. 

on the second robot, i am upgrading software from 5.17.3 to 5.21.3
robot2's software successfully upgraded to 5.21.3

i ran the floor corner extended on a box. the bottom touch missed. (to the left). 
i realized i was still using the tcp calibration from robot 1 but robot 2's tcp is probably in a slightly different place. 
i used the corner of the extrude knife as a tcp and this worked well. the tcp calibration became very accurate. it touched all 7 points correctly. 
however, when it went to do the weld, the weld triangle tip bonked into the bottom of the chamfer at the corner. it sat well in the vertical weld but went too far. perhaps i need to also calibrate the weld tip. 

it seems like robot 2 has different coordinates or something. specifically when you start Floor Corner Extended and have to retreat to home first. 
it always went back to home "differently" than robot 1. different joint angle path. 
now it sometimes throws an error "cannot reach requested pose). i tried moving to position manually and it did some crazy shit with turns and rotations and upside down. 
specifically waypoint 47 and waypoint 49. BUT 49 is able to get there using the play button but borks out when you try to go there manually. 
47 fails both times. 
these are the same waypoints that worked on the other robot. 



-----step corners----
i started by turning the box on its side, but soon realized that there were multiple different possible cappings for step corners. 
i talked to ron and ryan about this. 
they clarified the proper step corner geometry and weld path. 
proper geometry is both walls cap the floor. 
proper weld path is to make an L underneath. then go to the intersection and wrap around and up. (going all the way to the top of the tank). 

the rxryrz 0,0,0 position is with the welder tip pointed straight up with the preheat facing the y+ direction. 
so that means the first angle (from the right, back towards the corner) will be about 225 degrees.
the second angle (from the corner, going back left) will be about 135 degrees. 
rx and ry should be 0. only rz.

i successfully completed the bottom L section of step corner welds. 
i successfully completed the Up and Around section of left step corner welds. 
the Up and Around section of right step corner welds is a problem. while traveling up, the orientation of the weld tip requires that the mounting bracket be on the opposite side as the gun. 
the robot cannot reach all the way around the gun with the wrist. 
so i try moving the robot cart closer to the box by about 1-1.5 feet. 
yes! that works great for the right side up and around weld.
it works good for the left side up and around weld. 
it does not work good for the underneath L. 
on the back of the gun there is a wire connection. that is attached to the mounting plate by some plastic. 
on the robot forearm there is a clamp. the plastic on the back of the gun is hitting the plastic forearm clamp and pinching the cords in between. 
maybe i will try a distance in between my two tapes. 
sammy sent me the welding training video for Corners. 
it was a surprise. in it, there were floor corner, cover corner, step corner outside, and step corner inside. 
for the step corner outside, it was a normal step corner with 2 edges facing the floor and one facing the front. 
he started with the vertical edge at the top and started welding downwards. he paused at the corner and wrapped around without breaking weld, continuing below onto the parallel chamfer of the underneath. 
he then came back and did a straight weld (the other underneath chamfer). 
this is different than I expected. he's not making an L and then a wrap. 
he's making a long wrap, and then a straight. 
we had a meeting with me, ron, ryan and sammy. he explained why this was better and this is what im going to do for the robot. 

this is good. it helps the robot as well. 
the right side Under L then Up and Around was a bitch. 
i might still use that pattern for left because it was working pretty good. 
maybe. might run into a singularity. 

ok so the right side weld i was able to fairly easily plot a path for the down around and under. 
however, the last leg (under) (away and to the right) i cannot get to. 
i went to p[-1.257, .53, -.3, 0, 0, 3.6], which was the position i wanted, but the gun facing opposite. 
then i changed 3.6 to 0.5. i got an error: Unreachable pose. 
this seems weird but maybe. 
if i change x to -1130, it is now reachable. 
while it is technically a reachable pose, according to math, it involves a collision. the geometry that make that angle possible push the tip of the gun inside the robot forearm. 
this is not a correct joint combo or even fixable. 
i will try switching the entire shoulder elbow combo. 
yes that worked. the shoulder elbow flip allowed the wrist to switch its chirality and hold the gun from the left. 
it can align, but it can't reach that far. 
the farthset it can reach is about halfway down the duct tape. 
48 inches is the FARTHEST it can reach, at the right angle. 
if the robot base is rotated ccw around the tank, this will be even less. 
lets say we want to have 3 inches of weld and another little bit of buffer. if we position the robot 40-44 inches away from the tank corner, we would still be able to reach 3 inches deep. 
lets see if the right around and uncer works from 40-44 inches. \
ok so the right step cap weld is awesome. i use a shoulder-elbow-flip for all weld sections. down-around-and-under, then back-away.
the down-around-and-under has so much clearance and so much reach. no constraints there. 
the back-around has limited reach but plenty of clearance. robot needs to be closer to tank corner. 
the left side seam step corner also works great with the shoulder-elbow-flip. 
there should be 7 points on the weld path for both of these. 5 points on th first leg, 2 points on the last leg (only sart and stop)
this does not include ramping. 
for now at least, do not include lift column extension if the top point is too high. 
the first path starts at the top and goes underneath the tank. we cannot accommodate a lift column raise. 

because the first path now includes the listleans adjustment AND the circleMove, i may have to add a point 1 inch up with no listleans. 
i only want to have to calculate the circleMove in two dimensions. 
NO! i need all 4 points (1, 2, 4, 5) to be within the same plane. 
so, i need to apply the listleans change to point2 as well. 
BECAUSE if you have points that are all on two lines, then two lines form a plane and those points will all be coplanar. 
line1 is: pointbottomvcham, point2, point1. line2 is pointbottomvcham, point4, point5.
applying listleans to point2 will make it so point1, point2, and pointbottomvcham are colinear. 
then the only problem is rotationally, because right now at point1 i'm pointing straight down, not parallel to the line. 
finding a halfway point between orientations that aren't coplanar might be funky or impossible. 
after reconsideration, i think it would be best to make a point in between points 1 and 2. this point and point2 will NOT use listleans. 
that point will be called point2a
point2a to point2 to pointbottomvcham are colinear and exactly vertical. 
pointbottomvcham to point4 to point5 are colinear and exactly horizontal. 
this makes a right angle. 
this makes the point circle math way easier. 
i can moveP from point1 to point2a to point2 at 10mm/s
then i can moveP circle move to point3 and point4.
then i can moveL to point5. 
hopefully that works. 
for point 3, i simply calculated the arcpoint. i still need to calculate the arcpoint's rxryrz. 
chatgpt said i can use slerp to calculate the midpoint orientation between two orientations. 
i think i'll still just use my other formulas so i get better at using them. 

the rotations i need to combine to get a right seam step corner trail out rxryrz are:
rotate ~135 degrees about the z axis ccw. (positive) (rhr)
rotate ~10 degrees backwards about the gun's orientation.
i need to do that one first.
lets try again
rotate ~10 degrees about the x axis (positive)
THEN, rotate ~135 degrees about the positive z axis. 
that should give us point6

the rotations i need to get point3's rxryrz:
FIRST rotate 45 degrees forward about x axis (negative)
THEN rotate heading3 degrees about positive z axis. 
SO i need to multiply heading 3 times 45 deg forward. 

ok so that ALMOST worked. 
the cirlce move around the bottom was too fast and a little off. 
i need to tweak it. 
i think the problem is that heading1 and heading3 may not be exactly orthogonal. 
the key will be to only use heading3's data for the 5 points involved in the circle move (p2a, p2, p3, p4, p5) on a right side weld. 
that means not using heading1 and not using l1del_unit.
i can use l1del_unit for calculating pointbottomvcham. since all 5 points are based on that. 
i also need to make sure p2a has the correct orientation. make sure it's exact. so no moveP (that blends it). 

yeahhh that worked. right side weld completed
left side weld is doing good as well. 
points all look good. i ran it once in manual mode and the first path did great. 
at the start of the second pass it got real shaky and pro stopped. 
i put it to automatic mode and it was still shaky but powered through. 
i checked the chamfer and it seemed fine / normal. maybe i need to put the tip farther forward or something. 
this is a different weld path than the floor corner. 
i tried switching it to backofhole and that fixed the problem but it pushed it farther than i needed it.
im looking for something in between. 
i set it to where it was using pretend_welder. i then moved it to where i wanted it to be. the difference was 6 mm. 
i will add 6 mm to the calculations. 

left step corner weld successful!

the supervisors turned off the air without telling me (I'm here late)
i quickly turned off heating as i heard the air pressure declining. 
maybe i saved the heating element, maybe not. 



--------- cover corners ------
i need to change the corner homing program
since i am planning on only having 3 inches in all 3 directions, (or at least smaller welds), i dont need too many points
2 right, one left, 1 top
this way i assume verticality AND assume a 90 degrees corner
therefore, i can use the heading under that assumption and not have to use only one or the other. 

the left side cover weld (the hard side) is working great. 
HOWEVER, the lift column raise is taking FOREVER.
i will time it to see exactly how long it is taking. it is about 405 mm. 
i can confirm that the lift column raise took 40.5 seconds. 
this is way too long. 
in the script function for floor corner extended, it says the speed_v2 variable is 600,000, and the acceleration is 50,000.
but in the installation file it says the gain is 150 mm, the speed is 10.0 mm/s, and the acc is 50.0 mm/s2. this makes sense. 
hopefully if i change the installation file, it will speed up the lift column raise. 
i set the speed to 50 and click Save All. it should take about 8 seconds to raise. 
i try it out. it takes 40.52 seconds STILL.
maybe the installation file specifies what settings to give future nodes, but doesn't alter existing nodes. so, if i delete the move and re-add it, it will have the change. 
sike. it just had a speed listed in the node. i changed that and now it takes 8.8 seconds. this is acceptable

right side weld bonked itself while aligning for right .
in align_for_cover_right, when moveJ ing to waypoint 18, it hit itself. 
it comes directly from the end of extrude_knife. that's last point is oldhome. NOT newhome. could be the reason for the bonk. 
ok it was because the oldhome was driven into with a moveL, so it was the oldhome from a pose perspective but not a joint perspective. 
i moveJ'ed from oldhome to oldhome and then went to waypoint 18. this worked. 
cover path right kept bonking as it moved across from point1 to point2, right as it crossed the crossing chamfer. 
the machining on the endwall was shitty so i had chiseled it out. but it wasnt good enough. i had needed to chisel it out better. 

ok so we ran a left cover corner weld and a right cover corner weld with the extrusion on. the takeaways were the same from each. 
1.  the wraparound was not as good as the floor corner wraparound. 
  the floor corner preheats around the end before it goes back 1 inch to wraparound. cover corner does not. 
  one solution would be to turn the extrusion off while halfway around the corner. pause for 6 seconds to preheat. then restart extrusion and continue. 
2. when we press back in for the backaway, we are pressing the triangle right down into the center of the weld. then it drags that weld in front of it as it goes along its path. 
  we should preheat without pressing down on it. raise it a couple mm above the extrudant.
  then we should move the weld tip in front of the existing extrudant before pressing down. 
  i will need to add more points to 201 to make this happen. 

move_path_cover_left2 has number 2 implemented. 
move_path_cover_left3 will have both implemented. 

i try to add a Wait command halfway in the circle move. i cant. i get a popup: this section cannot be altered. 
one thing to try is maybe break it up into two circle moves with a wait in between. that would require 1/4 and 3/4 points along the curve. 
also i havent figured out if i can send a stop extrusion signal at the start of the circle move. or if that would break the motion. 

also, when it wraps around and is moving vertically downward, it looks like its not tight to the wall. like there is a little gap. i have seen that on all of them. 
this is most likely due to undersized chamfers on those sections of the box. i measured the vertical chamfer depth and it was 4mm. the top chamfer was 5mm. 
it could also be due to when the gun pushes on the top chamfer, the box has nowhere to go. but when it pushes on the side it moves slightly. 
i checked the corner homing and it looked like it worked fine. 

randomly during homing: path sanity check failed. wrist one goes way negative. it's like doing a full rotation of that joint for no reason. i checked and it IS during a moveL. ill change that to a moveJ and see if it fixes. 
it did.
ok now it's back. so none of the points in it until later are actual waypoints. they are all p[] variables. 
i added an actual waypoint just before ph2. god damn it. it still does that full rotation bullshit. position close to joint limits. 
now i added it before ph3 as well. it worked. it still does two little half-turns, but straightens out in between. extra movement (inefficient) but it now works. 

i put a üR0 right before the circle move and a üR1 right after the circle move. i wanted to see if it would stop moving before doing the circle weld.
it did not. however, it stopped halfway around the circle weld at point3. it clunked and then clunked again and errored. 
i will try it again. same thing happened. 
i removed the uR0 before the circle move. it still does it.
i remove the uR0 after the circle move too. it still does it!! what the hell!.
ok so they were suppressed. what if i delete them completely. 
ok now it works again. 
one. thats stupid.
two. thats gay. 
three. thats problematic for me. 

i make an assignment statement setting a dummy variable to true right after the circle move. 
it crashes at point 3. same thing. 
i move that assignment statement ahead of the circlemove. 
it completes it successfully. 
ok. so the rule is you can't have some bullshit right after the circlemove. has to be another moveL, so it knows what to link into. 
lets try it with a uR1 in front of the circle move instead of the assignment statement (suppressed)
works just fine. 
let's try making another point just slightly below point4 (3mm below), and moveLing to that point, then turning extrusion back on, and moveLing to point5. call it point4a.
yeah that worked. 
slight pause down there (very slight) but pretty good. 
i dont know if i want to pause to preheat there or not. i feel like i should preheat before 
ill put a 4s wait there before the ur1, and then anothr 1s wait there after the uR1
it looks... fine. where it stops, the preheat is about 1 inch below the corner. because i pivoted around backofhole. 
i'll try it with real weld. 
it did make it stop extruding earlier. the top of weld still looked good. it still had extrudite build up in front of the tip on the back side. not as much, but still some. i think we could make it better by turning off extrusion even earlier. try 15 mm instead of 10. 
yes i think that was perfect. it still made a little blob of it on the back side as it was rotating. but the blob was very small. and when the tip rotated fully it smushed the blob and none of the blob got in front of the tip. so it wasnt blocking the preheat. 

the reason for the loose weld on the backside could be that the robot's front two wheels were not locked. if robot cart was not straight it could have been pulling away as it welded. maybe. yeah idk. 

trying that on the right corner as well. 

so what changes did i make for the left? 
  i changed the analyze_touchpoints file.
  i assigned p4a (p4 - z(.003)), and p2a (pathturn[10])
  i moveL to p2a instead of p2. then i uR0, then i moveL to p2.
  after the moveP, i moveL to p4a. wait 4. uR1. wait 1. moveL to p5.
  assign p201 a, b, c = pathturn[7, 8, 9] (after assignment of p202)
  instead of moveL to p201, moveL to p201a. wait 6. moveL to p201b, p201c, 
thats all the changes

i make those changes to the right weld and run it dry. it kind of works but the box's tack is falling apart. 

i do it a second time and again it does some weird motion around the corner. 
i notice that i copy pasted wrong. l1, but should be l2del_unit for a right corner. 
lets see if that fixes it. 
right weld looks good after that. slight blob blockage of preheat on both leg2 and leg3. 

--------- straight welds ---------
instead of doing inside step corners i will do straight welds next. 
the step boxes are not tacked up yet. 
the straight welds should be for connecting two corners. that means ramp in and ramp out. 
i made a sample demo program caalled Straight Top Demo. it smoothly transitions from the angleback to the straight. 
there is a slight pause in that transition. i used a moveL with acc = 50. 
i am wondering if switching to a movep or increasing the acceleration would decrease that stoppage. 
yes that makes it so much faster. no stoppage at all at 1200 acc. moveP not needed. 
now lets try to add in preheat and pauses and extrude on and all that good stuff. 

ok now im making a Cover Straight program. 
i will need new everything. 
  new test teach position straight
  new get_straight_homing_pathpoints()
  new Straight Homing Cover subprogram
  new analyze_toughpoints_only_straight()
  new main_calculate()
  new move_path_cover_straight subprogram

i will make them teach the start and endpoints of the weld by making them specify the trail out point of each v chamfer. 
i will use those points to get homing points. i will use those homing result points to calculate the line on which the weld runs. 
in main_calculate, i will determine the start and end points by interpolating the y value of the teach points onto the line calculated by homing. 

i got my homing program compiling and running. 
it is not working correctly though. 
when it saves tcp_poe_left and right with get_actual_tcp_pose(), it is not saving it correctly. 
it is like 2 feet off of what it should be. it should have saved x = -1244, but it instead saved x = -.997
i will have to investigate that function, get_actual_tcp_pose() and make sure it is using the active tcp to save. 
i determined that it might have been using tcp_plate_1 or TCP as the tcp of reference for determining coordinates during that function. 
inside Test_Teach_Straight() there is no tcp set function. 

for some reason in the cover straight.script file, every moveJ move inside def Test_Teach_Straight(): looks like this:

    $ 366 "MoveJ"
    $ 367 "Waypoint_40" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_40_p, qnear=Waypoint_40_q), a=1.3962634015954636, v=1.0471975511965976)

i am not sure why it's setting the tcp to tcp_plate_1. 
in extrude_knife() it has this:
    $ 387 "Set"
    set_tcp(p[-0.0095,-0.328,0.10573,1.2092,-1.2092,1.2092])
but then has no set tcp command before each move. 
that implies the solution is to set the tcp in each subprogram. 
somehow the points work correctly. maybe the program was opened originally with tcp_1_plate as the default tcp. 
because of that, all the fixed waypoints are saved according to that tcp? maybe? 
i went to waypoint_2 with my tcp_1_plate active by going into cover straight program and clicking waypoint_2 (in subprogram test teach straight) and clicking move to position. its coordinates are -548, 386, 143 in the move screen. 
when i switch my active tcp to pretend_welder_top, my coordinates are -550, 120, 125.
inside the cover straight script file, waypoint 2 is defined as this:
  global Waypoint_2_p=p[-.548957282596, .386284559177, .143710178207, 1.570800598292, -.000025190822, .000004803470]
  global Waypoint_2_q=[-1.0516188780414026, -1.010990933781006, 2.1562450567828577, -1.143702046280243, -1.0526168982135218, -0.0017235914813440445]
yes. waypoint_2 is defined according to tcp_1_plate. 
test teach straight does not have a .script file. weird.
test teach position straight does. weird. 
probably because test teach straight was saved from its subprogram tag inside cover straight. saving test teach straight independently did cause its .script file to appear. 
now in the test teach straight .script file i have this:
  global Waypoint_2_p=p[-.548957282596, .386284559177, .143710178207, 1.570800598292, -.000025190822, .000004803470]
  global Waypoint_2_q=[-1.0516188780414026, -1.010990933781006, 2.1562450567828577, -1.143702046280243, -1.0526168982135218, -0.0017235914813440445]
its the same as in the cover straight main script.
in test teach position straight, it is the same. 
what the fuck. 
i added a set tcp command at the start of Test Teach Straight, setting the tcp to pretend_w_top. 
and now it looks like this:
    $ 3 "Set"
    set_tcp(p[-0.0010317764122757048,-0.018062446645763904,0.28523420717101033,0.0,0.0,0.0])
    $ 7 "MoveJ"
    $ 8 "Waypoint_40" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_40_p, qnear=Waypoint_40_q), a=1.3962634015954636, v=1.0471975511965976)
it sets the tcp to what i want, and then immediately sets it back to what it was before. 
that's an interesting observation. 
i should set the tcp immediately before moving to any variable position or requesting position. 
let me check the Cover Corner script and see how it's working when it comes to the move_path thing. 
move_path_cover_left3() inside cover corner .script has the following:
    $ 224 "Set"
    set_tcp(p[-0.0095,-0.328,0.10573,1.2092,-1.2092,1.2092])
    $ 225 "MoveL"
    $ 226 "pret1" "breakAfter"
    movel(pret1, a=0.05, v=0.05)
    $ 227 "MoveJ"
    $ 228 "pret2" "breakAfter"
    movej(pret2, a=1.3962634015954636, v=1.0471975511965976)
    $ 229 "MoveJ"
    $ 230 "'retreat of p5'"
    # 'retreat of p5'
    $ 231 "Waypoint_6" "breakAfter"
    movej(get_inverse_kin(Waypoint_6_p, qnear=Waypoint_6_q), a=1.3962634015954636, v=1.0471975511965976)
as you can see, the set command sets the tcp and then it moves to the variable waypoints without setting it again. 
it also moves to the fixed waypoint without setting the tcp. 
i am not sure why it doesnt set it here but it did before. 
i checked floor corner extended. i can confirm that it is also setting the tcp to tcp_1_plate before gathering the teach points. 
most likely this is the reason that the height start is not exactly the same as what you set it at. 
i am not sure why the x and y values arent way off though. perhaps they are and i just didnt notice. but if they were off, you'd think they would be an entire foot off. 
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 367 "freedrive_m_var≔ False "
    global freedrive_m_var=  False  
    $ 368 "freedrive_m_var≔ True "
    global freedrive_m_var=  True  
    $ 369 "Popup: Move the TCP to the top of the weld, then click 'Continue'"
    popup("Move the TCP to the top of the weld, then click 'Continue'", "Message", False, False, blocking=True)
    $ 370 "tcp_pose_top≔get_actual_tcp_pose()"
    global tcp_pose_top= get_actual_tcp_pose ()
    $ 371 "Popup: Move the TCP to the corner of the tank, then click 'Continue'"
    popup("Move the TCP to the corner of the tank, then click 'Continue'", "Message", False, False, blocking=True)
    $ 372 "tcp_pose≔get_actual_tcp_pose()"
    global tcp_pose= get_actual_tcp_pose ()
if thats the case then it should be 285 mm off. 
i run floor corner extended on this box. i pause immediately after i teach my two points
it pauses during corner homing 45's Wait 1.0.
immediately after the wait, there is a call to tp := get_actual_tcp_pose() INSIDE corner homing 45. 
and then what gets passed into get_corner_homing_45_pathpoints() is tp and tcp_pose_top. 
checking the run screen, tp has the correct coordinates based on pretend_w_top. 
so that explains why only the top position was off and the rest of the stuff was accurate. because it was calculating it again. 
i placed a set command inside the test teach position subprogram AFTER the moveJs and directly before the freedrive. 
trying it now. yes that fixed it. 
wow. thats crazy.
ok so i also made that change to test teach straight. and it did fix the problem. 
now it bumped itself when moving to ph3 from waypoint 11. 

the tiltback will need a 6mm raise. and a 10 degree backwards tilt?
preheat point (point1) is 1 inch back from teach point
start of turn is 0.5 inches ahead of teachpoint. 
end of turn is 1.5 inches ahead of teachpoint
start of end turn is 1.5 inches before rightpoint
end of turn is right at rightpoint
end of smear is 1.5 inches past rightpoint. make it 2 inches past. 

note: for doing pegs, we should raise the arm up as high as it will go, to be able to attack it from above. 

i will need to align for cover weld in a way that the wrist is pointing up. 
the point that i set though, pointtopvcham is spot on. less than 1/32 of an inch off. correct rxryrz. 
the program does seem to be working rigt. two things:
maybe the sidewall is thicker than 0.375 inches. tip is consistently nearer to the edge than the center of chamfer. just slightly
going from point 4 to point 5 seems to be slower than the other movements. 
maybe that is because the tip is still moving the same speed but the gun isnt moving as much. switches from a leteral motion to a tilting rotation motion. it could be that the tip is moving just as fast as it was it just seems slower to us. 

for the floor straight i got the move points function in the script working correctly.
i aligned it so that the cords wouldn't be wrapped around. they can just hang back and not be in the way. 
HOWEVER, when i went to play the program, the cords were good. they were in the back away from everything
BUT i got a wrist3 position close to joint limits. it was about 360 degrees halfway along the bottom edge. 
damn it.
looks like i will have to do a wrist 3 ful rotation. that will make it so that my wrist 3 won't be close to joint limits, but the cords will be wrapped. 
what do i do when doing a right corner? it's the same motion (gun upside down, welding cw)

------ trial tank ---------

so i finished welding all the floor corners and floor straights of the trial tank. 
next is step corners. i've never actually trimmed a step corner to see what it looks like / if it adhered well. 
i figured i would try it on a box first and trim that weld. 
glad i decided that. it welded half of it and then said "cannot reach requested pose". 
robot was too far away from tank. 
i need to add a check to ensure that all positions are reachable before i start welding. 

i welded the right step corner. (rear driver of tank)
for the other two step corners, i could not weld them. the back of the robot wrist bonked into the lower sidewall of the tank in the under section of the weld. 
i checked express to see if geometry ws consistent. it is not. 
my hypothesis was this: if the seam is on the right side, then the lower sidewall will also be on the left side. and vice versa
i found it to be not true. sometimes a left seam step weld would have its lower sidewall to the left; sometimes to the right. 
this makes it hard to navigate around obstacles and still perform the weld. 
if a right seam step weld has an obstacle on the left side, it could bonk when it goes to do the backaway. 
if a left seam step weld has an obstacle on the left side, it could bonk when it does its "and under". 
if a right seam step weld has an obstacle on the right side, that will be fine. (completed the weld). 
i think it doesn't matter whether it's a right seam or a left seam. it still does the same motions (in a different order). 
the right seam's And Under is a left seam's backaway. a left seam's And Under is a right seam's backaway. 
so it's a problem is the lower sidewall obstacle is on the left. 

if it's a left seam, left obstacle weld, we could do the bottom L then up and around. 
however, that doesn't work for right seam welds. 
right seam, left obstacle welds are a problem. i cannot figure out how to weld them. 
for a left left ltua step corner weld, you cannot be too far angled to the right. if you are close to facing straight into the right plane, the welder and wrist will pinch during leg 2. 

the cover weld looks much better when i slowed the speed down to 6 mm/s. actually, the third leg had been at 12 mm/s. i dont know why. it should be at 10 for a regular weld and 6 for a deep chamfer
i talked to the kitting guy about the weld quality. i chiseled off the excess, getting it flat. 
he said there might be a leak on the wraparound. i asked if maybe it was because there wasnt enough preheat there. 
he said it was more likely that the parent material hadn't been scraped. i dont remember if i scraped. i think just minimally, to get burrs off. 
he said yeah when it gets shiny from tacking, you need to scrape or it wont adhere even if there is preheat. 
so, for the trial tank i will scrape until it's not shiny
i will also slow down the moveP i think. i have already stopped extrusion, and am just dragging the extrusion around the corner, so that should be alright. 
slowing it down will cause more preheat to reach the corner. maybe. also i will scrape. 
if that doesn't work, i guess i will have to change the whole program to do a L then around and down. 

we also have to see if it rides out of the chamfer properly. 
jesus. so much stuff getting rushed through this process. so quickly. 

god damn it. i ran this left cover corner and it protective stopped right where it paused at p4a. 
i ran it like 5 times dry and it was fine every time. why did it have to crash out the one time i was welding. 
maybe because the extrudant was adding more force. who knows
it worked fine on the test box though.
when i dry ran t, it was shaking at that spot, indicating that the position was slightly off. 
fuck
the problem was that i didn't v chisel the front end seam down far enough. yeah i made it a v chisel out, but not in the right spot. 
my code assumes the trail end of the v chisel is 3 inches below the top corner. 
and the start of tilt back is 1.5 inches above that (= 1.5 inches below top corner)
the problem was my tank had a tapering v chisel where it was assumed to be straight chamfer (.21). 
thats why it bonked out.
going forward i need to v chisel out a wedge that is the appropriate size. full chamfer size (0.21) down at least 1.5 inches, then tapering up to a point 3 inches below cover. 

now i need to make the right weld. 
right script file already incorporates deepcovercham. 

i talked to dallas about how the robot welder worked. 
he said he only used it for two corners. 
he said it did everything well except the corners (lol)
he said it caused a pinhole in the corner both times. 
he said what he does is he welds the L, then preheats, then when he approaches for leg 3, he uses the tip to push the existing extrudant backwards, then welds. 
instead of coming in straight, he comes in ahead, then slides backwards, using the tip to push the extrudant backwards. 
and then he welds around. and that way, he doesnt get that bubble/pinhole leak. 

the right cover corner worked great. 
there was a huge gap between the endwall and cover (caused by warping) but it filled that gap up nicely. 

cover straights
i switched the program to run at 6 mm/s for deep covers. 
it worked fine on the first weld but it was ever so slightly curling around the tip in front of the tip. 
i was using the shoe that ryan had accidentally chiseled a slice into the tip. 
i decided to switch shoes and put a brand new shoe on. 
i then tried the long cover. it started the tiltback on the center of the cover, going towards the corner. 
it was tilting back unnecessarily (there was no previous extrudant to link into) but i fugured it would be fine. 
however, during that tiltback, we got a lot of extrudant in front of the tip. when it started going normally, it slowly sucked that back behind until there was none in front. 
after going a little bit farther, it started to build up again in front of the tip. it kept building up until there was about 2x a tip's worth of volume in front of it. i stopped the program. 
ryan 2 suggested increasing the speed from 6mm/s to 7. 
the 7mm/s was better in some ways and worse in no ways. 
there was less slag on the sides and it bubbled in front of the tip less often and smaller amounts. 
it still did sometimes but yeah. 
also it still looks like a full weld, like it's filling the chamfer completely. 
i also notice that for both the 6mm/s and 7mm/s cover straight welds, there is like a central raised cylinder. the weld is tallest over the center of the chamfer. 
it's possible this happens as it is cooling, like an uneven cooling effect. 
on the endwall with the foam cell, there was no corner and the cover around the foam cell hadn't been welded. 
so, it had to do an unnecessary tiltback at the start. 
the same pattern happened as with the 6mm/s: it bubbled in front, then reduced, then came back. 
this time it didnt get as big. less than one tip's worth of volume in front. so i let it go. 
but this is now a pattern. you shouldn't start a cover straight unless there's a v chamfer to ride down. 

i asked dallas to show me how to weld cover ltudes. 
he said it's important to scrape the top of the cover around the slit, especially if it's textured. 
he also v chiseled out both ends of the slit, making it just like a sidewall cover ramp in and ramp out. 

INTERESTING
mike krueger was talking to me about cover welding speeds. 
he said he did NOT want his operators slowing down while welding covers because doing that can overheat the material and leave bubbles in the weld once it's trimmed off. i guess i will see if my weld left bubbles. 
but on the contrary, i showed randy the weld, and he thought i was going too fast because it might not fill it all the way. 
this is why we use the cobot because everybody has a different opinion and there's no consistency. 

i manually moved the robot base so the front of the lift column was about two feet from the side of the tank. the cover is about 6 inches above the top of the lift column. 
i can reach the entire ltude both in weld position and in tcp position (homing tcp down)
in freedrive mode, it's a little difficult to move it from the side. it worked better if i moved my body around to the endwall and pulled it where i wanted from there. 
it seems to work though.
i will need to make a new teach position program : Test Teach Cover LT
i will need to make a new homing program: Homing Cover LT
i will need to make a new analyze_touchpoints_only: analyze_touchpoints_only_cover_lt()
the operator will need to place the homing tcp right in the middle of the groove on both points. we will use the teach position coordiantes for x and y, both start and end, and only use the homing points for z. 
if the new analyze_touchpoints_only_cover_lt() function calculates all of point0=point0, v3xunit=v3xunit, v3yunit=v3yunit, v3zunit=v3zunit, heading1=heading1, v4xunit=v4xunit, v4yunit=v4yunit...
then we should be able to use the same calculate_straight_points_cover() function. 
we will need a new move_points subprogram, because it goes at a different speed. due to fill size being in between regular chamfer volume and cover chamfer volume. 

this stupid cover lt homing program keeps touching off air and thinking it's touching tank. 
so when it goes to weld, it's too high. 
it seems random. 
maybe i need to touch it twice and make sure that it's the same
it happens maybe 1 in every 6 times. it could be due to the cords hitting. 
i fixed it by adjusting the wwld wire sheath. it was bonking the cover. and so the robot was feeling that force and thought it was contact. 

sleeves
i made a demo program for fillet sleeves and flush sleeves. the fillet sleeve was pretty sweet but the flush sleeve twisted itself up and self-collided. 
i talked to ryan and other people in the shop and they said fillet sleeves are the way to go, we are going away from flush sleeves. so that works well for me
ill just focus on fillet sleeves. 
im trying to figure out how i want to touch off and calculate these fillet sleeves. 
if i touch 3 points around the ring, that gives me enough data to calculate the plane of the endwall.
it also gives me enough data to calculate the center of the circle and the size of it. 
that gives me all the data i need. 
i calculate the plane, and center/size of the circle. 
to make my calculations easier, i assume a vertical circle and vertical plane, based off of the center. 
i calculate the points at the cardinal positions, including rxryrz. 
i include cushions of 0.005 m (5mm) in the out and around directions. 
i now go to try and run the program. 
the first time, it looks like it's working, until it starts rotating and the top of the cage collides with the top of the endwall. 
at a 45 degree angle, the cage sticks out farther than the weld tip. oof. 
so, we run the program again. this time, after it has completed its touchpoints, we use allen wrenches and remove the cage. then we send it on its way.
this time, it does not hit the top of the endwall. but as it is going around, it pushes the tip into the endwall and triggers protective stop. 
i figure that we maybe moved the tank while we were unbolting the cage. the cage was on a cart with rollie wheels. 
so, we prop up our end of the tank on jack stands to secure its location firm. this causes the plane to be slightly unvertical, but i figure it's close enough. 
we bolt the cage back on loosely to get our touchpoint. and we touchoff. then we remove the cage and try to weld. again, as it is going from 1 to 2 it bonks into the sidewall. 
this could be because it's assuming the sidewall is vertical but it's not (due to jack stands). i move z+ and z- and can see the tip going closer and further from the sidewall.
this could be because when we bolted the cage back on loosely, it didn't bolt in quite the right spot so our tcp measurements were wrong. 
this could be because my cushions aren't large enough. 
it could be because my calculations weren't correct. 
but when i moved to point2 manually, it certainly looked correct. the angle was correct, and y and z were correct, the x was just a millimeter or so into the endwall. 
actually, i did find a bug in my code. for points 2 and 4, i was adding the vecnx times cushion out instead of subtracting it. 
this would cause the tip to be pushed into the endwall 10mm in the x direction, which is exactly what happened. 
shoot. 
adam is welding the rest of the tank up right now. 

after testing the tank, we found 3 leaks from the robot welded. 2 on step corners (one of each) and one cover corner, on the top. 
we trimmed another cover corner down farther and found another leak (created?) around the edge, at the very top of the sidewall. 
i think we should be doing cover corners with an L then around and down approach. 

i am switching that program now. 
i made all the points for that program. 
when i run it though, it bonks on the p_5 portion.
after testing, i relaized that i am sending it straight home after reaching p_5, and that was causing the bonk. 
i also think that if i have large chamfers, i can send the segment 1 to the end (without the chamferbump). i know this is "past" where the next leg starts, but i have extra space on that side i want to utilize. 

changing the homing tcp did make it complete the whole weld. it still was a little too low and too far in but at least it completed it. 
i'll send it even a little further. 
oh my god i finally got the calibration right godddddd
that was so obnoxious. 
maybe. it still might not be right. 
this is retarded. i give up
i cant work with this junk
we need a better way to calibrate our tcp. this is ridiculous
god damn it. this calibration is still not right. 
fuck yes you stupid bitch. 
i clamped the box down and secured it super well. i calibrated it using the auto calibration on the tip of the temperature probe. 
it changed by a few mm in multiple directions. 
it is a two person job. i had ryan help me. 
i sent it on the right corner. it was perfect. 

preheating the around and down: 
because that portion uses backofhole, we don't have to come out from thebox at all. 
just raise p_3 up z direction 15 mm, and that will preheat the perfect spot. 

sleeves:
sleeve protective stop. 
sleeve is 49 inches from robot base. 7 inches left of center. sleeve center is 29 inches above the ground. angle offset is maybe 5-10 degrees.
back of mounting plate pinched air cord. about 30 degrees into the weld. 
wade has made some changes to the cordage. i'll check that the sleeve fillet demo program still works. never know
cordage changes fixed. 
was getting a protective stop as i went around the circle. possibly my cushion of 0.005 was too small. 
Changed that to 5cm and now it worked. did a big circle around the sleeve. too big obviously but proof of concept. 
i noticed that when it got bak to top, it couldn't really go very much farther. or it would hit itself i think. 
when i do the actual one, i will probably have to go 360 deg plus 90 deg. question is whether i want to start at the top and end on the right, or start on the left and end at the top. 

ok the quadonly works with 1.5 turns. 
the tank has to be the full string length away from the robot base. 
also my lift column is raised so that the robot base is slightly above the sleeve. 
straight on. 
my cushions are set at .009 and .003. 
it is still a couple mm too far in both directions. 
tank is clamped down. 
i noticed that when it completes 1 circle, and i pause at p1 (before the third circle move), it isnt vertical. it's made it like 345 degrees around. also at the end it doesnt got the full 540, again like 15 degrees short. 
must be some weirdness with UR's circlemove or moveP internal mechanics. 
also, i think i need to adjust the tcp from being the backofhole to being a specific tcp for sleeve welding. 
i hope its not dependant on sleeve size. 
backofhole is 14 mm different from the regular tcp in the x direction. 
trying to get the correct angle / orientation for going around the pipe. 
req. number 1: the left 45 face is coplanar with endwall surface. 
req number 2: back of shoe is touching the outside of pipe???
jeez it might be different if its a whole sleeve or just a 1/4 inch stub. 
if i touch the back of shoe to the quarter inch stub, then the back of the pipe juts into the shoe. this is fine because the pipe is just a stub, but it means that if the pipe stub were longer, there would be an interference if i didnt change my angle. 
if i tangent my right 45 face to the surface of the pipe, then there's a fairly big gap. 

proper pivot point is 5mm from back of shoe. backofhole is 13mm from back of shoe. so go 8 mm past backofhole. 
now i will touch at the intersection of the plane and the sleeve (not in the chamfer)
it should be 0.006 in both directions. that will give me the right 45 face tangent to the pipe



----- Test Tank Stripped Welds ------
when tad chiseled out the cover leak, he said the entire cover weld was bad. he started chiseling the cover weld and it ripped out easily. 
no adherence. 
the extrudant was not bonding to the parent material. 
he suggested that i didn't scrape the parent material. at least not well enough
so after he chiseled them out, he scraped the entire cover weld. i also took the acorn drill scraper to it. I started welding it again. STILL no adherence. 
We checked the air temperature with a probe: 283
we checked the material temperature with a probe. that was fine also. 
we had a team of scientists watch it weld. they all said the weld form was perfect. no preheat blocking the tip. proper pauses. proper speed. proper scraping. 
the weld still stripped. 
tad used a mak18 (different spool of rod) to weld a segment on my tank. that was good. 
we checked the air flow rate. we had the wrong sensor so it maxed out the sensor. hard to tell. 
the air flow rate on the air flow sensor in the robot base, said about 3.5. 
we used the temperature gun to read the temperature of the parent material as it was being preheated. 
it said about 130 degrees celsius. 
we went to the floor to watch other welders and record their temperature. 
one was 138, but the rest were 160-170s. 
we came back and increased our air flow until the temperature was reading 160 on the parent material as it was traveling and preheating. 
air flow said about 4.5 at that point. 
we welded a bunch of test runs on this test sheet. 
personally, i think it adheres much better now that it's welding hotter. 
i asked mike van outen to check the welds. 
he confirmed that the weld we welded yesterday was shitty. (old spool, lower blow)
he confirmed that our most recent two welds (new spool, more preheat airflow) were strong welds. 
he also confirmed that the first two welds today were good strong welds (new spool, low preheat)
this indicates that it may be the rod that caused the bad welds, not the preheat airflow. 
the "bad" rod in question is vk24032070
the good rod is vk25000557
the good rod that was tad welded was 25 something as well. 
switching back to the bad rod did not recreate the problem (at the higher air flow)
we wanted to switch the air flow back down to lower. ryan switched it back down to below 4 (about 3.8)
i noticed some yellow liquid floating around in the air flow meter. 
kris said we had the robot hooked up to the wrong shop air valve. 
we should have been hooked up to the shop air valve with the oil-water-separator. 
we hooked up to that one now. but the oil is still in the line. 
with the preheat down below 4, (3.8), we still welded and we could see the giant preheat wake. this was not the case before we turned the preheat up. 
this indicates that even though we turned the preheat down, we didnt turn it down as far as it had been. 
even after turning the preheat back down, the welds we put on the test sheet were still deemed strong. 
the weld i put on the v groove was questionable, but i dont know.
i wish there was an objective way to tell if the weld was good, like if the weld was bonded or cold. i cant fucking tell. nobody can. everyone is just guessing. 


--- corner homing ---
trying to fix all the bad stuff.
why does it need to weird rotate? nobody knows.
i checked my notes from above. line 299. it says it potentially causes a clamping error. and i wanted to have a different joint angle combo. but also wrist3 was above 360 degrees. so thats why it needed the spin. 
i think that was from when i was homing straight (not homing 45). 
so, if the corner homing 45 does not result in a clamping error without the spin, then i could eliminate the spin. 
i'll check and see how far i can go before i get a clamping error. 
it can go without clamping error no problem. i could not create the clamping error no matter what i did. 
good that means i can make the change. 

for the bottom homing, instead of an orientation of 0,0,0, i should choose an orientation of 0,0,3.14. 
this would mean my cords are on the near side of the gun. the cords wouldnt hit stuff as much. i would need to make sure the cords didnt get tangled on the wrist or wrist clamps. 

this welder failed to extrude (robot 2) two times while welding the tiny tee for fillet sleeve. wtf.


wade changed the cage on robot 2 to be set with a set screw. 
hopefully thins makes it so that we don't have to recalibrate every time we take the cage off and put it back on. 
i think the welder itself should be calibrated still. we took it off but those bolts were not very loose. 
with the set screws back on i knew i needed to calibrate it first before i messed around with sleeve welding. 
so i calibrated the top tcp (to the temp probe) and then ran a box corner (dry run). 
the calibration barely changed. 
the calibration was right but the shoe looked crooked. 
aha. ohhhh. i figured out what the issue was. calibrating before was probably right but the shoe was put back on the gun crooked after wade switched the heating element. 
thats what made it collide during sleeve welding. i didnt notice it because it was mid-turn. not ortho. 
still bad. 
i welded a box floor corner. the weld was not good. admittedly, it was a wade box with different chamfers. 
so ill weld a normal box. 
before that i dry run it. 
it looks slightly tilted too far forward. 
i loosen the bolts that connect the gun to the mounting plate. there is a lot of rotational play in that direction. 
i orient the robot to straight vertical, then put the brakes on. 
i use a level to level the gun vertically, then tighten those two screws. 
hopefully that helps.
dry run again. normal box floor corner. 
on the first pass, the tip is too far left and too far out. 
on the second pass, tip is too far out and too far down. 
on third pass it is perfect. 
wtf. 
what would explain these?
first pass - tip too far left: either tcp_top z is too small (needs to be increased) OR tcp_weld z value is too big (needs to be decreased)
first pass - tip too far out: either tcp_top_z is too small (needs to be increased) OR tcp_weld_y value is too big (needs to be made smaller). 
second pass - tip too far out: either tcp_top_z is too small (needs to be increased) OR tcp_weld_y value is too big (needs to be made smaller).
second pass: tip too far down: either tcp_top z is too small or tcp_weld z (welder is too low) so tcp_weld z value is too high (needs to be made smaller)

the pattern is that the tcp_top z is too small and the weld y and z are too big, but why isnt the third pass wrong then?
if this was the case, what would happen on the third pass?
tcp_top z too small would make the pass too far out and too low.
tcp_weld y too big would make the pass too high
tcp_weld z too big would make the pass too far out

so maybe i need to increase the tcp_top z and decrease the tcp_weld y.
just by a mm each. 
idk dude. i feel like im just guessing. 
i think i should calibrate the weld tip first. 
ok.
i calibrated the weld tip first, using the very back of the tip as the point. 
the y value was 6 mm more (because of tip), and the z value was exactly the same. x value was different by 4 mm. that's front to back along the shoe. that doesnt matter. 
this is stupid

try decreasing the z of the weld, and increasing the z of the top, both by 1mm

that worked pretty good. maybe the _top adjustment was a little too much. i could drop that down half an inch. 
but now the bottom passes (second and third leg) are at an even height. 

for sleeve welding, calibrate the back middle of shoe, then set sleeve_piv 5mm in front of that. 

for conical tip, compare to regular tip
it is longer in the length direction by 2/16ths of an inch (compared to flat part)
in both tips, the extrusion hole is exactly lined up with the tightening screw is exactly lined up with the gun nozzle. 

on floor straight, if tank is less than 34 inches from robot, it may collide when lipping for bottom touch. 
the x axis is not aligned with robot cart so theres no great equivalent. 
i need to add a retreat to home branch for floor straight. if it is just sticking out to teach a point or to probe horizontally. 

peg welding (normal)
when i first tried going around the peg, the cords were interfereing with the "tank". 
so to start, ill try it a few inches above the surface of the cover, around i sleeve i set down. 
interference happened when getting to the top-left corner. 
i raised the lift column up 450 mm. 150 to get even with the weld, then 300 more. 
right now i am 33 inches from peg center. 
damn it that doesnt even work. 
i dont know that i can go that much higher or closer. 
ill check some tanks on the line and see.
i found a typical tank. the peg on the close side was 10 inches from the side of the tank, the far peg was 32 inches from the side of the tank. 
the tank side itself was ~10-15 inches from where the lift column could reasonably be. 
so a X distance of 47 inches might not be doable. fuck. 
maybe the ones on the far side i would have to get from the far side. same as a cover straight on that side. 
ryan had a good idewa. go around it the other direction. 
so, i can go around it clockwise.
yes this works much better.

i did a demo program for peg welding. going clockwise works well. my 4 points were inaccurate. i need to find some way to secure my pipe down as i'm picking the points. i dont think a clamp would really work because the clamp would get in the way. 
i just drew it with lines and held it there as the welder went around.
i did the whole 4 quadrants correctly. 
i then added to the program to make it do 6 ( = 540 degrees)
it failed because wrist3 got up to 360 degrees. 
i checked and at position 1, wrist3 was at -20 degrees. so i can't just rotate 360 degrees before starting. 
what this means is that if i want 540 degrees, i will have to start at a dfferent quadrant. 
i had been starting at the near quadrant (closest to the robot cart). 

damn it i am aligning for peg once before all the pegs. but i am calculating the path for all the pegs individually, and thats when the liftcolumn z needed is calculated.
i need to calculate once for index 0 just to get the liftcolumnzneeded.
ok so the first weld worls great. 
but when it finishes the first and pulls up, it tries to go to the second weld. it says Position close to joint limits.
i need an "unwind and reset" function after every peg. 
also on the weld, it looks like it is welding correctly. but the side of the shoe is riding on / rubbing against the edge of the pocket cutout. they may need to make that slightly bigger. 

























