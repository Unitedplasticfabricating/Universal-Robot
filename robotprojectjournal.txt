Robot project journal
Started: Monday 6/10/2024
By: Calvin

Monday I worked on assembling everything except the robot itself. I physically mounted the UR controller box, the MachineMotionV2, the robot safety module, and the emergency stop. To do this I had to take all the boxes apart and find the screws, allen wrenches, 
No instructions. No wiring diagram
Had to wire all the shit together. Screwdriver
Found weights to counterbalance
Got the robot mounted on with a forklift
Needed to know that my ip address wasn’t going to be in the pool of florida ip addresses
Robot safety module was preventing the lift column from operating so I removed that
Installed the urcap software via the usb drive onto the ur
Linked machinemotion and ur via static ip addresses and ethernet cable. 
I learned that program files are saved as program files on the pendant.
I learned that installation setups are saves as installation files on the pendant. If you plug in a usb into the pendant, I think you can transfer files into or out of the ur.
I think you don’t need the vention usb inserted into the pendant to access urcap functionality. It installs the program on the pendant itself and connects via the ethernet cable and staticip.
I got the robot oriented correctly in virtual 3D space, saved it as default.installation, backed it up onto flash drive, and saved it to github. 
I calibrated the TCP and payload for a robot with no end effector. 
Reminder: On page 125 of the manual, it talks about Manual Mode vs automatic mode. Manual Reduced Speed is the default. I need to figure out how to switch to Manual High Speed and have it set to do that as the default. 
Reminder: Installation -> Safety -> Tool Position has a warning symbol. I need to read section 1.24 in the manual Software Safety Configuration to figure out what the warning is. 
Reminder: set the Home position
Software Safety Settings. Password is plastic
Discovered joint limits for every axis is 363 degrees to -363. So, almost two full rotations around. The maximum speed for each joint in “Normal” or “Reduced” mode is 131 degrees per second, or 221 degrees per second for the wrist joints. 161 for elbow. So far, the robot has not come close to that speed. 
I was able to do a full backup of the robot. I went to the pendant’s hamburger menu -> settings -> backup restore or whatever. I gave a huge .urb file, which I think included the entire operating system of the robot, not just programs, installations, and variables. I was able to push this file into fork on the local branch, but I couldn’t push it to github because the file size was too large. So, I “Reset main to here” in fork to remove that commit. The file is one folder up in the “C:\Users\cbaumgartner\Documents\UPF source code”. 
I successfully made a square motion program!
I tried to make a peg welding program but received an error. Joint acceleration failed to pass sanity check. I think it’s because I tried to do a MoveL directly over the base. Anyways it errored and locked me out. When I try to restart the robot (safety system), (the 5 step process), when it releases the brakes it keeps erroring. It says “Fault: Robot cannot maintain its current position. Check if payload is correct”. Weird. 
The urp files are all gibberish, the ones I made myself. It looks like the original ones like the one that came preinstalled on the robot contain xml like structures, but the ones I made are compressed. 
I installed python to make a script to decompress those files. 

Big breakthrough
I talked to Luca from vention. For the robot stopping and faulting, we figured that out. I set the payload to 0.o kg (down from 1.3). That was what was breaking the program, that it was off by 1 kg. Sometimes the payload wizard in UR is not very accurate. So he recommends weighing the payload and getting that exact by hand and entering it in. For the payload center of gravity and the tcp position, you can use the wizard. 
He agrees with me that the initial breakage was caused by using a moveL in a large movement over the base. moveL should only be for smaller movements or movements that you know aren’t going to be too close to singularities. After changing the payload to 0, I ran the same program (with the moveL). The program stopped because it said “cannot achieve the requested position” or something like that. However, it did not power off the robot. I just hit enable and had to angular move the joints manually (fourth tab) to get myself out of the knot. 
Next, I set up the urcap. My computer was not connecting to the machinemotion at 192.168.7.2. Luca emailed me directions for how to set up the urcap connection to allow the robot to control the lift column. I called justin to get the connection working. 
Computer was not connecting to 192.168.7.2 in chrome. What I had to do was unplug my ethernet cable from both sides. Turn off machinemotion. Unplug machinemotin’s power cqable. Hold down its power button for 20 seconds to release any stored energy in capacitors. Then turn it back on. After this, my Ethernet – Network 3 icon in control panel -> network and internet -> network connections changed from no connection to ethernet. And going to the chrome ip worked. 
Next, I wanted to get it so the robot could control the lift column. I went to http://192.168.7.2/networkConfig. Under ethernet settings, I clicked LAN1 which is where the cord is plugged into. I set that to 192.168.3.52. Justin had to look in dhcp to find one in our network that wasn’t being used, because I don’t have that permission anymore. He then said he reserved that ip for me. 
Then I went into UR settings on the pendant and changed the robot’s ipaddress to 192.168.3.53, which was also available. Justin also reserved this for me. I then went into installation->urcaps and configured it to be 192.168.3.52. and saved the configuration. 
I then created a new program to test whether the urcap works. It does! When I played my program in automatic mode, it did raise thelift column by 10mm (which I specified). 
Also, when I clicked the UR+ button and jogged it, it did raise the lift column as well. 
The UR+ button only works when in automatic mode, or it does work in manual mode but only when you have the 3pe button pressed. If youre in automatic mode and jog the column, then switch to manual mode, the column will continue its jog but then will not take any more inputs unless the 3pe is pressed. You can hold the 3pe, press the jog button, wait for the column to start moving, and then let go of the button. It will finish its move. 
Reminder: you should figure out a way to change the settings so that you don’t have to hold the 3pe even in manual mode because that’s annoying. OR find out how to enable everything from automatic mode

I switched my journal to a txt document so i could copy into repo easier and see the changes. If i want to make it pretty i can always copy the text into a word doc. 

I completed copyfilesintorepo.py which is sweet. i plug in the flash drive, run that program, and commit fork. super easy to source control all my changes on the UR. 

Programs can be saved as files and run as a subprogram. To do this, start editing the main toplevel program. Click robot program. Click SubProg. Under subprogram file, select your file. This will open the file as a subprogram. 
By default, making changes to this subprogram will not affect the parent file. 
By default, making changes to the parent subprogram will not affect the loaded subprogram. 
If you want to change a subprogram, you can change the parent subprogram and save. then go into the parent program, loaded subprogram, and reload to pull the changes. 

How to enter freedrive mode mid program:
You can look at using the “freedrive_mode” script call to set the robot into freedrive mode and the corresponding “end_freedrive_mode” call to stop it. You can look at the URScript manual for understanding both of these functions.
In your case you could possible set up a thread that watches the digital input for enable/disabling the freedrive mode.
https://forum.universal-robots.com/t/open-and-close-the-freedrive-switch-while-the-program-is-running/18046/2

save tcp pose as a variable: https://forum.universal-robots.com/t/creating-a-variable-waypoint/19366

the types of variables are: bool, int, float, string, pose, list (page 163). 

I need to learn about rotation vectors in UR. i want to align my tcp perpendicular to a cardinal plane. But i have no idea how rx, ry, and rz work or what they mean. 
Apparently (according to the internet), UR uses axis-angle representation of rotation vector (opposed to RPY roll-pitch-yaw. I don't know what that is either). 

Coordinates/directions:

Feature: view. this is when i aligned the robot with the direction i wanted it to face
Rx=0, RY=0, Rz=0 is with the tcp pointing straight up
The x direction is straight out in front of the robot. specifically, -x.
the y direction is to the right. positive y is right. negative y is left

Feature: Base. this is the preset orientation of the robot. in this view, pushing the forward button makes the robot come back towards me at an angle
Rx=0, RY=0, Rz=0 is with the tcp pointing straight up


I watched some good courses on virtual reality and representation of 3d space by this guy from University of Illinois at some IIT school. I learned different representations of orientation in 3d space. 
1. Euler's yaw, pitch, roll with respect to airplanes (commutative, respect to horizon, not uniform especially when approaching vertical)
2. Euler's yaw, pitch, roll with respect to fixed cartesian axes. (not commutative)
Axis angle representations: length of v is 1 (unit vector). 
3. axis-angle representation in Exponential syntax 
	[(v1, v2, v3), theta] -> (v1*theta, v2*theta, v3*theta)
4. axis-angle representation in Quaternion syntax
	[(v1, v2, v3), theta] -> (cos(th/2), v1*sin(th/2), v2*sin(th/2), v2*sin(th/2))
	
Based on that info i came back and ran the robot in Base mode. Here the buttons are labelled. 

zeroing out all the Rx, ry, rz made the robot point straight up. 
pressing each button worked the same as rx:
	i press rx and the tool moves. Imagine an axis through the tcp parallel to the fixed cartesian x axis. The tool rotates around that axis. I then send the tool back home.
	while i am going, ry and rz values remain at 0. 
	rx value increases consistently, hitting .785 when the robot has rotated 45 degrees, 1.57 when the robot has rotated 90 degrees. 
going back to 0,0,0 rotation and using the other buttons worked the same way. they rotated the tcp about their axis. 
entering a value of 7 resulted in a value of .717 (7 - 2 pi)
crossing the 6.28 barrier manually moving results in the angle dropping back down to 0.01

next experiment:
i set the tool orientation to 0,0,0
i rotated rx to +.785 using the rx+ button. 
i then pressed the ry+ button. it rotated the tcp with respect to the y axis. not only did the ry value change as i went, the rx value changed as well. so did the z value. 
rx decreased to -.741, ry went from 0 to .760, rz went from 0 to -.318

Based on this, I hypothesize that the rx, ry, and rz values in the upper right corner (orientation coordinates) are defined using axis-angle representations in Exponential syntax. 

I also hypothesize that pressing the rx+, ry+, etc. buttons do not simply increase the rx coordinate and calculate the resulting position. 
	They send a small increment of a transform about the x axis (something like a (0.1, 0, 0) transform vector and calculate the resulting exponential syntax of that transform. 
	This is why the other values sometimes change when you give a simple ry+ command. 
	so, holding down the ry+ button will make the robot perform a rotation about the y axis. But a rotation about the y axis most likely will change all 3 values in exponential syntax. 
	
You can set the rotation vectors to (90deg, 90, 0) or (.785, .785, 0). It looks like it's pretty close to a 45 degree rotation in both the x and y axis but i'm not sure. 
An example of this is that I set rx = 90deg (1.57), ry = 90deg (1.57), rz=0. it found the position. 
	the robot was pointed slightly down and at an angle. it was not orthogonal to any of the major axes. 
	however, projecting onto the x-y plane, the robot was at a 45 angle to the major axes. 
	this only makes sense if you understand axis-angle representaion with Exponential syntax. 
	
I need to make a list of the common orthogonal positions and common 45 (45 degrees with respect to one plane, ortho/parrallel with respect to the final axis) positions and their Exponential representation
	so that i can quickly position my robot in that orientation at a given position. 


I need to learn how to combine the position coordinates of a stored position (x,y,z) with manually setting the orientation coordinates. Maybe could be pose_add(), pose_sub(), or pose_trans(). 
update: they are hard to understand
look up how to manually enter poses
they used pose_trans() with a p[0,height,0,0,0,0] to manually tell it to go up height meters. 
https://www.universal-robots.com/articles/ur/programming/moving-to-a-position-calculated-from-user-input/
ill look up how to create my own function . cant

coordinate system:
i found out that the X+ direction is out away from the base. forward

for homing, use a tcp on the side of the gun. if the gun is attached sideways, then have a "rubber tip" "through" the gun (parrallel to robot arm). 
set this as a separate tcp in installation, and call the homing commands using that tcp.

the homing program wasnt working because of how the test box was mountd on the table. when it was homing on the bottom face, it was hitting into the table and faulting. 
i looked at the station in the express cell line and this isn't going to be a problem out there.
we are going to change the attachment of the test box to the table. in the mean time, i will adjust my program to avoid the table. 

i made a Main Method, and put test teach position into it. the thread that was part of test teach position did not come. running the program did not put the robot into freedrive mode at the correct time. 
copying over the variables setup and the thread into Test Main Program did make the program work. 

god damn it. 
it doesnt like nested subprograms.
i have some programs for aligning the tcp with a cardinal direction. 
my program corner homing brb contains calls to those alignment subprograms
i tried to put corner homing brb into my main program as a subprogram. robot didnt like that. 
it said 'the subprogram contains one or more calls to other subprograms. open corner homing brb and remove any contained subprograms, save, and then try again to add it.'
https://forum.universal-robots.com/t/subroutine-within-subprogram/12634 says you can do it as a subroutine, as a subprogram within a script block, or as a user-defined function

i added the plate to the robot end and added a tcp and payload into the system. 
when i set those as the active payload, the robot does some weird stuff when running the program. it bonks into itself when trying to align left

work on one corner. perfect that. and move the robot roll wheels to each corner on the tank.

want to reorientate the robot on the stand. everything is opposite
right now the cord is pointing left (when looking WITH the robot). we want the cord pointing right
robot reoriented with forklift

i learned you can use breakpoints in the software.
i learned that a subroutine is just a call to a subprogram.
script commands can be done using a single line or via a file
i need to try out this file script editor. 

i got the robot to follow the path on both sides, but when it goes around the corner, the angle dips. it does not maintain level orientation. 

maybe i need to do a "circle move" as part of a moveP command while welding and going across the corner. 

i try making a test circle move program out in space. it does not work very well. 
when the orientation switches from left to forward, the arm does a weird swivel to orient itself. it seems like an unnecessary swivel. when i use those points in the program of a moveP, the robot faults out. 
it is trying to maintain its speed (a pretty slow speed), but it needs to rearrange its joint angles to move just the slightest in tcp. 
i believe this is called approaching a singularity

i set a position by manually rotating the joints (instead of using the Move screen's rz+) and that did result in the robot not doing its weird dip. 
but it faulted because it needed to move at a constant speed and the distance was super small and the direction change was a lot.

motherfucker i dropped the speed down from 250 to 20 on the entire path.
it went so slow on the straight part, "sped up" a little on the curved part and then partway through the curved section stopped. 
warning: sanity check
protective stop: path sanity check failed: sudden stop
i will try ensuring that the three points on the path for a smooth curved
6.35 mm = .25 inches

rx,ry,rz patterns:
i go to align_left, then spin the head manually with Move Rz+ to a 45 degree angle. During this time, the ry and rz values go from 0 and go up. they are always equal.
i need to figure out what the angle is for align forward/left 45 degrees

it looks like th script feature in the robot does python but doesnt do tuples. damn. 

i need to calculate the midpoint of the arc turning around the corner
https://math.stackexchange.com/questions/4694976/calculate-length-between-intersection-of-circle-and-2-tangent-lines-relative-to

i got a program going. it goes smoothly through p2. but it stops at p2 (i put a breakpoint) and the center of the tcp is still 1.25" short of the end of the box
super weird. could my intersection calculations be off?

i added popups to the program so i can see what the coordinates are for all the points its calculating
i plotted the points and the points look fine
lucas took a video for me while i was performing the circle move. the tcp (end of robot) is in contact with the box and thats why it stops. 
BUT its supposed to be in contact with it. in the video, you can see the robot performing the desired motion. 
It is not "trying to go through" the box as much as it is just sliding around the corner of the box
so, the contact here is good. I don't need to change the motion, I need to tell the robot to not Fault out when it feels contact
I think i can achieve this by adding a force effect
additionally, after faulting out, i clicked Enable and continued the motion and it worked as intended, went to its desired position point 3

I made a test program to test whether the Force command actually worked
i set two waypoints a few mm off the side of the box, and moveP'd the robot from one point to the other. the robot did not touch the box
I then put that move command inside a Force command of 5N. It now touched the box and i couldnt fit a piece of paper or plastic in between the toolhead and the box while it was running

adding the force command to the main program still results in a protective stop while rounding the corner. i wll try specifying the tcp and also trying a larger newton value.
another thing to consider if this doesnt work is temporarily turning down the protective stop sensitivity, hopefully just while performing that force move

found a video on protective stops: https://video.universal-robots.com/tech-talk-understanding-protective
faults, violations, and protective stops are the three ways the robot can stop due to itself observing that something is wrong
a protective stop is issued when the robot can no longer perform the intended motion
a violation is when a safety system observes that a safety limit is exceeded
a fault is when the safety system detects a fault in the hardware or software
a torque window is the amount of current the robot expects to use in order to accomplish the necessary motion. if it needs more than that (outside the window), this is an indcator that the robot is blocked by someone or something.
"scaling" is lowering the acceleration for normal payloads or heavier payloads. 

i will try changing the variable in the program to .03 inches (a 32nd of an inch) down from 0.25 inches, so that it doesn't try to go into the box
I got rid of the radius and changed the rotation command from a moveP to a speedl() in script. 
when i do it in the main program, it sometimes gets singularity errors
it sometimes gets protective stops because point2 is stopping too early and turning into the box. but when i look at the intersection point, it is accurate
i figured out one of the problems. i switched the moveP from p1 to p2 into a moveL, and now it stops at the correct point. 
I believe it was stopping early before it got to point 2, because of a blend radius (25 mm = 1 inch). that would explain why it was stopping one inch too short. 
the singularity thing is still there when i do the speedl() command

I figured out why the singularity is happening. 
when all 4 axes are aligned, this is an example of a singularity. when it spins from the first edge to the second edge, it passes through a position where all 4 robot axes are aligned. 
i think the robot can make it through this position if it is part of a move command, but stops if it is part of a speedl() command or a manual move (fourth tab on pendant).
i have a video from july 30 where the robot is performing the "around the corner" motion in space, and it hits the singularity, drops its wrist below (which interrupts the motion), but then continues on. 

I figured out that i needed to mount the welder sideways on the cobot (the ryan orientation) in order to avoid the singularity
I batched, cut, and welded a demo welder the same dimensions as the mak-rob.
now i need to figure out how to atach it : both the model and the actual welder
talked to lucas and ed because ryaN WAS WFH. considered brass inserts, mounting plate, etc. the problem is you need clearance in order to tighten the bolt head, and most of the designs they came up with do not have clearance to tighten the bolt heads. 
considered threaded rod
talked to rick about clearance. plan is to make a demo mounting plate out of 1.5" plastic. if it works, get it made out of 1.5" steel
countersink bolt heads on both sides. bolt the plate onto the weld gun first. (because there will be no clearance for this after plate is attached to robot). 
then bolt plate onto robot. there will be clearance for this on either side of the mak-rob's metal plate. 
if there is not enough clearance for this using the holes on the tool flange adapter (4 small holes), then switch to mounting it straight onto the 6 main holes (slightly wider spaced). 
i need to add that metal block chunk to my model of the welder (in plastic). i will use real brass insert though. 
i need to find which bolts fit into the welder block, which bolts fit into the tool flange adapter, and which brass inserts i need to replicate the holes in the welder block. 
then i need to cut a batch out of 1.5" that includes the model of the block and the mounting plate with holes and counterbores. 
then weld the block onto the model welder

Determined that the pretend gun, screws, and a pretend block are 3 lbs 11 oz. the pretend block was 7 oz of that 3 lbs. the real block is almost twice as much. guess = 4 lbs exactly if we replace the pretend block with the real block. 
add the 0.31 kg of the plate and plate screws to that and we get a total of 2.124 kg for the pretend gun setup. 
begin installation for that. 

tcp orientation
i want to have one tcp for probing. that will be the topside of the gun and will have the same orientation as normal. 
the second tcp will be the weld tip. its orientation must change so that i can use the convert_heading_to_axang() function and have it be correct
to do this i have to set up the orientation at 0 so that a 90 degree rotation cw about the +y axis will result in a heading of 0 (respect to the +x axis).
the position that accomplishes that is the robot end facing backwards and the tip of the gun facing up
to get there from the natural rxryrz orientation, we need to first rotate clockwise, then rotate backwards. 
ill first ask openai to calculate that for me and see what it gets. i have it in position but it's not exact. if openai gives me something thats close to what i have (few decimals off), then ill know its right
it kept giving me (0,1,0,π), which i know isnt right. its supposed to be around (2.28, -2.54, 2.52). 
the first rotation is (0, 0, -pi/2) (in exponential) (rz- by 90 deg)
then we rotate in the ry+ direction. (0, pi/2, 0) in exponential. 
apparently (rx,ry,rz)=(vx⋅a,vy⋅a,vz⋅a), is referred to as the rotation vector or Rodrigues vector, not exponential coordinates. 
ill rotation matrix this out.
-y becomes positive z. positive y becomes - z. 
positive z becomes positive x. negative z becomes negative x
positive x becomes - y. -x becomes positive y. 

the appropriate rxryrz is (-2pi/(3sqrt(3)), 2pi/(3sqrt(3)), -2pi/(3sqrt(3))) = (-1.20919958, 1.20919958, -1.20919958)
i type this into the move screen and the robot barely moves, indicating it is correct. It immediately converts that rxryrz into: (2.419, -2.419, 2.419). 
it must like that better. i know in axis angle representation there are always two equivalent rotations to get the result. 
if you flip the axis and negate the angle you will get the exact same rotation. to avoid duplicates the robot program must have some rule where it chooses which one. this is fine. time to test. 

testing worked golden for that part. now i need to adjust my programs so that it works with this new setup. 
when it gets to the align_left() command in main program, it does not work well. it does align leftwards, but it also moves the tcp so that it misses the corner. 
i tried changing the moveJ command inside align_left() and align_forward() from "Use active tcp" to "pretend_w_top". but that didnt work it still moved the tcp. 
i paused the program mid program with a breakpoint. I went to the move screen and i saw that the active feature is Base and the active tcp is tcp_plate_1. this is a problem
i need to figure out how to change the active tcp. the default tcp is already pretend_w_top. but how to change the active. apparently they are different. 
use the set command

running align_left() as a standalone program works perfectly. tcp stays the same and the gun rotates around the tcp. 
but running align_left() within the Main Program does not. it moves the tcp when it aligns. 
even after re-adding the align_left() subprogram to Main Program, it still rotates about the end of robot (old tcp) when performing align_left. 
i went back to the move screen and now it says that the active tcp is tcp_1_plate. wtf.
i step through and debug to figure out how this happened. i set a breakpoint after Set and after Test_Teach_Position(). at the start, tcp is plate1. after Set, tcp is w_top. after Test_TP(), tcp is plate1. 
it could be that the sync() to the thread is causing the tcp to get switched back. 
nope. there is a command in test_teach_position (moveJ) that sets the tcp to plate_1. stupid me. 

GOT IT!
fuck yeah
it completes the entire weld, pretty smoothly (tiny jerk at the start of the corner, i could reduce the acceleration value there), goes back to home and is ready for the next iteration. 

How to attach welder (fake):
attach tcp plate to welder. 
screw on mounting plate to tcp plate. (extension the same direction as the black dot on wrist 3)
screw on welder to mounting plate (weld tip pointing same direction as black dot on wrist 3)

corner homing 45 - want to make the corner homing more robust. for the normal corner homing, if the robot is too close to the tank, it hits itself when homing, going around the corner or under
if the tank is too far away, when it tries to home on the left side, sometimes it maxes out the reach of the robot arm.
there is a pretty small window for where the robot can be in relation to the tank and have it still work.
in order to increase that window, we want to switch to a corner homing that's 45 degrees from both faces of the tank. that way we dont have any crazy reaches. 

during corner homing 45, the first side works very well. when it goes over to the second side, it has a clamping error. 
if i rotate the wrists differently, (and slightly move shoulder elbow up) i can achieve the same position and orientation without the clamping. 
there are multiple joint angle combinations that result in the same position-orientation of tcp. 
i want to prep the robot to use the joint angle combo that does not have clamping. I set a fixed waypoint (waypoint 5) that is close to the base and in the orientation that i want to use for ph4. if i go to this before moving to ph4, the robot will use the preferred joint angle combo at ph4.
unfortunately, the preferred jointanglecombo at ph4 results in wrist3 rotation exceeds limit, with a wrist3 rotation of over 360 degrees. i need to do a 360 spin of wrist3 on the way to the preferred position. 

when doing my complicated spin \ rearrange motion, i need to make sure there are no variables involved so it does the exact same thing every time. 
i need to make sure i go from fixed waypoint to fixed waypoint before going to the variable waypoints again.
i can do this as a combo just with waypoints, or i can also include a speedl of wrist3 in there to do the 360 spin

ok cool so that worked, setting intermediate waypoints to do the turns, flips, and bottoms and all that stuff. 
we even attached some weld wire to the pretend welder and also attached it to the robot arm above wrist1. worked pretty good. didnt get tangled. we only needed like 10 inches of slack. it did get caught on the L bracket when coming back to home. 
need to have it come back to home from above or something. idk. not really that important now until we get the actual welder mounted. 

next i want to work on the R/L second pass of making the weld go up after it comes around the turn. 

calculate the rotations needed to weld vertically starting from the bottom and going up, with the right side of the welder (preheat tip) leading
i put the welder into 0 orientation. at this point, the tip of the welder is facing straight up and the bottom of the welder is facing x- axis. 
i need to figure out a rotation that will put the welder within a yaw of correct, no matter what angle the box is at. 
i need to put the welder with the tip facing the x+ axis, with the preheat (right side) facing up. 
a rx of 90 degrees (from 0,0,0) puts the welder tip facing the y- axis with preheat up. 

I also want to to a full heating pass before I start welding. I will use a separate TCP (welder_preheat) that is like a centimeter out farther than the actual tip of the welder, and make it follow the same points the weld is going to go. 


I got the full program working for how I thought the weld path shouldve went. clockwise from right to left along the bottom edge, then moving back and welding up from bottom to top. 
It works pretty smooth and doesnt tangle itself. 

However, Andrew wants a different weld path procedure. 
Ron sent a video of what they are doing in florida. first you come down from the top, then fork right (if its a right side weld). then you go back to the weld path intersection, and turning clockwise, go around the corner and continue onto the left side. 
This path involves two turns instead of just one. One L turn, and then a wraparound turn. 
Personally I think this way of doing it is going to be less good. More turns means more places for potential error or leaks, plus its harder to code. But its not my company. 
Before I can connect the points I need to find more equations for heading_to_axang: the orientation of the vertical weld going straight down, and the orientation of the weld moving to the right (ccw). 

for the vertical weld moving downwards, the first turn is about the x axis the other direction. and then -pi/2 not +pi/2 for the heading angle. 

for the ccw weld around, rotate about the y axis 90 degrees, opposite of the first equation. then for final result add pi to heading. 

full weld path is working
is it robust? can the robot be positioned a little closer, a little farther, or at a different angle and have the program still work?
no
the problem is going to be the bottom part of the L (for right side). in the current path, it works. but i paused it at the bottom of the L, after it has turned. 
if i move (speedL screen) 17 mm back wards (x+), the gun butt hits the robot forearm. 
if i move 55 mm left (y-) then the butt hits the forearm. 
if i move 126 mm down, the gun butt hits the forearm
these are pretty small changes. meaning we are pretty close to the edge of viability. the range of viability for this setup is how i had it and even further out. anything with the robot closer to the box will not work. 
this second turn really sucks

one solution we thought of was to raise the tank up, like on a lift table
another solution we thought of was to move the welder forward on the mounting plate. this would require a new mounting plate to be fabricated. 
in order to do that and test the new plates i cut out of plastic, i want to unattach the welder and try out the demo welder. 
the amount of slack we are using on the cords is perfect. how much is it?
it is 44 inches of cord slack, measured from the white base of preheat to the tape on the robot arm. the three cords are zipties together at a couple locations along that path. 
it is attached 5 inches up the arm, measured from the tape to the black line opposite the wrist 1 joint. 
it is attached on the top. this means at home position, the cord attachment is on the x+ side of the forearm. 

i batched a mounting plate with the attachment extended 2 inches past standard. 
I attached the pretend welder, and made a new home and tcp for it.
ran the program and it worked great. ran it again to see how much leeway we have:

if i move 207 mm back (x+), the gun butt hits the robot forearm. 
at x-1171 (normal position), i can move the arm left (y-) as much as i want and the gun butt will not hit. 
at normal position, i can move the arm all the way down with no interference

the rockets used in station 3 are 27-36 inches tall. including all the beams and stuff the tank floor would sit 36 inches off the ground. 
our test box is 42 inches tall. luckily, going from 42 to 36 inches doesnt change the forearm angle very much at all. 

ill put tape marks on the floor under the base's back two levers and see and see if moving the base causes any collisions
a folding arm on the front of the tower. go/nogo for robot base alignment
have an arm attached to the front of the tower. telescoping. it fold out straight away from the tower. on the end it has a "Y". the crook of the y is about a 110 degree angle. 
tell them to use the arm checker the first ten times they use it, and the first time every day. 

actual welder mounted on 2 inch plastic mounting block and calibrated.

how to hook up the welder. the power box came with a euro 230v plug. that needs to be changed to an americas 230v plug. 
also, there is no 230v outlet in the back corner. we will need to do electrician work to provide one. 
after that gets hooked up, the control box on the welder, and the robot welder operating instructions, should provide an easy way to turn the gun on manually. (not extrude). 
the robot welder Heat Control Serial manual says that the 9 pin connector into the control box, some of the functions of HeatControl can be controlled via a RS232 serial interface remotely
bing copilot says A 9-pin connector, often referred to as a DB9 or DE-9 connector, is commonly used in serial communication applications

i asked vention for advice on how to convert UR output into DB9. we will see what they say. 

ok i think i got it. i need to send a signal through the digital output into pin 3 (RX). 
and that signal needs to be üR1
no. digital output can't send ascii signals. according to vention, it is only able to send digital dc voltage signals or pulses. 
i need to send the signal via the usb port (Universal Serial Bus), and using a USB to DB9 converting cord, with URCap to properly send USB to RS232 signal. 
i found a URcap that has that functionality, including a special mode to send special characters (needed for the start of signal sequence). 

Dude, the electrical guy STILL hasnt given me an outlet. I need a 230v outlet to run the gun. I would like to do the testing back in my robot corner. 
Linking multiple extension cords can decrease the voltage and cause power drop, affecting the gun. dont really want to do that. 
its been 3 days though and im kind of just waiting for that. the motion is good. just waiting to add the extrusion aspect of it. 

slack vacuum hose exp:
~44 inches of slack. attached at the right side of welder cage, pointing backwards/down. other side attached ~8 inches up forearm attached on downward side (when in home position).
this seems to work pretty good. 

dude the gun is all fucked up. 
we turned on the gun the normal way (using the buttons) and almost immediately it gave an oeair error. 
the temperature for the material and the preheat was set correctly. the live reading for the temperature was looking good, but the live reading for the preheat kept saying 43 degrees. 
we think there might be a problem with the air pressure. we are using shop air, with a pressure regulator (and pressure sensor after the regulator). 
it also could be a bad wiring connection into the preheat region. we replaced the clunky wiring connection box with a soldered twist on connection. could be a bad solder or a crossed wire. 
wade is colorblind so that doesnt help. 

the password to get into the munsch menu is 8980 (down down check down check down down check check)

welp. using the usb to serial cord with my computer and putty did not work. putty was kind of clunky to work with and i could not get any response from the gun. no commands registered. 

i installed the urcap for wiretank serial
bingo!
we have success. 
i successfully sent a bytearray command to the welder to start heating. i also sent a command to the welder to stop heating. both worked. 
i have so far been unable to receive any commands back, whether from a uR1 command or from a uR? command. 
i think it may have to do with the installation-term characters. 
before i mess with it i want to save it those

the text i receive from a query always says "Operation timed out!"
i think maybe it has to do with the term chars. 
i first tried CR for both. then i tried None for both. neither worked. 

we got the gun to extrude. that is successful. we had to buy a 5V DC power supply and solder it onto the end of the 5 prong cable they gave us. 
Definitely weird that they required us to solder wires together in order to get the gun to run. Feels like munsch didn't send us a finished product. 

We compared speeds to the extrusion speed of a normal MAK 18. We decided that a speed setting of 4 was equal to the normal speed of a MAK 18. 

Wade is replacing the wiretaps of the thermocouple with some extra wires and soldering that in place so that the robot isnt motionally constrained. Next will be a straight weld test. 

straight weld test was a HUGE success. the welder welded amazing welds every single time. 

corner weld was mixed results

there is something weird where twice now the program said uR1 and sent the command but the welder did not start extruding. Im thinking maybe the signal didnt get heard for some reason. 
We ran the exact same program again and the extrusion happened (both times). something to keep an eye on. 

we have been adjusting the extrusion times of when to start and stop extruding along the path. 

one problem i need to fix is the Around portion the extrusion hole is kicking out around the corner in open space leaving a really poor weld there. 

Also, the straight welds of the corner isnt as good of quality as the straight welds of the actual straight. 
Could be that the box is missing a chamfer on one side. 
Could be that the welder is too far from the box. 
I want to adjust the tcp to push the welder closer to the box. 
Adjusting the tcp to push the welder farther into the box would be a y- move in tcp. (no, a y+)
adjusting the tcp to move the tcp back from the tip towards the hole would be a x+ move in tcp. (unsure)
adjusting the tcp to tilt the angle farther onto the back of the shoe would be a rz- move in tcp orientation, performed after the currentorientation moves. this would require rotation matrix calculations. 

when we switched to the double chamfer box, the welder in the Down weld was not in the right position. 
the tip was not far enough in the chamfer, and it was resting on the left side. 

i recalibrated my tcps according to what i needed. measured the adjustments that i needed to make and made them. 
the path it follows is perfecteverywhere except for the very top of the first weld. 
this is because the box is not level. the vertical face is not vertical. so that makes sense. it still makes a good weld. 

performing this weld yields pretty good results. the first two welds - straight section - are pretty clean. 
the first corner looks idk. kind of goopy. hard to tell though because the second pass changes it. 
the second pass needs adjustment. the triangle tip drags/pushes through the weld goop, and the tail end swings out, welding into airspace. 
because of the triangle tip pushing through, there is goop in front of the triangle for most of the third weld, resulting in an unclean weld. 

my solution is to add a third tcp (weldhole) that is pushed back from the tip to the hole. this third TCP will be just like pretend_welder, but have an adjustment in the x direction

it looks like the first turn does go faster now that i sped it up. im not sure how much faster. 
tomorrow i need to edit the script to control the weld distance separately of all the different welds. for example, i want to decrease the second weld distance. 

we welded three boxes. 
box 2: corner1: original
corner2: added rod straightener. removed trigger halfway through first rotation. it was funky and didnt extrude enough stuff out. could be that rod straightener was too tight or an air gap. 
corner3: reduced wd3 to 3 inches
corner4: same as corner 3? i think. 

box 3: corner1: same as box2 corner 4, but with the rod straightener slightly loosened. 
corner2: same as corner 1
corner3:changed the preheat pullback so it didnt pull back as far. it hit the weld
corner4: changed the preheat pullback so it wouldnt hit the weld. it just brushed the corner. 

box4: corner1: same as box3 corner4
corner3: dry ran because weld rod broke. also bad signal send. 





