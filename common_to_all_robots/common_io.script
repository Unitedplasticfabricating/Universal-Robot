# common_io.script
# this file contains IO (input/output) commands, commonly used by robot programs
# includes rs232 commands, lift column commands, and calls to native universal robots functions (like get_inverse_kin_has_solution())


# Section: rs232 commands ###############################

# this function sends a signal to turn extrusion on
def turn_extrusion_on():
  # flush the channel
  resp0 = send_serial_signal(["u", "r", "?"])
  # send the signal
  resp1 = send_serial_signal(["u", "R", "1"])
  # if resp <> "uR1"
  if resp1 != [252,82,49]:
    # turn off extrusion and heating. inform calvin
    resp2 = send_serial_signal(["u", "R", "0"])
    resp3 = send_serial_signal(["u", "H", "0"])
    popuptext = "Error code encountered while trying to start extrusion. Find Calvin. "
    while 1==1:
      popup(popuptext, title="Extrusion Error Code",blocking=True)
      popup(resp1, blocking=True)
    end
  end    
end

# this function sends a signal and receives a response
# signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
def send_serial_signal(signal):
  signal2char = signal[1]
  signal3char = signal[2]
  listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
  resp1 = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", listsignal, True)
  return resp1
end

# this function converts a letter into its ascii number
def get_corr_number(letter):
  if letter == "A":
    return 65
  elif letter == "H":
    return 72
  elif letter == "R":
    return 82
  elif letter == "M":
    return 77
  elif letter == "E":
    return 69
  elif letter == "a":
    return 97
  elif letter == "b":
    return 98
  elif letter == "h":
    return 104
  elif letter == "r":
    return 114
  elif letter == "s":
    return 115
  elif letter == "m":
    return 109
  elif letter == "0":
    return 48
  elif letter == "1":
    return 49
  elif letter == "2":
    return 50
  elif letter == "3":
    return 51
  elif letter == "4":
    return 52
  elif letter == "5":
    return 53
  elif letter == "6":
    return 54
  elif letter == "7":
    return 55
  elif letter == "8":
    return 56
  elif letter == "9":
    return 57
  elif letter == "?":
    return 63
  end
end

# this function checks whether the welder is in the ready state. 
# to be called at the beginning of Main Program
def welder_state_ready():
  # flush the channel
  resp0 = send_serial_signal(["u", "s", "?"])
  # send the signal
  resp1 = send_serial_signal(["u", "s", "?"])
  # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
  if resp1 != [252,115,49]:
    popuptext = "Welder is not ready for extrusion. Follow the instructions to start heating welder. "
    while 1==1:
      popup(popuptext, title="Welder Not Ready",blocking=True)
    end
  end
  
end


# Section: lift column commands ##################################

# initialize a lift column extension needed of 0.0
global liftcolumnzneeded = 0.0 # set this variable in mm

def get_lift_column_height():
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  #$ 5 "MachineLogic Get Position"
  while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    while(temp_estop_var_vention=="estop/status true"):
      if temp_estop_var_vention=="estop/status true":
        sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
      end
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      if temp_estop_var_vention=="estop/status true":
        popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
      end
    end
  else:
    popup("resource is being used already: MachineMotion1")
    halt
  end
  socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
  temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
  global var_1 = temp_drive[1]
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
end


def get_lift_column_height_condensed():
  socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
  temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
  ret = temp_drive[1]
  return ret
end


# Section: Native UR commands ###################################

# this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
# this function does NOT check for weird twists or joint limits
# inputstruct must contain only points
# it returns true if all points are valid. it returns false if any points are invalid
# a list of length 0 indicates that all points are valid
def check_structofpoints_validity(inputstruct):
  # next, check whether the touchpoints are reachable
  structlength = length(inputstruct)
  i = 0
  allvalid = True
  while i < structlength:
    curr = inputstruct[i]
    valid = get_inverse_kin_has_solution(curr)
    if not valid:
      return False
    end
    i = i + 1
  end
  return True
end


# this function takes in a struct of only points. it checks those points for validity. 
# if one of them is not valid, it throws a popup loop
def check_validity_only(struct2):
  validity = check_structofpoints_validity(struct2)
  if not validity:
    # bad
    popuptext = "Not all weldpoints are valid. "
    # infinite loop
    while 1==1:
      popup(popuptext, title="Position Error",blocking=True)
    end
  end
end


# this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
# arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
# returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
def can_pose_be_reached_without_twist(pose, orig_joints):
  # first, determine if the pose is valid
  valid = get_inverse_kin_has_solution(pose)
  if not valid:
    return False
  end
  valid = get_inverse_kin_has_solution(pose, orig_joints)
  if not valid:
    return False
  else:
    joints_1 = get_inverse_kin(pose, orig_joints)
    #iterate through the 6 joints
    allGood = True
    i = 0
    structlength = 6
    while i < structlength:
      joint_curr = joints_1[i]
      # check for anything that exceeds joint limits
      degreesmax = 360 * pi / 180 
      if joint_curr > degreesmax or joint_curr < degreesmax * -1:
        allGood = False
      end
      # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
      maxdifference = 150 * pi / 180 
      difference = joint_curr - orig_joints[i]
      if difference > maxdifference or difference * -1 > maxdifference:
        allGood = False
      end
      i = i + 1
    end
    return allGood
  end
end
