
def main_calculate_step(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top, leftseam, leftobstacle):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    if leftseam:
        if leftobstacle:
            struct2 = calculate_LtUA_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
            heading1deg = struct1[1] * 180/pi
            if heading1deg < 210:
                popup("Robot is not aligned 45 degree angle from corner. Wrist pinch may bonk, Align robot 45 degrees from corner and try again. ", title="Alignment Error",blocking=True)
            end
        else:
            struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
        end
    else:
        if leftobstacle:
            # error: this geometry is impossible for the robot to weld
            popup("Cannot weld a right seam, left obstacle step corner with robot. please weld by hand. ", title="Geometry Error",blocking=True)
        else:
            struct2 = calculate_DAaU_step_right(struct1, list1, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top)
        end
    end
    validity = check_validity_only(struct2)
    return struct2
end

def main_calculate_step_left(p11, p12, p21, p22, p3, p13, p23, noncappingsidewallthick, cappingsidewallthick, tcp_pose_top):
    struct1 = analyze_touchpoints_only(p11, p12, p21, p22, p3)
    list1 = analyze_vertical_touchpoints(p11, p12, p13, p21, p22, p23, p3)
    #struct2 = calculate_DOtA_points_right(struct1, list1, chamferover)
    #validity = check_validity_right(struct1, struct2)
    struct2 = calculate_DAaU_step_left(struct1, list1, cappingsidewallthick, noncappingsidewallthick, tcp_pose_top)
    validity = check_validity_only(struct2)
    return struct2
end

# analyze_touchpoints_only()
# it takes 5 arguments as points
# it returns a struct containing: (pointintersect, heading1, heading2, heading3, l1delxunit, l1delyunit, l2delxunit, l2delyunit)
#   FIND HEADINGS
#for each heading, find the angle of the line with respect to the pos x axis. then add/subtract 90 degrees because you want to be perpendicular to that
# so, heading1 finds the angle (from the +x axis) to the position pointing perpendicularly into the box. 
# we need to be +90 degrees of all 3 headings. (but we can ignore heading 2)
def step_right_demo(struct1):
    pointintersect = struct1[0]
    x = pointintersect[0]
    y = pointintersect[1]
    z = pointintersect[2]
    heading1 = struct1[1]
    heading1adj1 = heading1 + pi/2 #(90 deg) (parrallel to edge not perpendicular into
    heading1adj2 = heading1adj1 - pi/2 #(90 deg) (from y+ not x+)
    # heading1 == heading1adj2. ok 
    m1 = get_rotation_matrix_from_description("z", 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    point_demo = p[x, y, z, rxryrz[0], rxryrz[1], rxryrz[2]]
    popup(point_demo)
    movej(point_demo, a=1.4, v=0.1)
    popup(point_demo)
    ret = struct(point_demo = point_demo)
    return ret
end

# for a left seam step corner, calculate the toolpath points for a L (under) then Up and Around weld. for left obstacle step. 
def calculate_LtUA_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = tcp_pose_top[2] - pointintersect[2] # the z distance from the corner to the top of the weld
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    # get rxryrz for facing along towards the intersection. heading1 +90 deg - 90 deg
    m1 = get_rotation_matrix_from_description("z", 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    # get rxryrz for facing along the second edge pointed toward the left. heading 3 + 90 - 90
    m1 = get_rotation_matrix_from_description("z", 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    # now calculate the points of the Up Around
    # don't use heading3 at all. 
    #point201 is at the chamfer intersection
    p201x = xbottom
    p201y = ybottom
    p201z = z
    
    # rxryrz is the same 
    m1 = get_rotation_matrix_from_description("z", 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, p201z, rx, ry, rz]
    
    # find side point (point on the side. where point 203 would be if roundoverdistance was 0)
    sidex = pointintersect[0] + l2delxunit * rightwallthickmm
    sidey = pointintersect[1] + l2delyunit * rightwallthickmm
    sidez = z
    
    # p202
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    p202x = sidex + rod * l1delxunit
    p202y = sidey + rod * l1delyunit
    p202z = sidez
    point202 = p[p202x, p202y, p202z, rx, ry, rz]
    
    # p204 end of circle move
    p204x = sidex
    p204y = sidey
    p204z = sidez + rod
    
    # calculate rxryrz
    # first rotation: 90 degrees about x axis. positive direction. preheat is now facing up, and gun tip is pointed towards y- direction
    m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
    # second rotation: rotate about z until you are facing into the front face. but only use heading 1
    # heading 1 is about 225 degrees. i need to go about 225 degrees. starting from y- instead of x+ cancels out the extra 90 degrees needed to go into face1 instead of parallel to face1
    m2 = get_rotation_matrix_from_description("z", 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point204 = p[p204x, p204y, p204z, rx, ry, rz]
    
    #p205 (end of straight after cirlce move, before listleans
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point205 = p[p204x, p204y, sidez + sld, rx, ry, rz]
    
    #p206 (top of weld)
    p206x = sidex + wd3 * listleans[0]
    p206y = sidey + wd3 * listleans[1]
    p206z = sidez + wd3
    point206 = p[p206x, p206y, p206z, rx, ry, rz]
    
    # p203 (middle of turn)
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p203z = sidez + delta
    p203x = sidex + delta * l1delxunit
    p203y = sidey + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description("x", 1, 45 * pi / 180)
    m2 = get_rotation_matrix_from_description("z", 1, heading1)
    m3 = multiply_matrix(m2, m1)
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point203 = p[p203x, p203y, p203z, rx, ry, rz]
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point201=point201, point202=point202, point203=point203, point204=point204, point205=point205, point206=point206)
    return struct2
end

# for a right step corner, calculate the toolpath points for a L (under) then Up and Around weld. 
def calculate_LtUA_step_right(struct1, list1, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 3 # first path first leg
    welddistance2 = 3 # first path second leg
    welddistance3 = 8 # vertical weld distance
    
    # inches
    wd1 = welddistance1 * 25.4 / 1000
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    
    # weld distance is the distance that it will weld. this will make it start at the z height that the user specified
    #wd1 = tcp_pose_top[2] - pointintersect[2] - zup # this will need to change for step corner right
    
    # point bottom (point of intersection of the two chamfers on the bottom)
    xbottom = pointintersect[0] + l1delxunit * leftwallthickmm + l2delxunit * rightwallthickmm
    ybottom = pointintersect[1] + l1delyunit * leftwallthickmm + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    
    # point 1
    x = xbottom + l1delxunit * wd1
    y = ybottom + l1delyunit * wd1
    
    m1 = get_rotation_matrix_from_description("z", 1, heading1)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point1 = p[x, y, z, rx, ry, rz]
    
    # point 2
    point2 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 4
    m1 = get_rotation_matrix_from_description("z", 1, heading3)
    # at this point we would multiply matrices, but there is only one matrix
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point4 = p[xbottom, ybottom, z, rx, ry, rz]
    
    # point 5
    x = xbottom + l2delxunit * wd2
    y = ybottom + l2delyunit * wd2
    point5 = p[x, y, z, rx, ry, rz]
    
    
    # form struct
    struct2 = struct(point1=point1, point2=point2, point4=point4, point5=point5, point_1=point1, point_2=point1, point_3=point1, point_4=point1, point_5=point1)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on left side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_left(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren't any circle motion
    x = pointintersect[0] + l2delxunit * rightwallthickmm
    y = pointintersect[1] + l2delyunit * rightwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading1). should be very similar to the heading for point1 
    # only use the right side taps for circle move related things
    heading3basedh1 = heading1 - pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading3basedh1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the right edge (rx and ry should be 0 because gun is facing up)
    # to convert heading1 into the description, subtract 90 degrees to go parallel  instead of into. subtract 90 degrees to start from y+ instead of x+
    heading1descr = heading1 - pi
    m1 = get_rotation_matrix_from_description("z", 1, heading1descr)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l1delxunit * rod
    p4y = y + l1delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l1delxunit * wd2
    p5y = y + l1delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l1delxunit
    p3y = y + delta * l1delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description("x", -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description("z", 1, heading1descr) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
    p201x = x + l1delxunit * leftwallthickmm + l2delxunit * pushtipforward
    p201y = y + l1delyunit * leftwallthickmm + l2delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description("z", 1, heading3) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l2delxunit
    p202y = p201y + wd3 * l2delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end

# step corner with two seams on bottom face
# vertical seam on right side of corner
# Down Around and Under weld path, then Back Away
# the first path uses backofhole TCP, the second path uses pretend_welder TCP
def calculate_DAaU_step_right(struct1, listleans, rightwallthick, leftwallthick, tcp_pose_top):
    # get the stuff from the struct
    pointintersect = struct1[0]
    heading1 = struct1[1]
    heading2 = struct1[2]
    heading3 = struct1[3]
    l1delxunit = struct1[4]
    l1delyunit = struct1[5]
    l2delxunit = struct1[6]
    l2delyunit = struct1[7]
    
    # FIND THE POINTS ON THE LINES OF THE FIRST TURN PATH
    # find locations 8 inches away from  intersect point
    # CONST
    welddistance1 = 8 # first path first leg (down)
    welddistance2 = 3 # first path second leg (under) # inches
    welddistance3 = 3 # second path (back away) # inches
    
    wd1 = tcp_pose_top[2] - pointintersect[2] # the touchpoint minus the corner
    wd2 = welddistance2 * 25.4 / 1000
    wd3 = welddistance3 * 25.4 / 1000
    leftwallthickmm = leftwallthick * 25.4 / 1000 # in this step corner right, this is distance from left edge
    rightwallthickmm =  rightwallthick * 25.4 / 1000 # in this step corner right, this is distance from right edge
    
    # first, calculate the location of the bottom of the vertical chamfer (where point2 would be if there weren't any circle motion
    x = pointintersect[0] + l1delxunit * leftwallthickmm
    y = pointintersect[1] + l1delyunit * leftwallthickmm
    z = pointintersect[2]
    pointbottomvcham = p[x, y, z, 0, 0, 0]
    
    # calculate the rxryrz for facing the vertical chamfer, with the preheat down
    rxryrz = convert_heading_to_axang_preheatdown(heading1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # next, calculate point1 using the listleans
    point1 = p[x + wd1*listleans[0], y + wd1*listleans[1], z + wd1, rx, ry, rz] # add in the listleans factor to follow the face of the box as we move up
    
    # calculate rxryrz for point2 and point2a (based on heading3). should be very similar to the heading for point1 
    # only use the left side taps for circle move related things
    heading1basedh3 = heading3 + pi/2 # heading1 based on heading3 
    rxryrz = convert_heading_to_axang_preheatdown(heading1basedh3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # the round over distance is the distance from pointbottomvcham to point2 (which will be the same as distance to p4)
    roundoverdistance = 0.05
    rod = roundoverdistance * 25.4 / 1000
    point2 = p[x, y, z + rod, rx, ry, rz] 
    
    # calculate point2a, which is directly above pointbottomvcham (used to straighten weldpath before circlemove)
    straightlength = 1.0 # the moveP blend radius for the circle move was set to 1.0 mm in FloorCorner. we should be more than 2.0mm away from point2
    sld = straightlength * 25.4 / 1000
    point2a = p[x, y, z + sld, rx, ry, rz]
    
    
    # calculate the rxryrz for facing the underneath section, with the preheat facing parallel to the left edge (rx and ry should be 0 because gun is facing up)
    m1 = get_rotation_matrix_from_description("z", 1, heading3)
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point4
    p4x = x + l2delxunit * rod
    p4y = y + l2delyunit * rod
    point4 = p[p4x, p4y, z, rx, ry, rz]
    
    # calculate point5
    p5x = x + l2delxunit * wd2
    p5y = y + l2delyunit * wd2
    point5 = p[p5x, p5y, z, rx, ry, rz]
    
    # calculate point3
    # we know that the angle is exactly 90 degrees
    delta = calc_rod_midpoint_90deg(rod)
    p3z = z + delta
    p3x = x + delta * l2delxunit
    p3y = y + delta * l2delyunit
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description("x", -1, 45 * pi / 180) # rotation 1: 45 degrees forward about x axis
    m2 = get_rotation_matrix_from_description("z", 1, heading3) # rotation 2
    m3 = multiply_matrix(m2, m1) #we rotate m1 first then m2, so we multiply in backwards order: 2 then 1
    rxryrz = convert_matrix_to_axang(m3)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    #todo: calculate trail out point
    
    # calculate back-away (points 201 and 202)
    pushtipforward = 0.006 # 6 millimeters forward. the tip needs to clear the capping wall's angled chamfer to not BONK when getting into position
    p201x = x + l2delxunit * rightwallthickmm + l1delxunit * pushtipforward
    p201y = y + l2delyunit * rightwallthickmm + l1delyunit * pushtipforward
    
    # calculate rxryrz
    m1 = get_rotation_matrix_from_description("z", 1, heading1 - pi) 
    # minus pi/2 for the different start point. minus pi/2 for parallel not perpendicular into
    rxryrz = convert_matrix_to_axang(m1)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    point201 = p[p201x, p201y, z, rx, ry, rz]
    
    # calculate point 202
    p202x = p201x + wd3 * l1delxunit
    p202y = p201y + wd3 * l1delyunit
    point202 = p[p202x, p202y, z, rx, ry, rz]
    
    struct2 = struct(point1=point1, point2a=point2a, point2=point2, point3=point3, point4=point4, point5=point5, point201=point201, point202=point202)
    return struct2
end
