
def main_calculate_sleeve_fillet(p1, p2, p3):
    struct1 = analyze_touchpoints_only_sleeve_fillet(p1, p2, p3)
    struct2 = calculate_points_sleeve_fillet(struct1)
    return struct2
end

# given 3 points at the intersection of the sleeve and the sidewall, this calculates and returns 3 things:
# the centerpoint of the circle on the plane, the normal vector of the plane, and the radius of the circle
# then it returns 4 more things after converting to a vertical circle/plane: heading1 (into the plane), vecn, vecr, vecu
def analyze_touchpoints_only_sleeve_fillet(p1, p2, p3):
    x1 = p1[0]
    y1 = p1[1]
    z1 = p1[2]
    x2 = p2[0]
    y2 = p2[1]
    z2 = p2[2]
    x3 = p3[0]
    y3 = p3[1]
    z3 = p3[2]
    
    # calculate plane
    # calculate ab (1->2) vector
    abvec = [x2-x1, y2-y1, z2-z1]
    # calculate ac (1->3) vector
    acvec = [x3-x1, y3-y1, z3-z1]
    #calculate the plane's normal vector = ab x ac
    
    n = crossproduct(abvec, acvec)
    mag = sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2])
    n = [n[0]/mag, n[1]/mag, n[2]/mag]
    d = n[0] * x1 + n[1] * y1 + n[2] * z1
    
    # find the circle
    # Midpoint of AB:
    mab = [(x1 + x2)/2, (y1 + y2)/2, (z1 + z2)/2]
    # midpoint of ac
    mac = [(x3 + x1)/2, (y3 + y1)/2, (z3 + z1)/2]
    # Get Normal Vectors to AB and AC in the Plane
    # nab (normal to ab) = abvec x n
    nab = crossproduct(abvec, n)
    # nac (normal to ac) = acvec x n
    nac = crossproduct(acvec, n)
    # Define Perpendicular Bisector Lines
    # Each line goes through a midpoint and extends in the direction of the na_
    # we already have the equations of those lines in point vector form with l1 = mab + s * nab, and l2 = mac + t * nac
    # define all the terms so the math is simpler when i have to do math
    mabx = mab[0]
    maby = mab[1]
    mabz = mab[2]
    nabx = nab[0]
    naby = nab[1]
    nabz = nab[2]
    macx = mac[0]
    macy = mac[1]
    macz = mac[2]
    nacx = nac[0]
    nacy = nac[1]
    nacz = nac[2]
    # find the intersection point using the y and z equations
    # maby + s * naby = macy + t * nacy
    # mabz + s * nabz = macz + t * nacz
    # first solve for s and take
    # t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    t = (macz*naby + maby*nabz - mabz*naby - macy*nabz) / (nacy*nabz - naby*nacz)
    # s = (t*nacz + macz - mabz) / nabz
    s = (t*nacz + macz - mabz) / nabz
    # find the point
    # pcenter = mac + t * nac
    pcenterx = macx + t * nacx
    pcentery = macy + t * nacy
    pcenterz = macz + t * nacz
    rxryrz = [0.528, 4.631, 0.258] # demo point of the welder pointing forward into a sleeve
    pcenter = p[pcenterx, pcentery, pcenterz, rxryrz[0], rxryrz[1], rxryrz[2]]
    radius = distance_between(pcenterx, pcentery, pcenterz, x1, y1, z1)
    
    # ------ start calculation of vertical assumption -----
    # assume the plane close to vertical
    # fix it to make it actually vertical
    # calculate the unit vector of up, and the unit vector of right. 
    # calculate the heading from the +x axis to pointing straight into the wall. 
    # the unit vector of up is [0, 0, 1] (because the plane is verticalized) (for easier calculations)
    # first calculate the normal vector INTO the sidewall (make sure x is negative) and make it a unit vector
    vecn = [n[0], n[1], 0] # vector normal
    if vecn[0] > 0:
        vecn = [-n[0], -n[1], 0]
    end
    mag = sqrt(vecn[0]*vecn[0]+vecn[1]*vecn[1])
    vecn = [vecn[0]/mag, vecn[1]/mag, 0]
    # next calculate the right normal vector (the vector IN the plane that goes to the right)
    vecr = [vecn[1], -1*vecn[0], 0]
    vecu = [0, 0, 1] # vector up
    heading1 = convert_uv_to_heading(vecn[0], vecn[1])
    
    
    ret = struct(pcenter=pcenter, planenormalvec=n, radius=radius, heading1=heading1, vecn=vecn, vecr=vecr, vecu=vecu)
    return ret
end

# this function calculates only the four points of the quadrants, for the not real program. 
# these calculations are easier so that's why i'm starting with them first. 
# this assumes a vertical plane
def calculate_points_sleeve_fillet_quadonly(struct1):
    # get the stuff from the struct
    pcenter = struct1[0]
    pcx = pcenter[0]
    pcy = pcenter[1]
    pcz = pcenter[2]
    planenormalvec = struct1[1]
    radius = struct1[2]
    heading1 = struct1[3]
    vecn = struct1[4]
    vecnx = vecn[0]
    vecny = vecn[1]
    vecr = struct1[5]
    vecrx = vecr[0]
    vecry = vecr[1]
    vecu = struct1[6]
    vecuz = vecu[2]
    
    # define cushions (the backofhole can't actually touch the intersection of pipe and wall, it travels a certain distance around it
    cushout = 0.006 # 5mm # the cushion out from the wall
    cusharound = 0.006 # 5mm # the cushion around the sleeve. 
    
    # get the top point (point1)
    # take the center point and move up the radius plus the cushions
    p1x = pcx + vecnx * -1 * cushout
    p1y = pcy + vecny * -1 * cushout
    p1z = pcz + vecuz * radius + vecuz * cusharound
    
    # find rxryrz1
    # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
    m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
    # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # get second point (right) (point2)
    # take the center point and move right the radius plus the cushions
    p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * -1 * cushout
    p2y = pcy + vecry * radius + vecry * cusharound + vecny * -1 * cushout
    p2z = pcz
    
    # find rxryrz2
    # first rotation is 90 degrees about the x- axis
    m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
    # second rotation is About 135 degrees about the z+ axis. This calculation is heading1 – 45 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1 - 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
    
    # get the third point (bottom) (point3)
    p3x = pcx + vecnx * -1 * cushout
    p3y = pcy + vecny * -1 * cushout
    p3z = pcz - vecuz * radius - vecuz * cusharound
    
    # find rxryrz3
    # first rotation is 45 degrees about the y+ axis
    m1 = get_rotation_matrix_from_description("y", 1, 45 * pi / 180)
    # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    # get the fourth point (left) (point4)
    p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * -1 * cushout
    p4y = pcy - vecry * radius - vecry * cusharound + vecny * -1 * cushout
    p4z = pcz
    
    # find rxryrz4
    # first rotation is 90 degrees about the x+ axis
    m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
    # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
    m2 = get_rotation_matrix_from_description("z", 1, heading1 + 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
    
    # return the points
    ret = struct(point1=point1, point2=point2, point3=point3, point4=point4)
    return ret
    
end

# this function calculates the points necessary for the fillet sleeve weld path. 
# this assumes a vertical plane
def calculate_points_sleeve_fillet(struct1):
    # get the stuff from the struct
    pcenter = struct1[0]
    pcx = pcenter[0]
    pcy = pcenter[1]
    pcz = pcenter[2]
    planenormalvec = struct1[1]
    radius = struct1[2]
    heading1 = struct1[3]
    vecn = struct1[4]
    vecnx = vecn[0]
    vecny = vecn[1]
    vecr = struct1[5]
    vecrx = vecr[0]
    vecry = vecr[1]
    vecu = struct1[6]
    vecuz = vecu[2]
    
    # define cushions (the backofhole can't actually touch the intersection of pipe and wall, it travels a certain distance around it
    cushout = 0.006 # 5mm # the cushion out from the wall
    cusharound = 0.004 # 5mm # the cushion around the sleeve. 
    
    # get the top point (point1)
    # take the center point and move up the radius plus the cushions
    p1x = pcx + vecnx * -1 * cushout
    p1y = pcy + vecny * -1 * cushout
    p1z = pcz + vecuz * radius + vecuz * cusharound
    
    # find rxryrz1
    # first rotation is 135 degrees about the y- direction. 90 degrees to get flat. Tip pointing x-, preheat pointing y+. 45 more degrees to get at that above angle
    m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
    # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz1 = convert_matrix_to_axang(m3)
    rx1 = rxryrz1[0]
    ry1 = rxryrz1[1]
    rz1 = rxryrz1[2]
    
    point1 = p[p1x, p1y, p1z, rx1, ry1, rz1]
    
    # get second point (right) (point2)
    # take the center point and move right the radius plus the cushions
    p2x = pcx + vecrx * radius + vecrx * cusharound + vecnx * -1 * cushout
    p2y = pcy + vecry * radius + vecry * cusharound + vecny * -1 * cushout
    p2z = pcz
    
    # find rxryrz2
    # first rotation is 90 degrees about the x- axis
    m1 = get_rotation_matrix_from_description("x", -1, 90 * pi / 180)
    # second rotation is About 135 degrees about the z+ axis. This calculation is heading1 – 45 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1 - 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz2 = convert_matrix_to_axang(m3)
    rx2 = rxryrz2[0]
    ry2 = rxryrz2[1]
    rz2 = rxryrz2[2]
    
    point2 = p[p2x, p2y, p2z, rx2, ry2, rz2]
    
    # get the third point (bottom) (point3)
    p3x = pcx + vecnx * -1 * cushout
    p3y = pcy + vecny * -1 * cushout
    p3z = pcz - vecuz * radius - vecuz * cusharound
    
    # find rxryrz3
    # first rotation is 45 degrees about the y+ axis
    m1 = get_rotation_matrix_from_description("y", 1, 45 * pi / 180)
    # second rotation is About 180 degrees about the z+ axis. This calculation is heading1 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz3 = convert_matrix_to_axang(m3)
    rx3 = rxryrz3[0]
    ry3 = rxryrz3[1]
    rz3 = rxryrz3[2]
    
    point3 = p[p3x, p3y, p3z, rx3, ry3, rz3]
    
    # get the fourth point (left) (point4)
    p4x = pcx - vecrx * radius - vecrx * cusharound + vecnx * -1 * cushout
    p4y = pcy - vecry * radius - vecry * cusharound + vecny * -1 * cushout
    p4z = pcz
    
    # find rxryrz4
    # first rotation is 90 degrees about the x+ axis
    m1 = get_rotation_matrix_from_description("x", 1, 90 * pi / 180)
    # second rotation is heading1 + 45 degrees about the z+ axis. approx 225 degrees ccw
    m2 = get_rotation_matrix_from_description("z", 1, heading1 + 45 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    rxryrz4 = convert_matrix_to_axang(m3)
    rx4 = rxryrz4[0]
    ry4 = rxryrz4[1]
    rz4 = rxryrz4[2]
    
    point4 = p[p4x, p4y, p4z, rx4, ry4, rz4]
    
    # get the angle for the tilt-back at the top (p1)
    m0 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
    m1 = get_rotation_matrix_from_description("y", -1, 135 * pi / 180)
    # second rotation is heading1 – 180 degrees about the z+ axis to get pointing straight into wall. Heading1 should be about 180 degrees
    m2 = get_rotation_matrix_from_description("z", 1, heading1 - 180 * pi/180)
    # combine them by multiplying
    m3 = multiply_matrix(m2, m1)
    m4 = multiply_matrix(m3, m0)
    rxryrz1tilt = convert_matrix_to_axang(m4)
    rx1t = rxryrz1tilt[0]
    ry1t = rxryrz1tilt[1]
    rz1t = rxryrz1tilt[2]
    
    # point 1, but with the tilt back angle
    point1t = p[p1x, p1y, p1z, rx1t, ry1t, rz1t]
    
    # point45 (the point 45 degrees along the path) (has no rxryrz data) (because if we do fixed angle circle move it wont use that anyways, it'l just use the angle from p1t)
    distup = cos(45 * pi/180) * (radius + cusharound)
    distover = sin(45 * pi/180) * (radius + cusharound)
    p45x = pcx + vecrx * distover + vecnx * -1 * cushout
    p45y = pcy + vecry * distover + vecny * -1 * cushout
    p45z = pcz + vecuz * distup
    point45 = p[p45x, p45y, p45z, 0,0,0]
    
    # point22 (22.5 degrees of angle)
    distup = cos(22.5 * pi/180) * (radius + cusharound)
    distover = sin(22.5 * pi/180) * (radius + cusharound)
    p22x = pcx + vecrx * distover + vecnx * -1 * cushout
    p22y = pcy + vecry * distover + vecny * -1 * cushout
    p22z = pcz + vecuz * distup
    point22 = p[p22x, p22y, p22z, 0,0,0]
    
    # return the points
    ret = struct(point1=point1, point2=point2, point3=point3, point4=point4, point1t=point1t, point45=point45, point22=point22)
    return ret
    
end
