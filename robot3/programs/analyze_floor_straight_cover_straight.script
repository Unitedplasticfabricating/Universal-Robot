

def main_calculate_cover_straight(p11, p12, p21, p22, sidewallthick, leftpoint, rightpoint, deepcovercham):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_cover(struct1, sidewallthick, leftpoint, rightpoint, deepcovercham)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# calculates the line of intersection of the sidewall plane (assumed vertical) and the cover plane (assumed perpendicular to sidewall plane)
# returns a struct containing point0 (point on the intersection line, same y as leftpoint) and 3 components of the unit vector left to right and 2 components of the other direction in 2d
def analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint):
    # calculate slope of sidewall in x-y plane
    # get the raw points from the first line
    l1p1x=p11[0]
    l1p1y=p11[1]
    l1p2x=p12[0]
    l1p2y=p12[1]

    # equate the first line in 2d space
    ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)

    # b = y - mx
    bl1 = l1p1y - ml1 * l1p1x
    
    # calculate the cover plane
    # if two planes are perpendicular, then their normal vectors must be perpendicular. 
    # the first planes normal vector is n1, which is taken from the equation of the plane ax + by + cz = d -> <a, b, c>
    # the second plane's normal vector is perpendicular to all vectors contained in the plane
    # p21 to p22 is a vector v contained within plane 2. 
    # n2 is normal to both n1 AND v. to achieve a vector that is normal to both, take the cross product
    
    # plane 1 (y = mx + b) -> (b = -mx +1y +0z)
    n1 = [-1 * ml1, 1, 0]
    
    # v=P2−P1=(x2−x1,y2−y1,z2−z1)
    v = [p21[0]-p22[0], p21[1]-p22[1], p21[2]-p22[2]]
    
    #v n2 = cross product of n1 and v
    n2x = n1[1]*v[2] - n1[2]*v[1]
    n2y = n1[2]*v[0] - n1[0]*v[2]
    n2z = n1[0]*v[1] - n1[1]*v[0]
    n2 = [n2x, n2y, n2z]
    
    # find the d of the second plane
    # n2x * x + n2y * y + n2z * z = d0
    d = n2x * p21[0] + n2y * p21[1] + n2z * p21[2]
    
    # find the intersection line of the two planes
    # find the direction vector of that line by taking the cross product of the normal vector of those two planes
    v3x = n1[1]*n2[2] - n1[2]*n2[1]
    v3y = n1[2]*n2[0] - n1[0]*n2[2]
    v3z = n1[0]*n2[1] - n1[1]*n2[0]
    v3 = [v3x, v3y, v3z]
    
    # normalize the vector so the magnitude is 1
    magnitude2 = v3x * v3x + v3y * v3y + v3z * v3z
    magnitude = sqrt(magnitude2)
    v3xunit = v3x/magnitude
    v3yunit = v3y/magnitude
    v3zunit = v3z/magnitude
    
    # make sure it is going the right way (from left to right). make sure the v3yunit is positive
    if v3yunit < 0:
        v3xunit = v3xunit * -1
        v3yunit = v3yunit * -1
        v3zunit = v3zunit * -1
    end
    
    # next we have to find a point on the line by setting one of the dimensions and solving the system of equations
    # i will pick the y value of the left teach point
    y = leftpoint[1]
    # plane 1: -ml1 * x + 1 * y + 0 * z = bl1
    # -ml1 * x = bl1 - y
    x = (bl1 - y)/ (-1 * ml1)
    # plane 2: d = n2x * x + n2y * y + n2z * z
    # (d - n2x * x - n2y * y) = n2z * z
    z = (d - n2x * x - n2y * y) / n2z
    
    # make point0 into a pose
    point0 = p[x, y, z, 0, 0, 0]
    
    # find heading of main line
    heading1 = convert_uv_to_heading(v3xunit, v3yunit)
    
    # make a unit vector perpendicular to this one in the xy plane pointing x -. will be used to move over the chamfer distance
    ml2 = -1 / ml1
    # y = ml2 * x + unknownB
    # vector = [1, ml2]
    mag2 = 1 + ml2 * ml2
    mag = sqrt(mag2)
    v4xunit = 1 / mag
    v4yunit = ml2 / mag
    # switch is to the x direction is negative
    v4xunit = -1 * v4xunit
    v4yunit = -1 * v4yunit
    
    ret = struct(point0=point0, v3xunit=v3xunit, v3yunit=v3yunit, v3zunit=v3zunit, heading1=heading1, v4xunit=v4xunit, v4yunit=v4yunit)
    return ret
end

def calculate_straight_points_cover(struct1, sidewallthick, leftpointteach, rightpointteach, deepcovercham):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    sidewallthick = sidewallthick
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do, because for maximum reach we want to make the lift pedestal be even with the top of the covers)
    zpi = p0z
    if zpi > 0:
        liftcolumnzneeded = zpi * 1000.0 # the robot uses coordinates in meters, but the lift column uses coordinates in mm
        coverz = 0
    else:
        coverz = zpi
    end
    
    if deepcovercham:
        deepchambumpmm = 0.09 * 25.4/1000 # if there is a deep chamfer on the cover, bump the welder inwards 0.09 more inches. 
    else:
        deepchambumpmm = 0.0
    end
    
    # calculate pointtopvcham
    chamferover = sidewallthick * 25.4 / 1000.0 + deepchambumpmm
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    x = p0x + v4xunit * chamferover
    y = p0y + v4yunit * chamferover
    z = coverz + tiltraise
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180) 
    # second rotation is a 10 degree turn about the x axis (negative direction)
    m2 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = -1 * 25.4 / 1000.0 # move back 1 inch from 
    p1x = x + dist * v3xunit
    p1y = y + dist * v3yunit
    p1z = z + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x + dist * v3xunit
    p2y = y + dist * v3yunit
    p2z = z + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate rxryrz for nontilted
    # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
    m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180) 
    # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
    m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
    m5 = multiply_matrix(m3, m1)
    rxryrz = convert_matrix_to_axang(m5)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    
    # calculate point3 (end of flatten)
    dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x + dist * v3xunit
    p3y = y + dist * v3yunit
    p3z = coverz + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that's what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    
    # calculate point4 (start of unflatten)
    dist = -1.5 * 25.4 / 1000.0 
    p4x = x2 + v3xunit * dist
    p4y = y2 + v3yunit * dist
    p4z = z2 + v3zunit * dist - tiltraise
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = -0.5 * 25.4 / 1000.0 
    p5x = x2 + v3xunit * dist
    p5y = y2 + v3yunit * dist
    p5z = z2 + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = 2 * 25.4 / 1000.0 
    p6x = x2 + v3xunit * dist
    p6y = y2 + v3yunit * dist
    p6z = z2 + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
    
end

def main_calculate_floor_straight(p11, p12, p21, p22, floorthick, leftpoint, rightpoint):
    struct1 = analyze_touchpoints_only_cover_straight(p11, p12, p21, p22, leftpoint)
    struct2 = calculate_straight_points_floor(struct1, floorthick, leftpoint, rightpoint)
    #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
    #struct3 = check_validity_left(struct1, struct2)
    return struct2
    
end

# the path for welding a floor straight weld with v chisels on both sides. 
# start at the right side and move left. 
def calculate_straight_points_floor(struct1, floorthick, leftpointteach, rightpointteach):
    # get the stuff
    point0 = struct1[0]
    p0x = point0[0]
    p0y = point0[1]
    p0z = point0[2]
    v3xunit = struct1[1]
    v3yunit = struct1[2]
    v3zunit = struct1[3]
    heading1 = struct1[4]
    v4xunit = struct1[5]
    v4yunit = struct1[6]
    lpy = leftpointteach[1]
    rpy = rightpointteach[1]
    
    # first, check if we need a lift column raise
    # (we do not, because the floors are low)
    zpi = p0z
    floorz = zpi
    
    # calculate pointtopvcham (left point) (tilted and tiltraised)
    chamferup = floorthick * 25.4 / 1000.0
    tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
    # on this one, move the tiltraise distance sideways (towards robot) and the chamferover distance up
    x = p0x + v4xunit * tiltraise * -1
    y = p0y + v4yunit * tiltraise * -1
    z = floorz + chamferup
    
    # calculate rxryrz for tilted back
    # 3 rotations to make this happen. 
    # start point is straight up with the preheat pointed in the +y direction. 
    # first rotation is 90 degrees about y axis. positive direction. gun is now pointing in the x+ direction with preheat facing +y direction
    m1 = get_rotation_matrix_from_description("y", 1, 90 * pi / 180) 
    # second rotation is about 180 degrees about the z axis. heading1 plus 90 degrees. gun is now pointing directly into the sidewall
    m2 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
    # third rotation is 10 degrees about the z axis. gun is now tilted back 10 degrees from the sidewall
    m3 = get_rotation_matrix_from_description("z", 1, 10 * pi / 180)
    # combine them by multiplying m3 * m2 * m1
    # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
    m4 = multiply_matrix(m2, m1)
    m5 = multiply_matrix(m3, m4)
    rxryrzt = convert_matrix_to_axang(m5)
    rxt = rxryrzt[0]
    ryt = rxryrzt[1]
    rzt = rxryrzt[2]
    # the non tilted angle is just m4
    rxryrz = convert_matrix_to_axang(m4)
    rx = rxryrz[0]
    ry = rxryrz[1]
    rz = rxryrz[2]
    pointtopvcham = p[x, y, z, rxt, ryt, rzt]
    
    # calculate distance between leftpoint and rightpoint
    # we have the y distance. we need to find the total distance. 
    # the unit vector (v3) should have a magnitude of 1. that's what analyze_touchpoints_only_cover_straight() calculated.
    # so the total distance is y distance * 1 / v3yunit
    ydist = rpy - lpy
    totdist = ydist / v3yunit
    
    # calculate pointtopvcham2 (right point) (tilted and tiltraised)
    x2 = x + v3xunit * totdist
    y2 = y + v3yunit * totdist
    z2 = z + v3zunit * totdist
    pointtopvcham2 = p[x2, y2, z2, rxt, ryt, rzt]
    
    # calculate point1 (preheat)
    dist = 1 * 25.4 / 1000.0 # move back 1 inch from ptvc2 (in this case back means positive)
    p1x = x2 + dist * v3xunit
    p1y = y2 + dist * v3yunit
    p1z = z2 + dist * v3zunit
    point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
    
    # calculate point2 (start of flatten)
    dist = -0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
    p2x = x2 + dist * v3xunit
    p2y = y2 + dist * v3yunit
    p2z = z2 + dist * v3zunit
    point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
    
    # calculate point3 (end of flatten)
    dist = -1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
    p3x = x2 + dist * v3xunit + tiltraise * v4xunit
    p3y = y2 + dist * v3yunit + tiltraise * v4yunit
    p3z = z2 + dist * v3zunit
    point3 = p[p3x, p3y, p3z, rx, ry, rz]
    
    # calculate point4 (start of unflatten)
    dist = 1.5 * 25.4 / 1000.0 
    p4x = x + v3xunit * dist + tiltraise * v4xunit
    p4y = y + v3yunit * dist + tiltraise * v4yunit
    p4z = z + v3zunit * dist
    point4 = p[p4x, p4y, p4z, rx, ry, rz]
    
    # calculate point5 (end of unflatten)
    dist = 0.5 * 25.4 / 1000.0 
    p5x = x + v3xunit * dist
    p5y = y + v3yunit * dist
    p5z = z + v3zunit * dist
    point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
    
    # calculate point6 (end of smear)
    dist = -2 * 25.4 / 1000.0 
    p6x = x + v3xunit * dist
    p6y = y + v3yunit * dist
    p6z = z + v3zunit * dist
    point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
    
    # return struct
    ret = struct(pointtopvcham=pointtopvcham, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
    return ret
    
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_cover(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points (the rxryrz are given in pretend_welder_top coordinates. they match pure rotations of 90 degrees)
    ph1 = p[lpx + d0, lpy, lpz - d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz - d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d2, lpy, lpz + d0, 2.221, -2.221, 0] # left top approach
    ph4 = p[rpx - d2, rpy, rpz + d0, 2.221, -2.221, 0] # right top approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret)
    return ret
end

# this function determines the starting touchpoints for homing in on cover straight geometry
# includes two side points to determine the sidewall plane (assumed vertical) and two top points to determine top plane (assumed perpendicular to sidewall plane)
def get_straight_homing_pathpoints_floor(leftpoint, rightpoint):
    # get the teach position points
    lpx = leftpoint[0]
    lpy = leftpoint[1]
    lpz = leftpoint[2]
    rpx = rightpoint[0]
    rpy = rightpoint[1]
    rpz = rightpoint[2]
    
    # specify the distances from
    d0 = 0.05 # how far from the planes to approach from
    d1 = 0.03 # how far from the teach point to home from, when there is no chamfer to avoid
    d2 = 0.06 # how far from the teach point to home from, when there is a chamfer to avoid
    
    # calculate the points
    ph1 = p[lpx + d0, lpy, lpz + d1, 1.209, -1.209, -1.209] # left side approach
    ph2 = p[rpx + d0, rpy, rpz + d1, 1.209, -1.209, -1.209] # right side approach
    ph3 = p[lpx - d1, lpy, lpz - d0, 0, 0, 0] # left bottom approach
    ph4 = p[rpx - d1, rpy, rpz - d0, 0, 0, 0] # right bottom approach
    
    ret = struct(ph1=ph1, ph2=ph2, ph3=ph3, ph4=ph4)
    is_robot_at_reachable_spot(leftpoint, ret, 4)
    return ret
end
