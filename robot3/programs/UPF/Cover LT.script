def Cover_LT():
  global _hidden_verificationVariable=0
  set_gravity([0.0, 0.0, 9.82])
  set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  set_target_payload(10.800000, [-0.001000, -0.053000, 0.068000], [0.081228, 0.081228, 0.081228, 0.000000, 0.000000, 0.000000])
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  global robot_number=3
  global Point_1=p[0.0,0.0,0.0,0.0,0.0,0.0]
  global Point_2=p[0.0,0.0,0.0,0.0,0.0,0.0]
  # begin: URCap Installation Node
  #   Source: UR Connect, 1.13.79, Universal Robots
  #   Type: UR Connect
  myurRPC = rpc_factory("xmlrpc","http://127.0.0.1:40474")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  def waitForResponse(expected_response_vention, cname_vention):
  response_vention = socket_read_string(cname_vention,timeout=15)
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  end
  def sendString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringNAck(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while(response_vention != expected_response_vention and response_vention != "nAck"):
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received",blocking=True)
  end
  end
  sleep(0.01)
  sync()
  end
  def sendStringWithTimeout(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=10)
  if(response_vention == "nAck"):
  popup("nAck received"+string_vention)
  end
  sleep(0.01)
  sync()
  end
  def pollString(string_vention, expected_response_vention, cname_vention):
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(1)
  socket_send_string(str_cat(string_vention,";"), cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def sendVariable(var_vention, data_vention, expected_response_vention, cname_vention):
  socket_set_var(var_vention, data_vention, cname_vention)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  while response_vention != expected_response_vention:
  sleep(0.01)
  response_vention = socket_read_string(cname_vention,timeout=15)
  if(response_vention == "nAck"):
  popup("nAck received")
  end
  end
  sleep(0.01)
  sync()
  end
  def intToString(integer_vention,cname_vention):
  stringFix=""
  multiplier_vention123=1
  if integer_vention<0:
  stringFix="-"
  multiplier_vention123=-1
  end
  socket_set_var("GetString",integer_vention*multiplier_vention123,cname_vention)
  string_vention=""
  while string_vention=="":
  sleep(0.01)
  string_vention=socket_read_string(cname_vention,timeout=15)
  end
  sleep(0.01)
  sync()
  string_vention=stringFix+string_vention
  return string_vention
  end
  string_vention=""
  isVentionMovementBusy = False
  isVentionParallelMovementSendingScript = False
  ventionThreadHandle = 1
  isVentionMovementBusyMachineMotion1 = False
  isVentionParallelMovementSendingScriptMachineMotion1 = False
  socket_vention = socket_open("192.168.3.52", 9999, "MachineMotion1")
  if socket_vention==False:
  popup("Check configuration, can't connect to MachineMotion")
  end
  waitForResponse("MachineMotion connection established", "MachineMotion1")
  sendString("isReady", "MachineMotion isReady = true", "MachineMotion1")
  sendStringWithTimeout("setURCapVersion2", "setURCapVersion loaded", "MachineMotion1")
  sendString("SET speed_v2 1000000", "Ack", "MachineMotion1")
  sendString("SET acceleration_v2 100000", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_microsteps_config 8", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_mechanical_gain_config_v2 150000.0", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_direction_config 1", "Ack", "MachineMotion1")
  sendString("SET de_axis_1_type_config Custom Actuator ", "Ack", "MachineMotion1")
  sendString("de_axis_1_config_exec", "Ack", "MachineMotion1")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: WireTank Serial, 4.9.0, WireTank, LLC
  #   Type: WireTank Serial
  WTSerialBridge = rpc_factory("xmlrpc","http://127.0.0.1:40511/RPC2")
  # end: URCap Installation Node
  step_count_3c557b13_f5ec_48c2_a97a_cfeb7db83f57 = 0.0
  thread Step_Counter_Thread_f98c78a1_2374_42a1_a0d7_796e81b9e6bc():
    while (True):
      step_count_3c557b13_f5ec_48c2_a97a_cfeb7db83f57 = step_count_3c557b13_f5ec_48c2_a97a_cfeb7db83f57 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_f98c78a1_2374_42a1_a0d7_796e81b9e6bc()
  global free_dr_already=  False  
  global freedrive_m_var=  False  
  global Waypoint_76_p=p[.886939072471, .356263001241, .442999104957, 2.316306590719, 2.057646408592, .074101958719]
  global Waypoint_76_q=[-3.2647881984118814, -1.2522049299371645, 1.5824044773896437, 0.9175786249801816, -0.008369636028316307, -1.3112608249927966]
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global Waypoint_46_p=p[.894107867742, .351078231601, .354456446052, 2.326366960603, 2.052510258679, .057358671808]
  global Waypoint_46_q=[-3.266944233571188, -1.1744955343059083, 1.6532734076129358, 1.003952904338501, -0.002457443867818654, -1.5361955801593226]
  global Waypoint_8_p=p[-.262598515057, -.117910587405, .443766749060, .115341915577, 3.114598670938, .265717910023]
  global Waypoint_8_q=[0.09593799853304574, -2.478920735206711, 2.2568664886291003, 0.22882056286890418, 1.7417236956390985, -0.16791597406715475]
  global Waypoint_9_p=p[.397354147848, .356263001249, .319808682466, 2.316306590727, 2.057646408591, .074101958728]
  global Waypoint_9_q=[-3.461131359466023, -2.0623222441504643, 2.3291806643499107, -0.2192273969510623, -0.20100694585182488, -0.11040669743862352]
  global Waypoint_40_p=p[.360688403366, .270119715397, .646144746546, .057805349154, 2.125995180379, 2.134053153683]
  global Waypoint_40_q=[-3.4579489866839808, -2.0569035015501917, 2.3265796343432825, -0.22706706941638188, -0.1993501822101038, -0.10534793535341436]
  global Waypoint_1_p=p[-.565561213657, -.088282455918, .748933518927, .347029359730, 3.101499736541, -.038451502133]
  global Waypoint_1_q=[-0.20992943689837773, -1.9784871065419498, 2.1181745704300012, 4.596341596371087, -1.5479914230732055, -1.5583000940644602]
  global Waypoint_6_p=p[.397354147848, .356263001249, .319808682466, 2.316306590727, 2.057646408591, .074101958728]
  global Waypoint_6_q=[-3.461131359466087, -2.062322244150579, 2.329180664349958, -0.21922739695102145, -0.20100694585188528, -0.11040669743860754]
  global Waypoint_7_p=p[-.262598515057, -.117910587405, .443766749060, .115341915577, 3.114598670938, .265717910023]
  global Waypoint_7_q=[0.09593799853302087, -2.4789207352067226, 2.256866488629104, 0.22882056286890795, 1.7417236956390747, -0.16791597406715297]
  global Waypoint_4_p=p[-.433664641517, -.217871332139, .358001604360, -1.895549759225, 2.498965706218, .036945701764]
  global Waypoint_4_q=[-0.6685436407672327, -2.098424097100729, 2.2798998991595667, -0.2272131007960816, -0.39710790315736944, 0.02628905698657036]
  global r1_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r1_ek_oldhome_q=[-3.457949940358297, -2.056894441644186, 2.32658034959902, -0.2270551484874268, -0.19935208955873662, -0.10533696809877569]
  global r1_ek_extrude_p=p[.454852104155, .405448828659, .064015413765, 2.316807606413, 2.051392071696, .076664825947]
  global r1_ek_extrude_q=[-3.274653975163595, -1.5604325172356148, 2.467809502278463, -0.34438879907641606, -0.014281574879781544, -0.6303489843951624]
  global r1_ek_front_p=p[.439064809878, .405452261046, .065996139932, 2.316843937268, 2.051427632497, .076607106393]
  global r1_ek_front_q=[-3.280560557042257, -1.6287623844542445, 2.502561871205465, -0.47416289270434575, -0.019731823598043263, -0.4669149557696741]
  global r1_ek_middle_p=p[.419010105608, .404850828431, .065994665459, 2.309574128677, 2.044678176343, .089098333896]
  global r1_ek_middle_q=[-3.290863100682394, -1.70143522838735, 2.548208538685934, -0.589385525589325, -0.029501263295308888, -0.3372734228717249]
  global r1_ek_middle2_p=p[.417011768852, .405435328663, .065002627117, 2.316867113472, 2.051334925313, .076628493429]
  global r1_ek_middle2_q=[-3.289830032979147, -1.6934038601317347, 2.5445857683764856, -0.579618052845337, -0.028589550648824513, -0.33885270753969365]
  global r1_ek_bottom_p=p[.413071667620, .405431286494, .067999701073, 2.316819721954, 2.051304037200, .076688572349]
  global r1_ek_bottom_q=[-3.2916205565081995, -1.708447118798727, 2.5485368410693567, -0.5849895042232056, -0.03033763567079717, -0.32244998613466436]
  global r1_ek_end_p=p[.389998638281, .405443674081, .068004818811, 2.316851991921, 2.051367741778, .076612018685]
  global r1_ek_end_q=[-3.3030064741717737, -1.7640062771239222, 2.5831297079669397, -0.63420523822818, -0.04154044786562139, -0.2521465460406702]
  global r2_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r2_ek_oldhome_q=[-3.461132842686933, -2.062320779349874, 2.32916033290004, -0.21924456446492258, -0.20097883707844666, -0.11039879152527199]
  global r2_ek_extrude_p=p[.612885745678, .429305279732, .100477107124, 2.149994969793, 2.225764025207, .087353352584]
  global r2_ek_extrude_q=[-3.199475796455825, -1.4862854517875999, 2.263543898005424, -0.6928175084157413, -0.09183293866530295, -0.15653548683830643]
  global r2_ek_front_p=p[.556405415915, .429305279815, .076984362723, -2.170411249256, -2.268200695165, -.015853660170]
  global r2_ek_front_q=[-3.2029012478485694, -1.4943971905029905, 2.3176866046272355, -0.727203417516419, -0.10461513056100813, -0.1013922369747533]
  global r2_ek_middle_p=p[.550033970532, .429305279917, .076253920653, -2.170411249261, -2.268200695170, -.015853660159]
  global r2_ek_middle_q=[-3.2036200175167613, -1.5006788185274456, 2.326226188945654, -0.730095076239345, -0.10533288811000929, -0.10075548926859312]
  global r2_ek_bottom_p=p[.546594660555, .429305280025, .080868477599, -2.170411249265, -2.268200695174, -.015853660149]
  global r2_ek_bottom_q=[-3.204010221105431, -1.5099366263094405, 2.3272215014458872, -0.722096275899732, -0.10572512264357048, -0.10049057923478166]
  global r2_ek_end_p=p[.537335106646, .429305280055, .080868477459, -2.170411249266, -2.268200695175, -.015853660146]
  global r2_ek_end_q=[-3.205098875769389, -1.5204959829395506, 2.3387656715508855, -0.724001524008818, -0.10681294496314919, -0.09956563917089412]
  global r3_ek_oldhome_p=p[.397385850131, .356252441346, .369809999696, 2.316320575836, 2.057576093691, .074125563417]
  global r3_ek_oldhome_q=[-3.4600108097540825, -2.084533794186367, 2.2686976909438377, -0.1444297831854957, -0.20178034518575938, -0.10248789488416588]
  global r3_ek_extrude_p=p[.612883684377, .429310301838, .149999999683, 2.149962295817, 2.225777492182, .087374550826]
  global r3_ek_extrude_q=[-3.1980123446153748, -1.538400201434774, 2.229744902146236, -0.6115506790497731, -0.09278008251792791, -0.15193191663383665]
  global r3_ek_front_p=p[.585401951131, .429310301785, .130897209292, -2.141141259038, -2.278798102914, .003494663752]
  global r3_ek_front_q=[-3.1977950186249755, -1.509019432206986, 2.231012808207609, -0.6356372563310302, -0.12004377417080114, -0.07413604338809954]
  global r3_ek_middle_p=p[.557524015151, .429310301916, .129293833058, -2.141141259041, -2.278798102920, .003494663762]
  global r3_ek_middle_q=[-3.2005729995755914, -1.5395326608130926, 2.2666642679419926, -0.6429191168126112, -0.12287173078895908, -0.07197890791210071]
  global r3_ek_bottom_p=p[.555663640729, .429310301939, .134686156380, -2.141141259041, -2.278798102921, .003494663764]
  global r3_ek_bottom_q=[-3.2007742562633155, -1.5471114650120104, 2.2646959380089817, -0.6335979607235984, -0.12306896366210651, -0.07175138602093867]
  global r3_ek_end_p=p[.526089168975, .429310301982, .134686156136, -2.141141259042, -2.278798102923, .003494663767]
  global r3_ek_end_q=[-3.2040748332776694, -1.5824472969401349, 2.3003171479555093, -0.636326927528188, -0.12641724847094338, -0.06929140185129778]
  global r4_ek_oldhome_p=p[.397380247322, .356253634699, .319820846021, 2.316316320871, 2.057594704604, .074118471609]
  global r4_ek_oldhome_q=[-3.4680860338785493, -2.070376223306912, 2.3329367157510497, -0.22828162349163783, -0.20619604348947362, -0.09694130604598783]
  global r4_ek_extrude_p=p[.458670548589, .429305279741, .125141489362, 2.149994969793, 2.225764025207, .087353352584]
  global r4_ek_extrude_q=[-3.224306558956634, -1.7135315940479465, 2.43410270276974, -0.6768839938806144, -0.1154143142053492, -0.11562209601533713]
  global r4_ek_front_p=p[.420084046436, .429305279533, .122370065986, -2.206701899775, -2.177374452500, .052747240372]
  global r4_ek_front_q=[-3.2223885287117087, -1.7265329174617632, 2.4434355314143925, -0.6644243149558609, -0.06512925128431313, -0.01659929377642566]
  global r4_ek_middle_p=p[.385663706386, .429305279588, .119862350556, -2.206701899778, -2.177374452500, .052747240377]
  global r4_ek_middle_q=[-3.2295441306515738, -1.774240686665987, 2.4822688267544946, -0.6583601229072489, -0.07232201786773373, -0.0137735297523216]
  global r4_ek_bottom_p=p[.385663706260, .429305279599, .122809894660, -2.206701899778, -2.177374452501, .052747240377]
  global r4_ek_bottom_q=[-3.2295577467539287, -1.7778480193330992, 2.4794176409730713, -0.6518633442593682, -0.07233077879629679, -0.013811892538432069]
  global r4_ek_end_p=p[.366757227289, .429305279628, .122809894538, -2.206701899780, -2.177374452501, .052747240380]
  global r4_ek_end_q=[-3.2341047638544715, -1.8072551968371293, 2.4987903200913473, -0.6435011221874376, -0.07689850609233773, -0.01212997029934737]
  global Waypoint_3_p=p[.397385850131, .356252441346, .369809999696, 2.316320575836, 2.057576093691, .074125563417]
  global Waypoint_3_q=[-3.4607526847793646, -2.0810779994496613, 2.2670702358413193, -0.1463790324724492, -0.20252143988217952, -0.10236457463665882]
  global Waypoint_2_p=p[-.563855321858, -.113244573292, .483266449482, -.334089792396, -3.123383559358, -.000763175429]
  global Waypoint_2_q=[-0.1909317618442481, -1.986253760572688, 2.1264441062309594, 4.572573528963279, -1.5709593895431304, -1.548760198301764]
  def Test_Teach_Cover_LT():
    $ 170 "Test_Teach_Cover_LT" "noBreak"
    $ 171 "Set"
    set_tcp(p[0.0018451128039461973,-0.015648957570072047,0.2843339884457262,0.0,0.0,0.0])
    $ 175 "MoveJ"
    $ 176 "Waypoint_40" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_40_p, qnear=Waypoint_40_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 177 "'above waypoint is home'"
    # 'above waypoint is home'
    $ 179 "Waypoint_1" "breakAfter"
    set_tcp(p[0.0,0.0,0.019,0.0,0.0,0.0])
    movej(get_inverse_kin(Waypoint_1_p, qnear=Waypoint_1_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 180 "Set"
    set_tcp(p[0.0018451128039461973,-0.015648957570072047,0.2843339884457262,0.0,0.0,0.0])
    $ 181 "freedrive_m_var≔ False "
    global freedrive_m_var=  False  
    $ 182 "freedrive_m_var≔ True "
    global freedrive_m_var=  True  
    $ 183 "Popup: Move the TCP to the left side of the weld (very center of groove), then click 'Continue'"
    popup("Move the TCP to the left side of the weld (very center of groove), then click 'Continue'", "Message", False, False, blocking=True)
    $ 184 "tcp_pose_left≔get_actual_tcp_pose()"
    global tcp_pose_left= get_actual_tcp_pose ()
    $ 185 "Popup: Move the TCP to the right side of the weld (very center of groove), then click 'Continue'"
    popup("Move the TCP to the right side of the weld (very center of groove), then click 'Continue'", "Message", False, False, blocking=True)
    $ 186 "tcp_pose_right≔get_actual_tcp_pose()"
    global tcp_pose_right= get_actual_tcp_pose ()
    $ 187 "freedrive_m_var≔ False "
    global freedrive_m_var=  False  
    $ 188 "Wait: 0.25"
    sleep(0.25)
    $ 189 "sync()"
    sync()
  end
  def move_path_cover_lt():
    $ 190 "move_path_cover_lt" "noBreak"
    $ 191 "p1≔pathturn[1]"
    global p1=pathturn[1]
    $ 192 "p2≔pathturn[2]"
    global p2=pathturn[2]
    $ 193 "p3≔pathturn[3]"
    global p3=pathturn[3]
    $ 194 "p4≔pathturn[4]"
    global p4=pathturn[4]
    $ 195 "p5≔pathturn[5]"
    global p5=pathturn[5]
    $ 196 "p6≔pathturn[6]"
    global p6=pathturn[6]
    $ 197 "pa1≔p[p1[0],p1[1],p1[2]+0.05,p1[3],p1[4],p1[5]]"
    global pa1=p[p1[0],p1[1],p1[2]+0.05,p1[3],p1[4],p1[5]]
    $ 198 "pret≔p[p6[0],p6[1],p6[2]+0.05,p6[3],p6[4],p6[5]]"
    global pret=p[p6[0],p6[1],p6[2]+0.05,p6[3],p6[4],p6[5]]
    $ 199 "'go to preheat'"
    # 'go to preheat'
    $ 200 "Set"
    set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
    $ 201 "MoveJ"
    $ 202 "pa1" "breakAfter"
    movej(pa1, a=1.3962634015954636, v=1.0471975511965976)
    $ 203 "MoveL"
    $ 204 "p1" "breakAfter"
    movel(p1, a=0.05, v=0.05)
    $ 205 "Wait: 4.0"
    sleep(4.0)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 206 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 207 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 208 "Wait: 1.0"
    sleep(1.0)
    $ 209 "MoveL"
    $ 210 "p2" "breakAfter"
    movel(p2, a=1.2, v=0.009)
    $ 211 "p3" "breakAfter"
    movel(p3, a=1.2, v=0.009)
    $ 212 "p4" "breakAfter"
    movel(p4, a=1.2, v=0.009)
    $ 213 "p5" "breakAfter"
    movel(p5, a=1.2, v=0.009)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 220 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 221 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 222 "MoveL"
    $ 223 "p6" "breakAfter"
    movel(p6, a=1.2, v=0.01)
    $ 224 "Wait: 1.0"
    sleep(1.0)
    $ 225 "MoveL"
    $ 226 "pret" "breakAfter"
    movel(pret, a=0.05, v=0.05)
  end
  def align_for_cover_straight():
    $ 227 "align_for_cover_straight" "noBreak"
    $ 233 "MoveJ"
    $ 234 "Waypoint_6" "breakAfter"
    movej(get_inverse_kin(Waypoint_6_p, qnear=Waypoint_6_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 235 "Waypoint_7" "breakAfter"
    movej(get_inverse_kin(Waypoint_7_p, qnear=Waypoint_7_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 236 "If 1≟2"
    if (1 == 2):
      $ 237 "MoveJ"
      $ 238 "Waypoint_4" "breakAfter"
      movej(get_inverse_kin(Waypoint_4_p, qnear=Waypoint_4_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 239 "'this is for xvcut'"
      # 'this is for xvcut'
    end
  end
  def extrude_knife3():
    $ 240 "extrude_knife3" "noBreak"
    $ 241 "pre program stuff"
    $ 242 "Set"
    set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
    $ 243 "ek_sp≔get_actual_tcp_pose()"
    global ek_sp= get_actual_tcp_pose ()
    $ 244 "MoveL"
    $ 245 "ek_sp" "breakAfter"
    movel(ek_sp, a=1.2, v=0.005)
    $ 246 "'list possible points'"
    # 'list possible points'
    $ 247 "robot 1 moves"
    $ 248 "If 1≟2"
    if (1 == 2):
      $ 249 "MoveJ"
      $ 250 "r1_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r1_ek_oldhome_p, qnear=r1_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 251 "r1_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r1_ek_extrude_p, qnear=r1_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 252 "r1_ek_front" "breakAfter"
      movej(get_inverse_kin(r1_ek_front_p, qnear=r1_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 253 "r1_ek_middle" "breakAfter"
      movej(get_inverse_kin(r1_ek_middle_p, qnear=r1_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 254 "r1_ek_middle2" "breakAfter"
      movej(get_inverse_kin(r1_ek_middle2_p, qnear=r1_ek_middle2_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 255 "r1_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r1_ek_bottom_p, qnear=r1_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 256 "r1_ek_end" "breakAfter"
      movej(get_inverse_kin(r1_ek_end_p, qnear=r1_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 257 "robot 2 moves"
    $ 258 "If 1≟2"
    if (1 == 2):
      $ 259 "MoveJ"
      $ 260 "r2_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r2_ek_oldhome_p, qnear=r2_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 262 "r2_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r2_ek_extrude_p, qnear=r2_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 263 "r2_ek_front" "breakAfter"
      movej(get_inverse_kin(r2_ek_front_p, qnear=r2_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 264 "r2_ek_middle" "breakAfter"
      movej(get_inverse_kin(r2_ek_middle_p, qnear=r2_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 265 "r2_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r2_ek_bottom_p, qnear=r2_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 266 "r2_ek_end" "breakAfter"
      movej(get_inverse_kin(r2_ek_end_p, qnear=r2_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 267 "robot 3 moves"
    $ 268 "If 1≟2"
    if (1 == 2):
      $ 269 "MoveJ"
      $ 270 "r3_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r3_ek_oldhome_p, qnear=r3_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 271 "r3_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r3_ek_extrude_p, qnear=r3_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 272 "r3_ek_front" "breakAfter"
      movej(get_inverse_kin(r3_ek_front_p, qnear=r3_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 273 "r3_ek_middle" "breakAfter"
      movej(get_inverse_kin(r3_ek_middle_p, qnear=r3_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 274 "r3_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r3_ek_bottom_p, qnear=r3_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 275 "r3_ek_end" "breakAfter"
      movej(get_inverse_kin(r3_ek_end_p, qnear=r3_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 276 "robot 4 moves"
    $ 277 "If 1≟2"
    if (1 == 2):
      $ 278 "MoveJ"
      $ 279 "r4_ek_oldhome" "breakAfter"
      movej(get_inverse_kin(r4_ek_oldhome_p, qnear=r4_ek_oldhome_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 280 "r4_ek_extrude" "breakAfter"
      movej(get_inverse_kin(r4_ek_extrude_p, qnear=r4_ek_extrude_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 281 "r4_ek_front" "breakAfter"
      movej(get_inverse_kin(r4_ek_front_p, qnear=r4_ek_front_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 282 "r4_ek_middle" "breakAfter"
      movej(get_inverse_kin(r4_ek_middle_p, qnear=r4_ek_middle_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 283 "r4_ek_bottom" "breakAfter"
      movej(get_inverse_kin(r4_ek_bottom_p, qnear=r4_ek_bottom_q), a=1.3962634015954636, v=1.0471975511965976)
      $ 284 "r4_ek_end" "breakAfter"
      movej(get_inverse_kin(r4_ek_end_p, qnear=r4_ek_end_q), a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 285 "'detemine correct points for which robot'"
    # 'detemine correct points for which robot'
    $ 286 "If robot_number≟1"
    if (robot_number == 1):
      $ 287 "robot1 positions"
      $ 288 "ek_oldhome≔r1_ek_oldhome_p"
      global ek_oldhome=r1_ek_oldhome_p
      $ 289 "ek_extrude≔r1_ek_extrude_p"
      global ek_extrude=r1_ek_extrude_p
      $ 290 "ek_front≔r1_ek_front_p"
      global ek_front=r1_ek_front_p
      $ 291 "ek_middle≔r1_ek_middle_p"
      global ek_middle=r1_ek_middle_p
      $ 292 "ek_middle2≔r1_ek_middle2_p"
      global ek_middle2=r1_ek_middle2_p
      $ 293 "ek_bottom≔r1_ek_bottom_p"
      global ek_bottom=r1_ek_bottom_p
      $ 294 "ek_end≔r1_ek_end_q"
      global ek_end=r1_ek_end_q
    else:
      $ 295 "ElseIf robot_number≟2"
      if (robot_number == 2):
        $ 296 "robot2 positions"
        $ 297 "ek_oldhome≔r2_ek_oldhome_p"
        global ek_oldhome=r2_ek_oldhome_p
        $ 298 "ek_extrude≔r2_ek_extrude_p"
        global ek_extrude=r2_ek_extrude_p
        $ 299 "ek_front≔r2_ek_front_p"
        global ek_front=r2_ek_front_p
        $ 300 "ek_middle≔r2_ek_middle_p"
        global ek_middle=r2_ek_middle_p
        $ 301 "ek_middle2≔r2_ek_middle_p"
        global ek_middle2=r2_ek_middle_p
        $ 302 "ek_bottom≔r2_ek_bottom_p"
        global ek_bottom=r2_ek_bottom_p
        $ 303 "ek_end≔r2_ek_end_q"
        global ek_end=r2_ek_end_q
      else:
        $ 304 "ElseIf robot_number≟3"
        if (robot_number == 3):
          $ 305 "robot3 positions"
          $ 306 "ek_oldhome≔r3_ek_oldhome_p"
          global ek_oldhome=r3_ek_oldhome_p
          $ 307 "ek_extrude≔r3_ek_extrude_p"
          global ek_extrude=r3_ek_extrude_p
          $ 308 "ek_front≔r3_ek_front_p"
          global ek_front=r3_ek_front_p
          $ 309 "ek_middle≔r3_ek_middle_p"
          global ek_middle=r3_ek_middle_p
          $ 310 "ek_middle2≔r3_ek_middle_p"
          global ek_middle2=r3_ek_middle_p
          $ 311 "ek_bottom≔r3_ek_bottom_p"
          global ek_bottom=r3_ek_bottom_p
          $ 312 "ek_end≔r3_ek_end_q"
          global ek_end=r3_ek_end_q
        else:
          $ 313 "ElseIf robot_number≟4"
          if (robot_number == 4):
            $ 314 "robot4 positions"
            $ 315 "ek_oldhome≔r4_ek_oldhome_p"
            global ek_oldhome=r4_ek_oldhome_p
            $ 316 "ek_extrude≔r4_ek_extrude_p"
            global ek_extrude=r4_ek_extrude_p
            $ 317 "ek_front≔r4_ek_front_p"
            global ek_front=r4_ek_front_p
            $ 318 "ek_middle≔r4_ek_middle_p"
            global ek_middle=r4_ek_middle_p
            $ 319 "ek_middle2≔r4_ek_middle_p"
            global ek_middle2=r4_ek_middle_p
            $ 320 "ek_bottom≔r4_ek_bottom_p"
            global ek_bottom=r4_ek_bottom_p
            $ 321 "ek_end≔r4_ek_end_q"
            global ek_end=r4_ek_end_q
          end
        end
      end
    end
    $ 322 "'start of program'"
    # 'start of program'
    $ 324 "Set"
    set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
    $ 325 "MoveJ"
    $ 326 "Waypoint_3" "breakAfter"
    movej(Waypoint_3_q, a=1.3962634015954636, v=1.0471975511965976)
    $ 327 "'joint angles for fixed position'"
    # 'joint angles for fixed position'
    $ 328 "MoveJ"
    $ 330 "ek_oldhome" "breakAfter"
    movej(ek_oldhome, a=1.3962634015954636, v=1.0471975511965976)
    $ 331 "'above waypoint is home'"
    # 'above waypoint is home'
    $ 332 "'move above bucket'"
    # 'move above bucket'
    $ 333 "MoveJ"
    $ 335 "ek_extrude" "breakAfter"
    movej(ek_extrude, a=1.3962634015954636, v=1.0471975511965976)
    $ 336 "'extrude out a foot'"
    # 'extrude out a foot'
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 338 "Serial Bridge uR1"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,49], False)
    # end: URCap Program Node
    $ 339 "Set DO[0]=On"
    set_standard_digital_out(0, True)
    $ 340 "Wait: 24.0"
    sleep(24.0)
    # begin: URCap Program Node
    #   Source: WireTank Serial, 4.9.0, WireTank, LLC
    #   Type: WireTank Serial
    $ 341 "Serial Bridge uR0"
    SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
    # end: URCap Program Node
    $ 342 "Wait: 1.0"
    sleep(1.0)
    $ 343 "Set DO[0]=Off"
    set_standard_digital_out(0, False)
    $ 344 "'slice'"
    # 'slice'
    $ 345 "MoveL"
    $ 351 "ek_front" "breakAfter"
    movel(ek_front, a=0.05, v=0.03)
    $ 352 "ek_middle" "breakAfter"
    movel(ek_middle, a=0.05, v=0.03)
    $ 353 "ek_middle2" "breakAfter"
    movel(ek_middle2, a=0.05, v=0.03)
    $ 354 "ek_bottom" "breakAfter"
    movel(ek_bottom, a=0.05, v=0.03)
    $ 355 "ek_end" "breakAfter"
    movel(ek_end, a=0.05, v=0.03)
    $ 356 "MoveJ"
    $ 358 "ek_oldhome" "breakAfter"
    movej(ek_oldhome, a=1.3962634015954636, v=1.0471975511965976)
    $ 359 "'above waypoint is home'"
    # 'above waypoint is home'
  end
  def Cover_LT_Homing():
    $ 361 "Cover_LT_Homing" "noBreak"
    $ 362 "Set"
    set_tcp(p[0.0018451128039461973,-0.015648957570072047,0.2843339884457262,0.0,0.0,0.0])
    $ 363 "'assume the person has just taught the right point and pressed continue.'"
    # 'assume the person has just taught the right point and pressed continue.'
    $ 370 "Wait: 1.0"
    sleep(1.0)
    $ 373 "path_pre≔get_coverlt_homing_pathpoints(tcp_pose_left,tcp_pose_right)"
    global path_pre=get_coverlt_homing_pathpoints(tcp_pose_left,tcp_pose_right)
    $ 374 "ph1≔path_pre[0]"
    global ph1=path_pre[0]
    $ 375 "ph2≔path_pre[1]"
    global ph2=path_pre[1]
    $ 378 "MoveL"
    $ 379 "Direction: Base Z+"
    global move_thread_flag_379=0
    thread move_thread_379():
      enter_critical
      move_thread_flag_379 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [0.0,0.0,1.0], 0.1)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_379 = 2
      exit_critical
    end
    move_thread_flag_379 = 0
    move_thread_han_379 = run move_thread_379()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_379 > 1):
        join move_thread_han_379
        $ 380 "Until (distance)"
        break
      end
      sync()
    end
    $ 381 "MoveL"
    $ 382 "ph2" "breakAfter"
    movel(ph2, a=0.2, v=0.25)
    $ 383 "MoveL"
    $ 384 "Direction: Base Z-"
    global move_thread_flag_384=0
    thread move_thread_384():
      enter_critical
      move_thread_flag_384 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [0.0,0.0,-1.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_384 = 2
      exit_critical
    end
    move_thread_flag_384 = 0
    move_thread_han_384 = run move_thread_384()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_384
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 385 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 386 "p12≔get_actual_tcp_pose()"
    global p12= get_actual_tcp_pose ()
    $ 387 "MoveL"
    $ 388 "ph2" "breakAfter"
    movel(ph2, a=1.2, v=0.25)
    $ 389 "ph1" "breakAfter"
    movel(ph1, a=1.2, v=0.25)
    $ 390 "MoveL"
    $ 391 "Direction: Base Z-"
    global move_thread_flag_391=0
    thread move_thread_391():
      enter_critical
      move_thread_flag_391 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [0.0,0.0,-1.0], 1000.0)
      movel(towardsPos, a=0.1, v=0.02)
      move_thread_flag_391 = 2
      exit_critical
    end
    move_thread_flag_391 = 0
    move_thread_han_391 = run move_thread_391()
    while (True):
      local targetTcpDirection=get_target_tcp_speed()
      local stepsToRetract=tool_contact(direction=targetTcpDirection)
      if (stepsToRetract > 0):
        kill move_thread_han_391
        stopl(3.0)
        local backTrackMovement=get_actual_joint_positions_history(stepsToRetract)
        local contactPose=get_forward_kin(backTrackMovement)
        local posDir=[targetTcpDirection[0],targetTcpDirection[1],targetTcpDirection[2]]
        local retractTo=contactPose
        if (norm(posDir) > 1e-6):
          local normalizedPosDir=normalize(posDir)
          local additionalRetraction=p[normalizedPosDir[0] * 0.0, normalizedPosDir[1] * 0.0, normalizedPosDir[2] * 0.0, 0, 0, 0]
          retractTo = pose_sub(contactPose, additionalRetraction)
        end
        movel(retractTo, a=3.0, v=0.1)
        $ 392 "Until (tool_contact_detection)"
        break
      end
      sync()
    end
    $ 400 "p11≔get_actual_tcp_pose()"
    global p11= get_actual_tcp_pose ()
    $ 401 "MoveJ"
    $ 402 "ph1" "breakAfter"
    movej(ph1, a=1.3962634015954636, v=1.0471975511965976)
    $ 403 "MoveJ"
    $ 404 "ph1" "breakAfter"
    movej(ph1, a=1.3962634015954636, v=1.0471975511965976)
    $ 405 "MoveJ"
    $ 406 "Waypoint_2" "breakAfter"
    movej(get_inverse_kin(Waypoint_2_p, qnear=Waypoint_2_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 407 "Home"
    movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  end
  $ 2 "BeforeStart"
  $ 90 "'for this, dont have to worry about the normal stuff. just send it up and home'"
  # 'for this, dont have to worry about the normal stuff. just send it up and home'
  $ 91 "Cover Safe Home Folder"
  $ 92 "'if robot is not at home, send it back to home safely'"
  # 'if robot is not at home, send it back to home safely'
  $ 93 "'make sure the tcp is welder'"
  # 'make sure the tcp is welder'
  $ 94 "Set"
  set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
  $ 95 "sp≔get_actual_tcp_pose()"
  global sp= get_actual_tcp_pose ()
  $ 96 "MoveL"
  $ 97 "sp" "breakAfter"
  movel(sp, a=1.2, v=0.25)
  $ 98 "'if first move is to a variable, skip automove'"
  # 'if first move is to a variable, skip automove'
  $ 99 "'turn off welder'"
  # 'turn off welder'
  # begin: URCap Program Node
  #   Source: WireTank Serial, 4.9.0, WireTank, LLC
  #   Type: WireTank Serial
  $ 100 "Serial Bridge uR0"
  SerialResponse = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", [252,82,48], False)
  # end: URCap Program Node
  $ 101 "Set DO[0]=Off"
  set_standard_digital_out(0, False)
  $ 102 "jp≔get_actual_joint_positions()"
  global jp= get_actual_joint_positions ()
  $ 103 "If sp[0]>0.600"
  if (sp[0]>0.600):
    $ 104 "'if x > 600 then above then home'"
    # 'if x > 600 then above then home'
    $ 105 "MoveJ"
    $ 107 "Waypoint_76" "breakAfter"
    movej(get_inverse_kin(Waypoint_76_p, qnear=Waypoint_76_q), a=1.3962634015954636, v=1.0471975511965976)
    $ 108 "Home"
    movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  else:
    $ 109 "Else" "noBreak"
    $ 110 "Popup: retreating to home"
    popup("retreating to home", "Message", False, False, blocking=True)
    $ 111 "MoveL"
    $ 112 "Direction: Base Z+"
    global move_thread_flag_112=0
    thread move_thread_112():
      enter_critical
      move_thread_flag_112 = 1
      local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [0.0,0.0,1.0], 0.1)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_112 = 2
      exit_critical
    end
    move_thread_flag_112 = 0
    move_thread_han_112 = run move_thread_112()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_112 > 1):
        join move_thread_han_112
        $ 113 "Until (distance)"
        break
      end
      sync()
    end
    $ 117 "'insert logic for how to get back to oldhome'"
    # 'insert logic for how to get back to oldhome'
    $ 118 "'finish with oldhome then above then home'"
    # 'finish with oldhome then above then home'
    $ 123 "Home"
    movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  end
  $ 408 "Thread_1"
  thread Thread_1():
    $ 409 "Loop  True "
    while (  True  ):
      $ 410 "If freedrive_m_var≟ True "
      if (freedrive_m_var ==   True  ):
        $ 411 "freedrive_mode()"
        freedrive_mode()
        $ 412 "free_dr_already≔ True "
        global free_dr_already=  True  
      else:
        $ 413 "Else" "noBreak"
        $ 414 "If free_dr_already"
        if (free_dr_already):
          $ 415 "end_freedrive_mode()"
          end_freedrive_mode()
        end
      end
      $ 416 "sync()"
      sync()
    end
  end
  threadId_Thread_1 = run Thread_1()
  $ 125 "Robot Program"
  $ 126 "'start of main program'"
  # 'start of main program'
  $ 127 "Set"
  set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
  $ 128 "Home"
  movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
  $ 129 "Script: common_math.script"
  # this file contains math equations and operations, not specific to any one feature
  
  # define pi
  pi = 3.1415926535
  
  # given 3 points, this finds the plane and its equation
  # rereturns ax + by + cz + d = 0 in a list of [a, b, c, d]
  def findplane(p11, p12, p13):
      # extract coordinates
      x1 = p11[0]
      y1 = p11[1]
      z1 = p11[2]
      x2 = p12[0]
      y2 = p12[1]
      z2 = p12[2]
      x3 = p13[0]
      y3 = p13[1]
      z3 = p13[2]
      # create vectors from the points
      v1x = x2-x1
      v1y = y2-y1
      v1z = z2-z1
      v2x = x3-x1
      v2y = y3-y1
      v2z = z3-z1
      #calculate the normal vector using the cross product
      nx = v1y*v2z - v1z*v2y # i component
      ny = v1z*v2x - v1x*v2z # j component
      nz = v1x*v2y - v1y*v2x # k component
      # calculate d in the plane equation
      d = -1 * (nx*x1 + ny*y1 + nz*z1)
      ret = [nx, ny, nz, d]
      return ret
  end
  
  # this function finds the intersection point between two lines in the xy plane
  # takes 4 arguments: m1, b1, m2, b2
  # returns a list of [x,y] (the point of intersection)
  def find_intersection(m1, b1, m2, b2):
    # m1x+b1 = m2x+b2
    # m1x - m2x = b2 - b1
    # x = (b2-b1) / (m1-m2)
    x = (b2-b1) / (m1-m2)
    y = m1 * x + b1
    ret = [x, y]
    return ret
  end
  
  # this function finds the distance between 2 points in 3d space
  # it takes 6 arguments: x1, y1, z1, x2, y2, z2
  # it returns a distance
  def distance_between(x1, y1, z1, x2, y2, z2):
    distsquared = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)+(z2-z1)*(z2-z1)
    dist = sqrt(distsquared)
    return dist
  end
  
  # this function takes a point, a unit vector, and a distance, and adds the distance to the point in the direction of the unit vector (3d space)
  # it returns a point as a list of coordinates
  def add_vectordistance_to_point(xi, yi, zi, uvx, uvy, uvz, delta):
    xf = xi + uvx * delta
    yf = yi + uvy * delta
    zf = zi + uvz * delta
    ret = [xf, yf, zf]
    return ret
  end
  
  # this function takes two rotation matrices, and multiplies them together, returning one matrix.
  # all matrices are in the form of a list.
  # all matrix values have constant values (no variables)
  def multiply_matrix(matrix1, matrix2):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
      b11 = matrix2[0]
      b12 = matrix2[1]
      b13 = matrix2[2]
      b21 = matrix2[3]
      b22 = matrix2[4]
      b23 = matrix2[5]
      b31 = matrix2[6]
      b32 = matrix2[7]
      b33 = matrix2[8]
      #calculate c values
      c11 = a11*b11 + a12*b21 + a13*b31
      c12 = a11*b12 + a12*b22 + a13*b32
      c13 = a11*b13 + a12*b23 + a13*b33
      c21 = a21*b11 + a22*b21 + a23*b31
      c22 = a21*b12 + a22*b22 + a23*b32
      c23 = a21*b13 + a22*b23 + a23*b33
      c31 = a31*b11 + a32*b21 + a33*b31
      c32 = a31*b12 + a32*b22 + a33*b32
      c33 = a31*b13 + a32*b23 + a33*b33
      # return resulting matrix
      ret = [c11, c12, c13, c21, c22, c23, c31, c32, c33]
      return ret
  end
  
  # this function converts a matrix to axis angle representations
  # this matrix is usually a resulting matrix (result of matrix multiplication) in normal use, given as a list
  # returns a list of [rx,ry,rz]
  def convert_matrix_to_axang(matrix1):
      # retrieve values
      a11 = matrix1[0]
      a12 = matrix1[1]
      a13 = matrix1[2]
      a21 = matrix1[3]
      a22 = matrix1[4]
      a23 = matrix1[5]
      a31 = matrix1[6]
      a32 = matrix1[7]
      a33 = matrix1[8]
  
      # First Half: find the angle
      # find the trace
      # using the formula: trace = a11 + a22 + a33
      trace = a11 + a22 + a33
      # find the angle using the formula: trace(matrix) = 1 + 2 cos(angle)
      angle = acos((trace - 1.0)/2.0)
  
      # Second Half: calculate the rotation axis
      axisxraw = a32 - a23
      axisyraw = a13 - a31
      axiszraw = a21 - a12
      # normalize axis
      magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
      axisxunit = axisxraw / magnitude
      axisyunit = axisyraw / magnitude
      axiszunit = axiszraw / magnitude
  
      # combine axis and angle into rxryrz representation
      rxout = axisxunit * angle
      ryout = axisyunit * angle
      rzout = axiszunit * angle
      return [rxout, ryout, rzout]
  end
  
  # this function takes a rotation and calculates the corresponding rotation matrix
  # input is (axis, direction, angle in radians)
  # example is ("x", 1, pi/6) = a 30 degree turn around the x axis in the positive direction (right hand rule)
  # returns a matrix (a list of 9 values)
  def get_rotation_matrix_from_description(axis, direction, angle):
      # get the angle
      a = angle * direction
      # get the axis
      if axis == "x" or axis == "X":
          matrix = [1, 0, 0, 0, cos(a), -1 * sin(a), 0, sin(a), cos(a)]
          return matrix
      end
      if axis == "y" or axis == "Y":
          matrix = [cos(a), 0, sin(a), 0, 1, 0, -1*sin(a), 0, cos(a)]
          return matrix
      end
      if axis == "z" or axis == "Z":
          matrix = [cos(a), -1*sin(a), 0, sin(a), cos(a), 0, 0, 0, 1]
          return matrix
      end
      # bad
      popuptext = "Error in get_rotation_matrix_from_description. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Code Error",blocking=True)
      end
  end
  
  # given a round over distance (in mm), calculate (based on 90 degrees) the distance from corner (line intersection) to midpoint of arc
  # returns a value (in mm) that you need to move from line intersection to midpoint (actual distance will be this times sqrt(2))
  def calc_rod_midpoint_90deg(rod):
      # the factor is (1- 1/sqrt(2))
      factor = 0.292893
      ret = rod * factor
      return ret
  end
  
  def crossproduct(vec1, vec2):
      nx = vec1[1]*vec2[2] - vec1[2]*vec2[1]
      ny = vec1[2]*vec2[0] - vec1[0]*vec2[2]
      nz = vec1[0]*vec2[1] - vec1[1]*vec2[0]
      ret = [nx, ny, nz]
      return ret
  end
  
  # Section: headings, angles, slopes conversions
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the bottom side of the gun facing up.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang(heading):
   axisxraw = -1 * sin(heading)
   axisyraw = cos(heading) + 1
   axiszraw = sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing up. Used for welding in a vertical path.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatup(heading):
   axisxraw = -sin(heading) + 1
   axisyraw = cos(heading)
   axiszraw = cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing down. Used for welding in a vertical path downwards.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_preheatdown(heading):
   axisxraw = -sin(heading) - 1
   axisyraw = cos(heading)
   axiszraw = -cos(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (sin(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # this function converts a heading (ccw radians from the positive x axis) into rxryrz to be put into a point p[]
  # this will point the gun in this heading with the preheat side of the gun tip facing right. Used for welding counterclockwise around the box.
  # the values used in this program were calculated by doing rotation matrix math in the file on WI-CALVINB10 C. Documents. Theory for converting rotations into axis angle representations
  def convert_heading_to_axang_ccw(heading):
   axisxraw = -sin(heading)
   axisyraw = cos(heading) - 1
   axiszraw = -sin(heading)
  
   magnitude = sqrt(axisxraw*axisxraw + axisyraw*axisyraw + axiszraw*axiszraw)
  
   axisxunit = axisxraw / magnitude
   axisyunit = axisyraw / magnitude
   axiszunit = axiszraw / magnitude
  
   angle = acos( (-cos(heading) - 1) / 2 )
  
   rxout = axisxunit * angle
   ryout = axisyunit * angle
   rzout = axiszunit * angle
  
   return [rxout, ryout, rzout]
  end
  
  # given a heading, (ccw from +x axis), find the mx+b slope
  # fails if exactly vertical
  def get_slope_from_heading(heading):
      return tan(heading)
  end
  
  # this function converts a unit vector to its heading angle ccw from x+ axis
  # takes uvx and uvy
  # returns heading in radians
  def convert_uv_to_heading(uvx, uvy):
    baseang = atan(uvy/uvx)
    if uvx < 0:
      ang = baseang + pi
    elif uvy < 0:
      ang = baseang + pi * 2
    else:
      ang = baseang
    end
    return ang
  end
  
  # this function finds the equation of a line, perpendicular to a given line, and going through a given point
  # takes 3 arguments: m (the original line's slope), x (point's x coord), y (point's y coord). the b of the original line is not needed
  # returns a list of [m,b] (the slope and intercept of the new line)
  def find_perpendicular_line(origm, x, y):
    m = (1/origm) * -1
    b = y - m*x
    ret = [m, b]
    return ret
  end
  
  # returns the absolute value of a number
  def absolute(x):
      ret = x
      if x < 0:
          ret = -1 * x
      end
      return ret
  end
  $ 130 "Script: common_io.script"
  # common_io.script
  # this file contains IO (input/output) commands, commonly used by robot programs
  # includes rs232 commands, lift column commands, and calls to native universal robots functions (like get_inverse_kin_has_solution())
  
  
  # Section: rs232 commands ###############################
  
  # this function sends a signal to turn extrusion on
  def turn_extrusion_on():
    # flush the channel
    resp0 = send_serial_signal(["u", "r", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "R", "1"])
    # if resp <> "uR1"
    if resp1 != [252,82,49]:
      # turn off extrusion and heating. inform calvin
      resp2 = send_serial_signal(["u", "R", "0"])
      resp3 = send_serial_signal(["u", "H", "0"])
      popuptext = "Error code encountered while trying to start extrusion. Find Calvin. "
      while 1==1:
        popup(popuptext, title="Extrusion Error Code",blocking=True)
        popup(resp1, blocking=True)
      end
    end
  end
  
  # this function sends a signal and receives a response
  # signal is a list of 3 strings, 1 character each. first is u. second is the next character. third is final character
  def send_serial_signal(signal):
    signal2char = signal[1]
    signal3char = signal[2]
    listsignal = [252, get_corr_number(signal2char), get_corr_number(signal3char)]
    resp1 = WTSerialBridge.send_command("/dev/ttyUSB0",1200, 8, "None", "One", "None", 1000, "None", "None", listsignal, True)
    return resp1
  end
  
  # this function converts a letter into its ascii number
  def get_corr_number(letter):
    if letter == "A":
      return 65
    elif letter == "H":
      return 72
    elif letter == "R":
      return 82
    elif letter == "M":
      return 77
    elif letter == "E":
      return 69
    elif letter == "a":
      return 97
    elif letter == "b":
      return 98
    elif letter == "h":
      return 104
    elif letter == "r":
      return 114
    elif letter == "s":
      return 115
    elif letter == "m":
      return 109
    elif letter == "0":
      return 48
    elif letter == "1":
      return 49
    elif letter == "2":
      return 50
    elif letter == "3":
      return 51
    elif letter == "4":
      return 52
    elif letter == "5":
      return 53
    elif letter == "6":
      return 54
    elif letter == "7":
      return 55
    elif letter == "8":
      return 56
    elif letter == "9":
      return 57
    elif letter == "?":
      return 63
    end
  end
  
  # this function checks whether the welder is in the ready state.
  # to be called at the beginning of Main Program
  def welder_state_ready():
    # flush the channel
    resp0 = send_serial_signal(["u", "s", "?"])
    # send the signal
    resp1 = send_serial_signal(["u", "s", "?"])
    # if resp1 == [252,115,49] (us1) then it is ready. otherwise, it is not
    if resp1 != [252,115,49]:
      popuptext = "Welder is not ready for extrusion. Follow the instructions to start heating welder. "
      while 1==1:
        popup(popuptext, title="Welder Not Ready",blocking=True)
      end
    end
  
  end
  
  
  # Section: lift column commands ##################################
  
  # initialize a lift column extension needed of 0.0
  global liftcolumnzneeded = 0.0 # set this variable in mm
  
  def get_lift_column_height():
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    #$ 5 "MachineLogic Get Position"
    while isVentionMovementBusyMachineMotion1==True:
      sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
      isVentionMovementBusyMachineMotion1 = True
      socket_send_string("estop/status;", "MachineMotion1")
      temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
      while(temp_estop_var_vention=="estop/status true"):
        if temp_estop_var_vention=="estop/status true":
          sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
        end
        socket_send_string("estop/status;", "MachineMotion1")
        temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
        if temp_estop_var_vention=="estop/status true":
          popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
        end
      end
    else:
      popup("resource is being used already: MachineMotion1")
      halt
    end
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    global var_1 = temp_drive[1]
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
  end
  
  
  def get_lift_column_height_condensed():
    socket_send_string("GET im_get_controller_pos_axis_1;", "MachineMotion1")
    temp_drive = socket_read_ascii_float(1, "MachineMotion1",timeout=15)
    ret = temp_drive[1]
    return ret
  end
  
  
  # Section: Native UR commands ###################################
  
  # this function takes a struct of points as an argument, and checks whether every point in the list is reachable using get_inverse_kin_has_solution()
  # this function does NOT check for weird twists or joint limits
  # inputstruct must contain only points
  # it returns true if all points are valid. it returns false if any points are valid
  # a list of length 0 indicates that all points are valid
  def check_structofpoints_validity(inputstruct):
    # next, check whether the touchpoints are reachable
    structlength = length(inputstruct)
    i = 0
    allvalid = True
    while i < structlength:
      curr = inputstruct[i]
      valid = get_inverse_kin_has_solution(curr)
      if not valid:
        return False
      end
      i = i + 1
    end
    return True
  end
  
  
  # this function takes in a struct of only points. it checks those points for validity.
  # if one of them is not valid, it throws a popup loop
  def check_validity_only(struct2):
    validity = check_structofpoints_validity(struct2)
    if not validity:
      # bad
      popuptext = "Not all weldpoints are valid. "
      # infinite loop
      while 1==1:
        popup(popuptext, title="Position Error",blocking=True)
      end
    end
  end
  
  
  # this function calculates whether a given pose can be reached, and if it can, whether it requires a wrist twist (from the seed joint angles)
  # arguments are target pose (p[x,y,z,rx,ry,rz]) and orig_joints which is the 6 joint angles of a pose that is close by the target pose and has the desired joint angles
  # returns true if the pose is valid and requires no twist. If pose is valid but requires a twist, returns false. If pose is invalid, returns false.
  def can_pose_be_reached_without_twist(pose, orig_joints):
    # first, determine if the pose is valid
    valid = get_inverse_kin_has_solution(pose)
    if not valid:
      return False
    end
    valid = get_inverse_kin_has_solution(pose, orig_joints)
    if not valid:
      return False
    else:
      joints_1 = get_inverse_kin(pose, orig_joints)
      #iterate through the 6 joints
      allGood = True
      i = 0
      structlength = 6
      while i < structlength:
        joint_curr = joints_1[i]
        # check for anything that exceeds joint limits
        degreesmax = 360 * pi / 180
        if joint_curr > degreesmax or joint_curr < degreesmax * -1:
          allGood = False
        end
        # check for anything that is significantly different than the aligned approach. could indicate a twist is needed. we dont want that
        maxdifference = 150 * pi / 180
        difference = joint_curr - orig_joints[i]
        if difference > maxdifference or difference * -1 > maxdifference:
          allGood = False
        end
        i = i + 1
      end
      return allGood
    end
  end
  $ 131 "Script: analyze_coverlt.script"
  def main_calculate_cover_lt(p11, p12, leftpoint, rightpoint):
      struct1 = analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint)
      struct2 = calculate_points_cover_lt(struct1)
      #struct2 = calculate_DOtA_points_left_extended(struct1, list1, chamferover, chamferup, tcp_pose_top)
      #struct3 = check_validity_left(struct1, struct2)
      return struct2
  
  end
  
  def analyze_touchpoints_only_cover_lt(p11, p12, leftpoint, rightpoint):
      # calculate the slope of the groove in xy plane
      l1p1x = leftpoint[0]
      l1p1y = leftpoint[1]
      l1p2x = rightpoint[0]
      l1p2y = rightpoint[1]
  
      # equate the first line in 2d space
      ml1 = (l1p2y-l1p1y) / (l1p2x-l1p1x)
  
      # b = y - mx
      bl1 = l1p1y - ml1 * l1p1x
  
      # zraise (how much the z value changes from left point to right point
      zraise = p12[2] - p11[2]
  
      #get the calcpoints
      leftcalcpoint = [leftpoint[0], leftpoint[1], p11[2]]
      rightcalcpoint = [rightpoint[0], rightpoint[1], p12[2]]
      # get the vector from a to b
      vec = [rightcalcpoint[0] - leftcalcpoint[0], rightcalcpoint[1] - leftcalcpoint[1], rightcalcpoint[2] - leftcalcpoint[2]]
      # get the unit vector in 3d
      mag3d = sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])
      vec3dunit = [vec[0]/mag3d, vec[1]/mag3d, vec[2]/mag3d]
      # get the unit vector in 2d
      mag2d = sqrt(vec[0]*vec[0]+vec[1]*vec[1])
      vec2dunit = [vec[0]/mag2d, vec[1]/mag2d]
      # get the heading
      heading1 = convert_uv_to_heading(vec2dunit[0], vec2dunit[1])
  
      ret = struct(leftcalcpoint=leftcalcpoint, rightcalcpoint=rightcalcpoint, vxunit=vec3dunit[0], vyunit=vec3dunit[1], vzunit=vec3dunit[2], heading1=heading1)
      return ret
  end
  
  def calculate_points_cover_lt(struct1):
      # get the stuff from struct
      leftcalcpoint = struct1[0]
      x = leftcalcpoint[0]
      y = leftcalcpoint[1]
      z = leftcalcpoint[2]
      rightcalcpoint = struct1[1]
      x2 = rightcalcpoint[0]
      y2 = rightcalcpoint[1]
      z2 = rightcalcpoint[2]
      v3xunit = struct1[2]
      v3yunit = struct1[3]
      v3zunit = struct1[4]
      heading1 = struct1[5]
  
      # first calculate rxryrz f normal and tiltback
      # calculate rxryrz for tilted back
      # 3 rotations to make this happen.
      # start point is straight up with the preheat pointed in the +y direction.
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # second rotation is a 10 degree turn about the x axis (negative direction)
      m2 = get_rotation_matrix_from_description("x", -1, 10 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      # combine them by multiplying m3 * m2 * m1
      # matrix multiplication is not commutative but it IS associative, so you can do this whichever order
      m4 = multiply_matrix(m2, m1)
      m5 = multiply_matrix(m3, m4)
      rxryrzt = convert_matrix_to_axang(m5)
      rxt = rxryrzt[0]
      ryt = rxryrzt[1]
      rzt = rxryrzt[2]
  
      # calculate rxryrz for nontilted
      # first rotation is 180 degrees about x direction. gun is now pointing straight down with preheat facing -y direction
      m1 = get_rotation_matrix_from_description("x", 1, 180 * pi / 180)
      # third rotation is about 180 degrees about the z axis. starting from the -y axis, go until you get to heading1. that will equal heading1 plus 90 degrees
      m3 = get_rotation_matrix_from_description("z", 1, pi/2 + heading1)
      m5 = multiply_matrix(m3, m1)
      rxryrz = convert_matrix_to_axang(m5)
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      tiltraise = 0.006 # 6 mm raise needed for the tip to clear the plane during tiltback
  
      # calculate points 1-3
      # calculate point1 (preheat)
      dist = -1 * 25.4 / 1000.0 # move back 1 inch from
      p1x = x + dist * v3xunit
      p1y = y + dist * v3yunit
      p1z = z + dist * v3zunit + tiltraise
      point1 = p[p1x, p1y, p1z, rxt, ryt, rzt]
  
      # calculate point2 (start of flatten)
      dist = 0.5 * 25.4 / 1000.0  # half an inch past the top of v chamfer
      p2x = x + dist * v3xunit
      p2y = y + dist * v3yunit
      p2z = z + dist * v3zunit + tiltraise
      point2 = p[p2x, p2y, p2z, rxt, ryt, rzt]
  
      # calculate point3 (end of flatten)
      dist = 1.5 * 25.4 / 1000.0  # 1.5 inches past top of v chamfer
      p3x = x + dist * v3xunit
      p3y = y + dist * v3yunit
      p3z = z + dist * v3zunit
      point3 = p[p3x, p3y, p3z, rx, ry, rz]
  
      # calculate points 4-6
      # calculate point4 (start of unflatten)
      dist = -1.5 * 25.4 / 1000.0
      p4x = x2 + v3xunit * dist
      p4y = y2 + v3yunit * dist
      p4z = z2 + v3zunit * dist
      point4 = p[p4x, p4y, p4z, rx, ry, rz]
  
      # calculate point5 (end of unflatten)
      dist = -0.5 * 25.4 / 1000.0
      p5x = x2 + v3xunit * dist
      p5y = y2 + v3yunit * dist
      p5z = z2 + v3zunit * dist + tiltraise
      point5 = p[p5x, p5y, p5z, rxt, ryt, rzt]
  
      # calculate point6 (end of smear)
      dist = 2 * 25.4 / 1000.0
      p6x = x2 + v3xunit * dist
      p6y = y2 + v3yunit * dist
      p6z = z2 + v3zunit * dist + tiltraise
      point6 = p[p6x, p6y, p6z, rxt, ryt, rzt]
  
      # return struct
      ret = struct(pointtopvcham=leftcalcpoint, point1=point1, point2=point2, point3=point3, point4=point4, point5=point5, point6=point6)
      return ret
  
  end
  
  
  # this function determines the starting touchpoints for homing in on cover lt geometry
  # includes two points above the cover lt, closer to the robot than the lt, facing down
  def get_coverlt_homing_pathpoints(leftpoint, rightpoint):
      # get the teach position points
      lpx = leftpoint[0]
      lpy = leftpoint[1]
      lpz = leftpoint[2]
      rpx = rightpoint[0]
      rpy = rightpoint[1]
      rpz = rightpoint[2]
  
      # determine if the points are parallel (to the tank) or perpendicular
      xdelt = absolute(lpx - rpx)
      ydelt = absolute(lpy - rpy)
      xvcut = False
      if xdelt > ydelt:
          xvcut = True
      end
  
      # specify the distances from (in meters)
      d0 = 0.05 # how far from the cover to approach from
      d1 = 0.03 # how far the touchpoints are pushed closer to the robot, offset from the groove
      d2 = 0.00 # how far inwards the touchpoints are pushed
  
      # rxryrz of left point (point 1, taken second): preheat back towards robot to avoid collision with divider wall
      rxryrz = [2.014, -2.411, 0]
      rx = rxryrz[0]
      ry = rxryrz[1]
      rz = rxryrz[2]
  
      # calculate the points
      ph1 = p[lpx + d1, lpy + d2, lpz + d0, rx, ry, rz] # left side approach
      if xvcut:
          ph1 = p[lpx, lpy - d1, lpz + d0, rx, ry, rz] # left side approach
      end
  
      # rxryrz of right point (point 2, taken first): preheat to the left (front) of the tank.
      rxryrz2 = [0.334, 3.124, 0]
      rx2 = rxryrz2[0]
      ry2 = rxryrz2[1]
      rz2 = rxryrz2[2]
  
      ph2 = p[rpx + d1, rpy - d2, rpz + d0, rx2, ry2, rz2] # right side approach
      if xvcut:
          ph2 = p[rpx, rpy - d1, rpz + d0, rx2, ry2, rz2] # right side approach
      end
  
      ret = struct(ph1=ph1, ph2=ph2)
      check_validity_only(ret)
      return ret
  end
  $ 137 "MoveJ"
  $ 138 "Waypoint_46" "breakAfter"
  movej(get_inverse_kin(Waypoint_46_p, qnear=Waypoint_46_q), a=1.3962634015954636, v=1.0471975511965976)
  $ 139 "Set"
  set_tcp(p[0.0018451128039461973,-0.015648957570072047,0.2843339884457262,0.0,0.0,0.0])
  $ 140 "Test_Teach_Cover_LT()"
  Test_Teach_Cover_LT()
  $ 141 "Set"
  set_tcp(p[0.0018451128039461973,-0.015648957570072047,0.2843339884457262,0.0,0.0,0.0])
  $ 142 "kill threadId_Thread_1"
  kill threadId_Thread_1
  $ 143 "Cover_LT_Homing()"
  Cover_LT_Homing()
  $ 144 "Set"
  set_tcp(p[-0.009269999999999999,-0.328,0.10571,1.2092,-1.2092,1.2092])
  $ 149 "pathturn≔main_calculate_cover_lt(p11,p12, tcp_pose_left, tcp_pose_right)"
  global pathturn=main_calculate_cover_lt(p11,p12, tcp_pose_left, tcp_pose_right)
  $ 150 "extrude knife"
  $ 151 "lch≔get_lift_column_height_condensed()"
  global lch=get_lift_column_height_condensed()
  $ 152 "If lch > 1"
  if (lch > 1):
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    $ 153 "MachineLogic Homing"
    while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    while(temp_estop_var_vention=="estop/status true"):
    if temp_estop_var_vention=="estop/status true":
    sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
    end
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    if temp_estop_var_vention=="estop/status true":
    popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
    end
    end
    else:
    popup("resource is being used already: MachineMotion1")
    halt
    end
    isVentionMovementBusyMachineMotion1 = True
    sendString("im_home_axis_1", "MachineMotion im_home_axis_1 = completed", "MachineMotion1")
    isVentionMovementBusyMachineMotion1 = False
    sendString("SET im_set_encoder_pos_aux_1 0.000", "Ack", "MachineMotion1")
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
    $ 154 "extrude_knife3()"
    extrude_knife3()
    # begin: URCap Program Node
    #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
    #   Type: MachineLogic for Universal Robots
    $ 155 "MachineLogic Move to Position"
    while isVentionMovementBusyMachineMotion1==True:
    sleep(0.05)
    end
    if(isVentionMovementBusyMachineMotion1 == False):
    isVentionMovementBusyMachineMotion1 = True
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    while(temp_estop_var_vention=="estop/status true"):
    if temp_estop_var_vention=="estop/status true":
    sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
    end
    socket_send_string("estop/status;", "MachineMotion1")
    temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
    if temp_estop_var_vention=="estop/status true":
    popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
    end
    end
    else:
    popup("resource is being used already: MachineMotion1")
    halt
    end
    sendString("SET speed_v2 3000000.000", "Ack", "MachineMotion1")
    sendString("SET acceleration_v2 50000.000", "Ack", "MachineMotion1")
    string_vention=intToString(lch*1000,"MachineMotion1")
    sendString("SET de_move_abs_1 "+string_vention, "Ack", "MachineMotion1")
    sendString("de_move_abs_exec", "Ack", "MachineMotion1")
    isVentionParallelMovementSendingScriptMachineMotion1 = False
    pollString("isMotionCompleted", "MachineMotion isMotionCompleted = true", "MachineMotion1")
    isVentionMovementBusyMachineMotion1 = False
    sleep(0.03)
    # end: URCap Program Node
  else:
    $ 156 "Else" "noBreak"
    $ 157 "extrude_knife3()"
    extrude_knife3()
  end
  $ 163 "align_for_cover_straight()"
  align_for_cover_straight()
  $ 164 "move_path_cover_lt()"
  move_path_cover_lt()
  $ 165 "MoveJ"
  $ 166 "Waypoint_8" "breakAfter"
  movej(get_inverse_kin(Waypoint_8_p, qnear=Waypoint_8_q), a=1.3962634015954636, v=1.0471975511965976)
  $ 167 "Waypoint_9" "breakAfter"
  movej(get_inverse_kin(Waypoint_9_p, qnear=Waypoint_9_q), a=1.3962634015954636, v=1.0471975511965976)
  # begin: URCap Program Node
  #   Source: MachineLogic for Universal Robots, 3.1.7, Vention Inc.
  #   Type: MachineLogic for Universal Robots
  $ 168 "MachineLogic Homing"
  while isVentionMovementBusyMachineMotion1==True:
  sleep(0.05)
  end
  if(isVentionMovementBusyMachineMotion1 == False):
  isVentionMovementBusyMachineMotion1 = True
  socket_send_string("estop/status;", "MachineMotion1")
  temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
  while(temp_estop_var_vention=="estop/status true"):
  if temp_estop_var_vention=="estop/status true":
  sendStringWithTimeout("estop/systemreset/request","Ack estop/systemreset/request;","MachineMotion1")
  end
  socket_send_string("estop/status;", "MachineMotion1")
  temp_estop_var_vention = socket_read_string("MachineMotion1",timeout=15)
  if temp_estop_var_vention=="estop/status true":
  popup("MachineMotion in estop, make sure you have all emergency modules released manually. If you continue the system will try to reset MachineMotion automatically.",blocking=True)
  end
  end
  else:
  popup("resource is being used already: MachineMotion1")
  halt
  end
  isVentionMovementBusyMachineMotion1 = True
  sendString("im_home_axis_1", "MachineMotion im_home_axis_1 = completed", "MachineMotion1")
  isVentionMovementBusyMachineMotion1 = False
  sendString("SET im_set_encoder_pos_aux_1 0.000", "Ack", "MachineMotion1")
  isVentionMovementBusyMachineMotion1 = False
  sleep(0.03)
  # end: URCap Program Node
  $ 169 "Home"
  movej([-3.266929759358355, -1.2139462677784536, 1.5878387874396154, 1.1069165929565088, -0.0023738326664366483, -1.7891447305770605], a=1.3962634015954636, v=1.0471975511965976)
end
